
(function(l, i, v, e) { v = l.createElement(i); v.async = 1; v.src = '//' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; e = l.getElementsByTagName(i)[0]; e.parentNode.insertBefore(v, e)})(document, 'script');
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function create_slot(definition, ctx, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
            : ctx.$$scope.ctx;
    }
    function get_slot_changes(definition, ctx, changed, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
            : ctx.$$scope.changed || {};
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.data !== data)
            text.data = data;
    }
    function set_style(node, key, value) {
        node.style.setProperty(key, value);
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function flush() {
        const seen_callbacks = new Set();
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    callback();
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
    }
    function update($$) {
        if ($$.fragment) {
            $$.update($$.dirty);
            run_all($$.before_update);
            $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        if (component.$$.fragment) {
            run_all(component.$$.on_destroy);
            component.$$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            component.$$.on_destroy = component.$$.fragment = null;
            component.$$.ctx = {};
        }
    }
    function make_dirty(component, key) {
        if (!component.$$.dirty) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty = blank_object();
        }
        component.$$.dirty[key] = true;
    }
    function init(component, options, instance, create_fragment, not_equal, prop_names) {
        const parent_component = current_component;
        set_current_component(component);
        const props = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props: prop_names,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty: null
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, props, (key, value) => {
                if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
                    if ($$.bound[key])
                        $$.bound[key](value);
                    if (ready)
                        make_dirty(component, key);
                }
            })
            : props;
        $$.update();
        ready = true;
        run_all($$.before_update);
        $$.fragment = create_fragment($$.ctx);
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var lodash = createCommonjsModule(function (module, exports) {
    (function() {

      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined$1;

      /** Used as the semantic version number. */
      var VERSION = '4.17.14';

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;

      /** Error message constants. */
      var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
          FUNC_ERROR_TEXT = 'Expected a function';

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /** Used as the maximum memoize cache size. */
      var MAX_MEMOIZE_SIZE = 500;

      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;

      /** Used to compose bitmasks for function metadata. */
      var WRAP_BIND_FLAG = 1,
          WRAP_BIND_KEY_FLAG = 2,
          WRAP_CURRY_BOUND_FLAG = 4,
          WRAP_CURRY_FLAG = 8,
          WRAP_CURRY_RIGHT_FLAG = 16,
          WRAP_PARTIAL_FLAG = 32,
          WRAP_PARTIAL_RIGHT_FLAG = 64,
          WRAP_ARY_FLAG = 128,
          WRAP_REARG_FLAG = 256,
          WRAP_FLIP_FLAG = 512;

      /** Used as default options for `_.truncate`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';

      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 800,
          HOT_SPAN = 16;

      /** Used to indicate the type of lazy iteratees. */
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3;

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e+308,
          NAN = 0 / 0;

      /** Used as references for the maximum length and index of an array. */
      var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

      /** Used to associate wrap methods with their bit flags. */
      var wrapFlags = [
        ['ary', WRAP_ARY_FLAG],
        ['bind', WRAP_BIND_FLAG],
        ['bindKey', WRAP_BIND_KEY_FLAG],
        ['curry', WRAP_CURRY_FLAG],
        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
        ['flip', WRAP_FLIP_FLAG],
        ['partial', WRAP_PARTIAL_FLAG],
        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
        ['rearg', WRAP_REARG_FLAG]
      ];

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          asyncTag = '[object AsyncFunction]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          domExcTag = '[object DOMException]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          nullTag = '[object Null]',
          objectTag = '[object Object]',
          promiseTag = '[object Promise]',
          proxyTag = '[object Proxy]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          undefinedTag = '[object Undefined]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]';

      var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
          reUnescapedHtml = /[&<>"']/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;

      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source);

      /** Used to match leading and trailing whitespace. */
      var reTrim = /^\s+|\s+$/g,
          reTrimStart = /^\s+/,
          reTrimEnd = /\s+$/;

      /** Used to match wrap detail comments. */
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
          reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
          reSplitDetails = /,? & /;

      /** Used to match words composed of alphanumeric characters. */
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;

      /**
       * Used to match
       * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
       */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect host constructors (Safari). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Used to detect unsigned integer values. */
      var reIsUint = /^(?:0|[1-9]\d*)$/;

      /** Used to match Latin Unicode letters (excluding mathematical operators). */
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;

      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

      /** Used to compose unicode character classes. */
      var rsAstralRange = '\\ud800-\\udfff',
          rsComboMarksRange = '\\u0300-\\u036f',
          reComboHalfMarksRange = '\\ufe20-\\ufe2f',
          rsComboSymbolsRange = '\\u20d0-\\u20ff',
          rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
          rsDingbatRange = '\\u2700-\\u27bf',
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsPunctuationRange = '\\u2000-\\u206f',
          rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = '\\ufe0e\\ufe0f',
          rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

      /** Used to compose unicode capture groups. */
      var rsApos = "['\u2019]",
          rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
          rsFitz = '\\ud83c[\\udffb-\\udfff]',
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = '\\u200d';

      /** Used to compose unicode regexes. */
      var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
          rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
          rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
          rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
          rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
          rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

      /** Used to match apostrophes. */
      var reApos = RegExp(rsApos, 'g');

      /**
       * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
       * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
       */
      var reComboMark = RegExp(rsCombo, 'g');

      /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
      var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

      /** Used to match complex or compound words. */
      var reUnicodeWord = RegExp([
        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
        rsUpper + '+' + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join('|'), 'g');

      /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
      var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

      /** Used to detect strings that need a more robust regexp to match words. */
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
      ];

      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;

      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
      typedArrayTags[errorTag] = typedArrayTags[funcTag] =
      typedArrayTags[mapTag] = typedArrayTags[numberTag] =
      typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
      typedArrayTags[setTag] = typedArrayTags[stringTag] =
      typedArrayTags[weakMapTag] = false;

      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
      cloneableTags[boolTag] = cloneableTags[dateTag] =
      cloneableTags[float32Tag] = cloneableTags[float64Tag] =
      cloneableTags[int8Tag] = cloneableTags[int16Tag] =
      cloneableTags[int32Tag] = cloneableTags[mapTag] =
      cloneableTags[numberTag] = cloneableTags[objectTag] =
      cloneableTags[regexpTag] = cloneableTags[setTag] =
      cloneableTags[stringTag] = cloneableTags[symbolTag] =
      cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
      cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[weakMapTag] = false;

      /** Used to map Latin Unicode letters to basic Latin letters. */
      var deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
        '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
        '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
        '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
        '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
        '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
        '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
        '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
        '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
        '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
        '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
        '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
        '\u0134': 'J',  '\u0135': 'j',
        '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
        '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
        '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
        '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
        '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
        '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
        '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
        '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
        '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
        '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
        '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
        '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
        '\u0163': 't',  '\u0165': 't', '\u0167': 't',
        '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
        '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
        '\u0174': 'W',  '\u0175': 'w',
        '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
        '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
        '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
        '\u0132': 'IJ', '\u0133': 'ij',
        '\u0152': 'Oe', '\u0153': 'oe',
        '\u0149': "'n", '\u017f': 's'
      };

      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };

      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'"
      };

      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };

      /** Built-in method references without a dependency on `root`. */
      var freeParseFloat = parseFloat,
          freeParseInt = parseInt;

      /** Detect free variable `global` from Node.js. */
      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

      /** Detect free variable `self`. */
      var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      /** Detect free variable `exports`. */
      var freeExports =  exports && !exports.nodeType && exports;

      /** Detect free variable `module`. */
      var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports;

      /** Detect free variable `process` from Node.js. */
      var freeProcess = moduleExports && freeGlobal.process;

      /** Used to access faster Node.js helpers. */
      var nodeUtil = (function() {
        try {
          // Use `util.types` for Node.js 10+.
          var types = freeModule && freeModule.require && freeModule.require('util').types;

          if (types) {
            return types;
          }

          // Legacy `process.binding('util')` for Node.js < 10.
          return freeProcess && freeProcess.binding && freeProcess.binding('util');
        } catch (e) {}
      }());

      /* Node.js helper references. */
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
          nodeIsDate = nodeUtil && nodeUtil.isDate,
          nodeIsMap = nodeUtil && nodeUtil.isMap,
          nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
          nodeIsSet = nodeUtil && nodeUtil.isSet,
          nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

      /*--------------------------------------------------------------------------*/

      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0: return func.call(thisArg);
          case 1: return func.call(thisArg, args[0]);
          case 2: return func.call(thisArg, args[0], args[1]);
          case 3: return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }

      /**
       * A specialized version of `baseAggregator` for arrays.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.forEach` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.forEachRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;

        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.every` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       */
      function arrayEvery(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }

      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }

      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }

      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }

      /**
       * A specialized version of `_.reduce` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the first element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
            length = array == null ? 0 : array.length;

        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.reduceRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the last element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.some` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function arraySome(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Gets the size of an ASCII `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      var asciiSize = baseProperty('length');

      /**
       * Converts an ASCII `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function asciiToArray(string) {
        return string.split('');
      }

      /**
       * Splits an ASCII `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }

      /**
       * The base implementation of methods like `_.findKey` and `_.findLastKey`,
       * without support for iteratee shorthands, which iterates over `collection`
       * using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the found element or its key, else `undefined`.
       */
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection) {
          if (predicate(value, key, collection)) {
            result = key;
            return false;
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);

        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        return value === value
          ? strictIndexOf(array, value, fromIndex)
          : baseFindIndex(array, baseIsNaN, fromIndex);
      }

      /**
       * This function is like `baseIndexOf` except that it accepts a comparator.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.isNaN` without support for number objects.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       */
      function baseIsNaN(value) {
        return value !== value;
      }

      /**
       * The base implementation of `_.mean` and `_.meanBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the mean.
       */
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? (baseSum(array, iteratee) / length) : NAN;
      }

      /**
       * The base implementation of `_.property` without support for deep paths.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }

      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }

      /**
       * The base implementation of `_.reduce` and `_.reduceRight`, without support
       * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} accumulator The initial value.
       * @param {boolean} initAccum Specify using the first or last element of
       *  `collection` as the initial value.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the accumulated value.
       */
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
          accumulator = initAccum
            ? (initAccum = false, value)
            : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }

      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define the
       * sort order of `array` and replaces criteria objects with their corresponding
       * values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        var length = array.length;

        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }

      /**
       * The base implementation of `_.sum` and `_.sumBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the sum.
       */
      function baseSum(array, iteratee) {
        var result,
            index = -1,
            length = array.length;

        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : (result + current);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }

      /**
       * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
       * of key-value pairs for `object` corresponding to the property names of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the key-value pairs.
       */
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }

      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }

      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }

      /**
       * Checks if a `cache` value for `key` exists.
       *
       * @private
       * @param {Object} cache The cache to query.
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function cacheHas(cache, key) {
        return cache.has(key);
      }

      /**
       * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the first unmatched string symbol.
       */
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
            length = strSymbols.length;

        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the last unmatched string symbol.
       */
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;

        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Gets the number of `placeholder` occurrences in `array`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} placeholder The placeholder to search for.
       * @returns {number} Returns the placeholder count.
       */
      function countHolders(array, placeholder) {
        var length = array.length,
            result = 0;

        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }

      /**
       * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
       * letters to basic Latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      var deburrLetter = basePropertyOf(deburredLetters);

      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      var escapeHtmlChar = basePropertyOf(htmlEscapes);

      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }

      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }

      /**
       * Checks if `string` contains Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a symbol is found, else `false`.
       */
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }

      /**
       * Checks if `string` contains a word composed of Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a word is found, else `false`.
       */
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }

      /**
       * Converts `iterator` to an array.
       *
       * @private
       * @param {Object} iterator The iterator to convert.
       * @returns {Array} Returns the converted array.
       */
      function iteratorToArray(iterator) {
        var data,
            result = [];

        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }

      /**
       * Converts `map` to its key-value pairs.
       *
       * @private
       * @param {Object} map The map to convert.
       * @returns {Array} Returns the key-value pairs.
       */
      function mapToArray(map) {
        var index = -1,
            result = Array(map.size);

        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }

      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }

      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }

      /**
       * Converts `set` to an array of its values.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the values.
       */
      function setToArray(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }

      /**
       * Converts `set` to its value-value pairs.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the value-value pairs.
       */
      function setToPairs(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }

      /**
       * A specialized version of `_.indexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }

      /**
       * A specialized version of `_.lastIndexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }

      /**
       * Gets the number of symbols in `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the string size.
       */
      function stringSize(string) {
        return hasUnicode(string)
          ? unicodeSize(string)
          : asciiSize(string);
      }

      /**
       * Converts `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function stringToArray(string) {
        return hasUnicode(string)
          ? unicodeToArray(string)
          : asciiToArray(string);
      }

      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

      /**
       * Gets the size of a Unicode `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }

      /**
       * Converts a Unicode `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }

      /**
       * Splits a Unicode `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }

      /*--------------------------------------------------------------------------*/

      /**
       * Create a new pristine `lodash` function using the `context` object.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Util
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // Create a suped-up `defer` in Node.js.
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      var runInContext = (function runInContext(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

        /** Built-in constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;

        /** Used for built-in method references. */
        var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

        /** Used to detect overreaching core-js shims. */
        var coreJsData = context['__core-js_shared__'];

        /** Used to resolve the decompiled source of functions. */
        var funcToString = funcProto.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to generate unique IDs. */
        var idCounter = 0;

        /** Used to detect methods masquerading as native. */
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
          return uid ? ('Symbol(src)_1.' + uid) : '';
        }());

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;

        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);

        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = root._;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );

        /** Built-in value references. */
        var Buffer = moduleExports ? context.Buffer : undefined$1,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
            symIterator = Symbol ? Symbol.iterator : undefined$1,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

        var defineProperty = (function() {
          try {
            var func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }());

        /** Mocked built-ins. */
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
            ctxNow = Date && Date.now !== root.Date.now && Date.now,
            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = overArg(Object.keys, Object),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = Date.now,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse;

        /* Built-in method references that are verified to be native. */
        var DataView = getNative(context, 'DataView'),
            Map = getNative(context, 'Map'),
            Promise = getNative(context, 'Promise'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');

        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;

        /** Used to lookup unminified function names. */
        var realNames = {};

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);

        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol ? Symbol.prototype : undefined$1,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
            symbolToString = symbolProto ? symbolProto.toString : undefined$1;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` object which wraps `value` to enable implicit method
         * chain sequences. Methods that operate on and return arrays, collections,
         * and functions can be chained together. Methods that retrieve a single value
         * or may return a primitive value will automatically end the chain sequence
         * and return the unwrapped value. Otherwise, the value must be unwrapped
         * with `_#value`.
         *
         * Explicit chain sequences, which must be unwrapped with `_#value`, may be
         * enabled using `_.chain`.
         *
         * The execution of chained methods is lazy, that is, it's deferred until
         * `_#value` is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion.
         * Shortcut fusion is an optimization to merge iteratee calls; this avoids
         * the creation of intermediate arrays and can greatly reduce the number of
         * iteratee executions. Sections of a chain sequence qualify for shortcut
         * fusion if the section is applied to an array and iteratees accept only
         * one argument. The heuristic for whether a section qualifies for shortcut
         * fusion is subject to change.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
         * `zipObject`, `zipObjectDeep`, and `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
         * `upperFirst`, `value`, and `words`
         *
         * @name _
         * @constructor
         * @category Seq
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // Returns an unwrapped value.
         * wrapped.reduce(_.add);
         * // => 6
         *
         * // Returns a wrapped value.
         * var squares = wrapped.map(square);
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
          function object() {}
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object;
            object.prototype = undefined$1;
            return result;
          };
        }());

        /**
         * The function whose prototype chain sequence wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }

        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable explicit method chain sequences.
         */
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }

        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
         * following template settings to use alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type {Object}
         */
        lodash.templateSettings = {

          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'escape': reEscape,

          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'evaluate': reEvaluate,

          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'interpolate': reInterpolate,

          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          'variable': '',

          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          'imports': {

            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            '_': lodash
          }
        };

        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;

        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @constructor
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }

        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = copyArray(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = copyArray(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = copyArray(this.__views__);
          return result;
        }

        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }

        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);

          if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result = [];

          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;

            var iterIndex = -1,
                value = array[index];

            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);

              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }

        // Ensure `LazyWrapper` is an instance of `baseLodash`.
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined$1 : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
        }

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
        }

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
          return this;
        }

        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          return index < 0 ? undefined$1 : data[index][1];
        }

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet(key, value) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }

        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash,
            'map': new (Map || ListCache),
            'string': new Hash
          };
        }

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete(key) {
          var result = getMapData(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
              size = data.size;

          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var index = -1,
              length = values == null ? 0 : values.length;

          this.__data__ = new MapCache;
          while (++index < length) {
            this.add(values[index]);
          }
        }

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = new ListCache;
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
              result = data['delete'](key);

          this.size = data.size;
          return result;
        }

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }

        // Add methods to `Stack`.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;

          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (
                   // Safari 9 has enumerable `arguments.length` in strict mode.
                   key == 'length' ||
                   // Node.js 0.10 has enumerable non-index properties on buffers.
                   (isBuff && (key == 'offset' || key == 'parent')) ||
                   // PhantomJS 2 has enumerable non-index properties on typed arrays.
                   (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                   // Skip index properties.
                   isIndex(key, length)
                ))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * A specialized version of `_.sample` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @returns {*} Returns the random element.
         */
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }

        /**
         * A specialized version of `_.sampleSize` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }

        /**
         * A specialized version of `_.shuffle` for arrays.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue(object, key, value) {
          if ((value !== undefined$1 && !eq(object[key], value)) ||
              (value === undefined$1 && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined$1 && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }

        /**
         * Aggregates elements of `collection` on `accumulator` with keys transformed
         * by `iteratee` and values set by `setter`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function(value, key, collection) {
            setter(accumulator, value, iteratee(value), collection);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }

        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue(object, key, value) {
          if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }

        /**
         * The base implementation of `_.at` without support for individual paths.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {string[]} paths The property paths to pick.
         * @returns {Array} Returns the picked elements.
         */
        function baseAt(object, paths) {
          var index = -1,
              length = paths.length,
              result = Array(length),
              skip = object == null;

          while (++index < length) {
            result[index] = skip ? undefined$1 : get(object, paths[index]);
          }
          return result;
        }

        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }

        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result,
              isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG;

          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined$1) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;

            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = (isFlat || isFunc) ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result, value))
                  : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack);
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);

          if (isSet(value)) {
            value.forEach(function(subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key) {
              result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
          }

          var keysFunc = isFull
            ? (isFlat ? getAllKeysIn : getAllKeys)
            : (isFlat ? keysIn : keys);

          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }

        /**
         * The base implementation of `_.conforms` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         */
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }

        /**
         * The base implementation of `_.conformsTo` which accepts `props` to check.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         */
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (length--) {
            var key = props[length],
                predicate = source[key],
                value = object[key];

            if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.delay` and `_.defer` which accepts `args`
         * to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Array} args The arguments to provide to `func`.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined$1, args); }, wait);
        }

        /**
         * The base implementation of methods like `_.difference` without support
         * for excluding multiple arrays or iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length;

          if (!length) {
            return result;
          }
          if (iteratee) {
            values = arrayMap(values, baseUnary(iteratee));
          }
          if (comparator) {
            includes = arrayIncludesWith;
            isCommon = false;
          }
          else if (values.length >= LARGE_ARRAY_SIZE) {
            includes = cacheHas;
            isCommon = false;
            values = new SetCache(values);
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee == null ? value : iteratee(value);

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        /**
         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);

        /**
         * The base implementation of `_.every` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }

        /**
         * The base implementation of methods like `_.max` and `_.min` which accepts a
         * `comparator` to determine the extremum value.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The iteratee invoked per iteration.
         * @param {Function} comparator The comparator used to compare values.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(array, iteratee, comparator) {
          var index = -1,
              length = array.length;

          while (++index < length) {
            var value = array[index],
                current = iteratee(value);

            if (current != null && (computed === undefined$1
                  ? (current === current && !isSymbol(current))
                  : comparator(current, computed)
                )) {
              var computed = current,
                  result = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;

          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined$1 || end > length) ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }

        /**
         * The base implementation of `_.filter` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }

        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
              length = array.length;

          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();

        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return object && baseForRight(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from `props`.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the function names.
         */
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path) {
          path = castPath(path, object);

          var index = 0,
              length = path.length;

          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return (index && index == length) ? object : undefined$1;
        }

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return (symToStringTag && symToStringTag in Object(value))
            ? getRawTag(value)
            : objectToString(value);
        }

        /**
         * The base implementation of `_.gt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         */
        function baseGt(value, other) {
          return value > other;
        }

        /**
         * The base implementation of `_.has` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        /**
         * The base implementation of `_.inRange` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to check.
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         */
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }

        /**
         * The base implementation of methods like `_.intersection`, without support
         * for iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of shared values.
         */
        function baseIntersection(arrays, iteratee, comparator) {
          var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = [];

          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee) {
              array = arrayMap(array, baseUnary(iteratee));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
              ? new SetCache(othIndex && array)
              : undefined$1;
          }
          array = arrays[0];

          var index = -1,
              seen = caches[0];

          outer:
          while (++index < length && result.length < maxLength) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (!(seen
                  ? cacheHas(seen, computed)
                  : includes(result, computed, comparator)
                )) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache
                      ? cacheHas(cache, computed)
                      : includes(arrays[othIndex], computed, comparator))
                    ) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.invert` and `_.invertBy` which inverts
         * `object` with values transformed by `iteratee` and set by `setter`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform values.
         * @param {Object} accumulator The initial inverted object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseInverter(object, setter, iteratee, accumulator) {
          baseForOwn(object, function(value, key, object) {
            setter(accumulator, iteratee(value), key, object);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.invoke` without support for individual
         * method arguments.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        /**
         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         */
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }

        /**
         * The base implementation of `_.isDate` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         */
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = objIsArr ? arrayTag : getTag(object),
              othTag = othIsArr ? arrayTag : getTag(other);

          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;

          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;

          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object))
              ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
              : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other;

              stack || (stack = new Stack);
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack);
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }

        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;

          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];

            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack;
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined$1
                    ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                    : result
                  )) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        /**
         * The base implementation of `_.isRegExp` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         */
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }

        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
          return isObjectLike(value) &&
            isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == 'object') {
            return isArray(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value);
          }
          return property(value);
        }

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
              result = [];

          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.lt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         */
        function baseLt(value, other) {
          return value < other;
        }

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return (objValue === undefined$1 && objValue === srcValue)
              ? hasIn(object, path)
              : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack);
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            }
            else {
              var newValue = customizer
                ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
                : undefined$1;

              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);

          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer
            ? customizer(objValue, srcValue, (key + ''), object, source, stack)
            : undefined$1;

          var isCommon = newValue === undefined$1;

          if (isCommon) {
            var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);

            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              }
              else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              }
              else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              }
              else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              }
              else {
                newValue = [];
              }
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              }
              else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            }
            else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }

        /**
         * The base implementation of `_.nth` which doesn't coerce arguments.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {number} n The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         */
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }

        /**
         * The base implementation of `_.orderBy` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {string[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseOrderBy(collection, iteratees, orders) {
          var index = -1;
          iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

          var result = baseMap(collection, function(value, key, collection) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });

          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }

        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }

        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy(object, paths, predicate) {
          var index = -1,
              length = paths.length,
              result = {};

          while (++index < length) {
            var path = paths[index],
                value = baseGet(object, path);

            if (predicate(value, path)) {
              baseSet(result, castPath(path, object), value);
            }
          }
          return result;
        }

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }

        /**
         * The base implementation of `_.pullAllBy` without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         */
        function basePullAll(array, values, iteratee, comparator) {
          var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;

          if (array === values) {
            values = copyArray(values);
          }
          if (iteratee) {
            seen = arrayMap(array, baseUnary(iteratee));
          }
          while (++index < length) {
            var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value;

            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.pullAt` without support for individual
         * indexes or capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
              lastIndex = length - 1;

          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.random` without support for returning
         * floating-point numbers.
         *
         * @private
         * @param {number} lower The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the random number.
         */
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }

        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */
        function baseRange(start, end, step, fromRight) {
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);

          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }

        /**
         * The base implementation of `_.repeat` which doesn't coerce arguments.
         *
         * @private
         * @param {string} string The string to repeat.
         * @param {number} n The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         */
        function baseRepeat(string, n) {
          var result = '';
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);

          return result;
        }

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + '');
        }

        /**
         * The base implementation of `_.sample`.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         */
        function baseSample(collection) {
          return arraySample(values(collection));
        }

        /**
         * The base implementation of `_.sampleSize` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }

        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);

          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;

          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
                newValue = value;

            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject(objValue)
                  ? objValue
                  : (isIndex(path[index + 1]) ? [] : {});
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }

        /**
         * The base implementation of `setData` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant(string),
            'writable': true
          });
        };

        /**
         * The base implementation of `_.shuffle`.
         *
         * @private
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }

        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;

          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;

          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }

        /**
         * The base implementation of `_.some` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          var result;

          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }

        /**
         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
         * performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
              high = array == null ? low : array.length;

          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];

              if (computed !== null && !isSymbol(computed) &&
                  (retHighest ? (computed <= value) : (computed < value))) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }

        /**
         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
         * which invokes `iteratee` for `value` and each element of `array` to compute
         * their sort ranking. The iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The iteratee invoked per element.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);

          var low = 0,
              high = array == null ? 0 : array.length,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsSymbol = isSymbol(value),
              valIsUndefined = value === undefined$1;

          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined$1,
                othIsNull = computed === null,
                othIsReflexive = computed === computed,
                othIsSymbol = isSymbol(computed);

            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }

        /**
         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseSortedUniq(array, iteratee) {
          var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.toNumber` which doesn't ensure correct
         * conversions of binary, hexadecimal, or octal string values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         */
        function baseToNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;

          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          }
          else if (length >= LARGE_ARRAY_SIZE) {
            var set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache;
          }
          else {
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }

        /**
         * The base implementation of `_.update`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to update.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }

        /**
         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
         * without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;

          while ((fromRight ? index-- : ++index < length) &&
            predicate(array[index], index, array)) {}

          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }

        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to perform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          return arrayReduce(actions, function(result, action) {
            return action.func.apply(action.thisArg, arrayPush([result], action.args));
          }, result);
        }

        /**
         * The base implementation of methods like `_.xor`, without support for
         * iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of values.
         */
        function baseXor(arrays, iteratee, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1,
              result = Array(length);

          while (++index < length) {
            var array = arrays[index],
                othIndex = -1;

            while (++othIndex < length) {
              if (othIndex != index) {
                result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }

        /**
         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
         *
         * @private
         * @param {Array} props The property identifiers.
         * @param {Array} values The property values.
         * @param {Function} assignFunc The function to assign values.
         * @returns {Object} Returns the new object.
         */
        function baseZipObject(props, values, assignFunc) {
          var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {};

          while (++index < length) {
            var value = index < valsLength ? values[index] : undefined$1;
            assignFunc(result, props[index], value);
          }
          return result;
        }

        /**
         * Casts `value` to an empty array if it's not an array like object.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array|Object} Returns the cast array-like object.
         */
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction(value) {
          return typeof value == 'function' ? value : identity;
        }

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        /**
         * A `baseRest` alias which can be replaced with `identity` by module
         * replacement plugins.
         *
         * @private
         * @type {Function}
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        var castRest = baseRest;

        /**
         * Casts `array` to a slice if it's needed.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {number} start The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the cast slice.
         */
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return (!start && end >= length) ? array : baseSlice(array, start, end);
        }

        /**
         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
         *
         * @private
         * @param {number|Object} id The timer id or timeout object of the timer to clear.
         */
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

          buffer.copy(result);
          return result;
        }

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }

        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }

        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }

        /**
         * Compares values to sort them in ascending order.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value);

            var othIsDefined = other !== undefined$1,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other);

            if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
                (valIsNull && othIsDefined && othIsReflexive) ||
                (!valIsDefined && othIsReflexive) ||
                !valIsReflexive) {
              return 1;
            }
            if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
                (othIsNull && valIsDefined && valIsReflexive) ||
                (!othIsDefined && valIsReflexive) ||
                !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }

        /**
         * Used by `_.orderBy` to compare multiple properties of a value to another
         * and stable sort them.
         *
         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
         * specify an order of "desc" for descending or "asc" for ascending sort order
         * of corresponding values.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {boolean[]|string[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareMultiple(object, other, orders) {
          var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length;

          while (++index < length) {
            var result = compareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              var order = orders[index];
              return result * (order == 'desc' ? -1 : 1);
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
          return object.index - other.index;
        }

        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried;

          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }

        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried;

          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
              length = source.length;

          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});

          var index = -1,
              length = props.length;

          while (++index < length) {
            var key = props[index];

            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined$1;

            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }

        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }

        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }

        /**
         * Creates a function like `_.groupBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} [initializer] The accumulator object initializer.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};

            return func(collection, setter, getIteratee(iteratee, 2), accumulator);
          };
        }

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined$1,
                guard = length > 2 ? sources[2] : undefined$1;

            customizer = (assigner.length > 3 && typeof customizer == 'function')
              ? (length--, customizer)
              : undefined$1;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);

            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;

            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }

        /**
         * Creates a function that wraps `func` to invoke it with the optional `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.lowerFirst`.
         *
         * @private
         * @param {string} methodName The name of the `String` case method to use.
         * @returns {Function} Returns the new case function.
         */
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);

            var strSymbols = hasUnicode(string)
              ? stringToArray(string)
              : undefined$1;

            var chr = strSymbols
              ? strSymbols[0]
              : string.charAt(0);

            var trailing = strSymbols
              ? castSlice(strSymbols, 1).join('')
              : string.slice(1);

            return chr[methodName]() + trailing;
          };
        }

        /**
         * Creates a function like `_.camelCase`.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
          };
        }

        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtor(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors. See
            // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);

            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }

        /**
         * Creates a function that wraps `func` to enable currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {number} arity The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getHolder(wrapper);

            while (index--) {
              args[index] = arguments[index];
            }
            var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
              ? []
              : replaceHolders(args, placeholder);

            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
                args, holders, undefined$1, undefined$1, arity - length);
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} findIndexFunc The function to find the collection index.
         * @returns {Function} Returns the new find function.
         */
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object(collection);
            if (!isArrayLike(collection)) {
              var iteratee = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) { return iteratee(iterable[key], key, iterable); };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
          };
        }

        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;

            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];

              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined$1;

              if (data && isLaziable(data[0]) &&
                    data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                    !data[4].length && data[9] == 1
                  ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func))
                  ? wrapper[funcName]()
                  : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];

              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;

              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          });
        }

        /**
         * Creates a function that wraps `func` to invoke it with optional `this`
         * binding of `thisArg`, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided
         *  to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG,
              isBind = bitmask & WRAP_BIND_FLAG,
              isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
              isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
              isFlip = bitmask & WRAP_FLIP_FLAG,
              Ctor = isBindKey ? undefined$1 : createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length;

            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                  holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, thisArg,
                args, newHolders, argPos, ary, arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;

            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.invertBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} toIteratee The function to resolve iteratees.
         * @returns {Function} Returns the new inverter function.
         */
        function createInverter(setter, toIteratee) {
          return function(object, iteratee) {
            return baseInverter(object, setter, toIteratee(iteratee), {});
          };
        }

        /**
         * Creates a function that performs a mathematical operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @param {number} [defaultValue] The value used for `undefined` arguments.
         * @returns {Function} Returns the new mathematical operation function.
         */
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result = value;
            }
            if (other !== undefined$1) {
              if (result === undefined$1) {
                return other;
              }
              if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result = operator(value, other);
            }
            return result;
          };
        }

        /**
         * Creates a function like `_.over`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over iteratees.
         * @returns {Function} Returns the new over function.
         */
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee) {
                return apply(iteratee, thisArg, args);
              });
            });
          });
        }

        /**
         * Creates the padding for `string` based on `length`. The `chars` string
         * is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {number} length The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padding for `string`.
         */
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? ' ' : baseToString(chars);

          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars)
            ? castSlice(stringToArray(result), 0, length).join('')
            : result.slice(0, length);
        }

        /**
         * Creates a function that wraps `func` to invoke it with the `this` binding
         * of `thisArg` and `partials` prepended to the arguments it receives.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to
         *  the new function.
         * @returns {Function} Returns the new wrapped function.
         */
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            // Ensure the sign of `-0` is preserved.
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }

        /**
         * Creates a function that performs a relational operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @returns {Function} Returns the new relational operation function.
         */
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == 'string' && typeof other == 'string')) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }

        /**
         * Creates a function that wraps `func` to continue currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {Function} wrapFunc The function to create the `func` wrapper.
         * @param {*} placeholder The placeholder value.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG,
              newHolders = isCurry ? holders : undefined$1,
              newHoldersRight = isCurry ? undefined$1 : holders,
              newPartials = isCurry ? partials : undefined$1,
              newPartialsRight = isCurry ? undefined$1 : partials;

          bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
            newHoldersRight, argPos, ary, arity
          ];

          var result = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return setWrapToString(result, func, bitmask);
        }

        /**
         * Creates a function like `_.round`.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              // Shift with exponential notation to avoid floating-point issues.
              // See [MDN](https://mdn.io/round#Examples) for more details.
              var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision));

              pair = (toString(value) + 'e').split('e');
              return +(pair[0] + 'e' + (+pair[1] - precision));
            }
            return func(number);
          };
        }

        /**
         * Creates a set object of `values`.
         *
         * @private
         * @param {Array} values The values to add to the set.
         * @returns {Object} Returns the new set.
         */
        var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
          return new Set(values);
        };

        /**
         * Creates a `_.toPairs` or `_.toPairsIn` function.
         *
         * @private
         * @param {Function} keysFunc The function to get the keys of a given object.
         * @returns {Function} Returns the new pairs function.
         */
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }

        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags.
         *    1 - `_.bind`
         *    2 - `_.bindKey`
         *    4 - `_.curry` or `_.curryRight` of a bound function
         *    8 - `_.curry`
         *   16 - `_.curryRight`
         *   32 - `_.partial`
         *   64 - `_.partialRight`
         *  128 - `_.rearg`
         *  256 - `_.ary`
         *  512 - `_.flip`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;

          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;

            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);

          var newData = [
            func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
            argPos, ary, arity
          ];

          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1
            ? (isBindKey ? 0 : func.length)
            : nativeMax(newData[9] - length, 0);

          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result = createPartial(func, bitmask, thisArg, partials);
          } else {
            result = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result, newData), func, bitmask);
        }

        /**
         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
         * of source objects to the destination object for all destination properties
         * that resolve to `undefined`.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to assign.
         * @param {Object} object The parent object of `objValue`.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 ||
              (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            return srcValue;
          }
          return objValue;
        }

        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
         * objects into destination objects that are passed thru.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to merge.
         * @param {Object} object The parent object of `objValue`.
         * @param {Object} source The parent object of `srcValue`.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack['delete'](srcValue);
          }
          return objValue;
        }

        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$1 : value;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length;

          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(array);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var index = -1,
              result = true,
              seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome(other, function(othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) &&
                        (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                      return seen.push(othIndex);
                    }
                  })) {
                result = false;
                break;
              }
            } else if (!(
                  arrValue === othValue ||
                    equalFunc(arrValue, othValue, bitmask, customizer, stack)
                )) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if ((object.byteLength != other.byteLength) ||
                  (object.byteOffset != other.byteOffset)) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;

            case arrayBufferTag:
              if ((object.byteLength != other.byteLength) ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;

            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);

            case errorTag:
              return object.name == other.name && object.message == other.message;

            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == (other + '');

            case mapTag:
              var convert = mapToArray;

            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);

              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;

            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              objProps = getAllKeys(object),
              objLength = objProps.length,
              othProps = getAllKeys(other),
              othLength = othProps.length;

          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);

          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined$1
                  ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                  : compared
                )) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + '');
        }

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }

        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }

        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };

        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = (func.name + ''),
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0;

          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }

        /**
         * Gets the argument placeholder value for `func`.
         *
         * @private
         * @param {Function} func The function to inspect.
         * @returns {*} Returns the placeholder value.
         */
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
          return object.placeholder;
        }

        /**
         * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
         * this function returns the custom method, otherwise it returns `baseIteratee`.
         * If arguments are provided, the chosen function is invoked with them and
         * its result is returned.
         *
         * @private
         * @param {*} [value] The value to convert to an iteratee.
         * @param {number} [arity] The arity of the created iteratee.
         * @returns {Function} Returns the chosen function or its result.
         */
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map;
        }

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = keys(object),
              length = result.length;

          while (length--) {
            var key = result[length],
                value = object[key];

            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {}

          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };

        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result = [];
          while (object) {
            arrayPush(result, getSymbols(object));
            object = getPrototype(object);
          }
          return result;
        };

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag = baseGetTag;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map && getTag(new Map) != mapTag) ||
            (Promise && getTag(Promise.resolve()) != promiseTag) ||
            (Set && getTag(new Set) != setTag) ||
            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
          getTag = function(value) {
            var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined$1,
                ctorString = Ctor ? toSource(Ctor) : '';

            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString: return dataViewTag;
                case mapCtorString: return mapTag;
                case promiseCtorString: return promiseTag;
                case setCtorString: return setTag;
                case weakMapCtorString: return weakMapTag;
              }
            }
            return result;
          };
        }

        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;

          while (++index < length) {
            var data = transforms[index],
                size = data.size;

            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }

        /**
         * Extracts wrapper details from the `source` body comment.
         *
         * @private
         * @param {string} source The source to inspect.
         * @returns {Array} Returns the wrapper details.
         */
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);

          var index = -1,
              length = path.length,
              result = false;

          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) &&
            (isArray(object) || isArguments(object));
        }

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);

          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          return (typeof object.constructor == 'function' && !isPrototype(object))
            ? baseCreate(getPrototype(object))
            : {};
        }

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);

            case boolTag:
            case dateTag:
              return new Ctor(+object);

            case dataViewTag:
              return cloneDataView(object, isDeep);

            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              return cloneTypedArray(object, isDeep);

            case mapTag:
              return new Ctor;

            case numberTag:
            case stringTag:
              return new Ctor(object);

            case regexpTag:
              return cloneRegExp(object);

            case setTag:
              return new Ctor;

            case symbolTag:
              return cloneSymbol(object);
          }
        }

        /**
         * Inserts wrapper `details` in a comment at the top of the `source` body.
         *
         * @private
         * @param {string} source The source to modify.
         * @returns {Array} details The details to insert.
         * @returns {string} Returns the modified source.
         */
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
          details = details.join(length > 2 ? ', ' : ' ');
          return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
        }

        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol]);
        }

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;

          return !!length &&
            (type == 'number' ||
              (type != 'symbol' && reIsUint.test(value))) &&
                (value > -1 && value % 1 == 0 && value < length);
        }

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
                ? (isArrayLike(object) && isIndex(index, object.length))
                : (type == 'string' && index in object)
              ) {
            return eq(object[index], value);
          }
          return false;
        }

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' ||
              value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
            (object != null && value in Object(object));
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
            ? (value !== '__proto__')
            : (value === null);
        }

        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
         *  else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func),
              other = lodash[funcName];

          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
          return !!maskSrcKey && (maskSrcKey in func);
        }

        /**
         * Checks if `func` is capable of being masked.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
         */
        var isMaskable = coreJsData ? isFunction : stubFalse;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          var Ctor = value && value.constructor,
              proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

          return value === proto;
        }

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue &&
              (srcValue !== undefined$1 || (key in Object(object)));
          };
        }

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped(func) {
          var result = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });

          var cache = result.cache;
          return result;
        }

        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers used to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and
         * `_.rearg` modify function arguments, making the order in which they are
         * executed important, preventing the merging of metadata. However, we make
         * an exception for a safe combined case where curried functions have `_.ary`
         * and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

          var isCombo =
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
            ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = value;
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;

          return data;
        }

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest(func, start, transform) {
          start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }

        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array);

          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }

          if (key == '__proto__') {
            return;
          }

          return object[key];
        }

        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity
         * function to avoid garbage collection pauses in V8. See
         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = shortOut(baseSetData);

        /**
         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString = shortOut(baseSetToString);

        /**
         * Sets the `toString` method of `wrapper` to mimic the source of `reference`
         * with wrapper details in a comment at the top of the source body.
         *
         * @private
         * @param {Function} wrapper The function to modify.
         * @param {Function} reference The reference function.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Function} Returns `wrapper`.
         */
        function setWrapToString(wrapper, reference, bitmask) {
          var source = (reference + '');
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut(func) {
          var count = 0,
              lastCalled = 0;

          return function() {
            var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);

            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }

        /**
         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @param {number} [size=array.length] The size of `array`.
         * @returns {Array} Returns `array`.
         */
        function shuffleSelf(array, size) {
          var index = -1,
              length = array.length,
              lastIndex = length - 1;

          size = size === undefined$1 ? length : size;
          while (++index < size) {
            var rand = baseRandom(index, lastIndex),
                value = array[rand];

            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size;
          return array;
        }

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath = memoizeCapped(function(string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        });

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value;
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return (func + '');
            } catch (e) {}
          }
          return '';
        }

        /**
         * Updates wrapper `details` based on `bitmask` flags.
         *
         * @private
         * @returns {Array} details The details to modify.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Array} Returns `details`.
         */
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = '_.' + pair[0];
            if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }

        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result.__actions__ = copyArray(wrapper.__actions__);
          result.__index__  = wrapper.__index__;
          result.__values__ = wrapper.__values__;
          return result;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `array` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the new array of chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size < 1) {
            return [];
          }
          var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size));

          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }
          return result;
        }

        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * Creates a new array concatenating `array` with any additional arrays
         * and/or values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to concatenate.
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var other = _.concat(array, 2, [3], [[4]]);
         *
         * console.log(other);
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array(length - 1),
              array = arguments[0],
              index = length;

          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }

        /**
         * Creates an array of `array` values not included in the other given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * **Note:** Unlike `_.pullAll`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.without, _.xor
         * @example
         *
         * _.difference([2, 1], [2, 3]);
         * // => [1]
         */
        var difference = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `iteratee` which
         * is invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var differenceBy = baseRest(function(array, values) {
          var iteratee = last(values);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `comparator`
         * which is invoked to compare elements of `array` to `values`. The order and
         * references of result values are determined by the first array. The comparator
         * is invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         *
         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }]
         */
        var differenceWith = baseRest(function(array, values) {
          var comparator = last(values);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
            : [];
        });

        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.dropRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropRightWhile(users, ['active', false]);
         * // => objects for ['barney']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropRightWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true, true)
            : [];
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.dropWhile(users, function(o) { return !o.active; });
         * // => objects for ['pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropWhile(users, ['active', false]);
         * // => objects for ['pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true)
            : [];
        }

        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8, 10], '*', 1, 3);
         * // => [4, '*', '*', 10]
         */
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }

        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(o) { return o.user == 'barney'; });
         * // => 0
         *
         * // The `_.matches` iteratee shorthand.
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findIndex(users, ['active', false]);
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.findIndex(users, 'active');
         * // => 2
         */
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }

        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
         * // => 2
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastIndex(users, ['active', false]);
         * // => 2
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0
              ? nativeMax(length + index, 0)
              : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }

        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        /**
         * Recursively flattens `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, [3, [4]], 5]]);
         * // => [1, 2, 3, 4, 5]
         */
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }

        /**
         * Recursively flatten `array` up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * var array = [1, [2, [3, [4]], 5]];
         *
         * _.flattenDepth(array, 1);
         * // => [1, 2, [3, [4]], 5]
         *
         * _.flattenDepth(array, 2);
         * // => [1, 2, 3, [4], 5]
         */
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }

        /**
         * The inverse of `_.toPairs`; this method returns an object composed
         * from key-value `pairs`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} pairs The key-value pairs.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.fromPairs([['a', 1], ['b', 2]]);
         * // => { 'a': 1, 'b': 2 }
         */
        function fromPairs(pairs) {
          var index = -1,
              length = pairs == null ? 0 : pairs.length,
              result = {};

          while (++index < length) {
            var pair = pairs[index];
            result[pair[0]] = pair[1];
          }
          return result;
        }

        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias first
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.head([1, 2, 3]);
         * // => 1
         *
         * _.head([]);
         * // => undefined
         */
        function head(array) {
          return (array && array.length) ? array[0] : undefined$1;
        }

        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the
         * offset from the end of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // Search from the `fromIndex`.
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         */
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }

        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }

        /**
         * Creates an array of unique values that are included in all given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersection([2, 1], [2, 3]);
         * // => [2]
         */
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped)
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `iteratee`
         * which is invoked for each element of each `arrays` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [2.1]
         *
         * // The `_.property` iteratee shorthand.
         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }]
         */
        var intersectionBy = baseRest(function(arrays) {
          var iteratee = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          if (iteratee === last(mapped)) {
            iteratee = undefined$1;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `comparator`
         * which is invoked to compare elements of `arrays`. The order and references
         * of result values are determined by the first array. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.intersectionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }]
         */
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, undefined$1, comparator)
            : [];
        });

        /**
         * Converts all elements in `array` into a string separated by `separator`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to convert.
         * @param {string} [separator=','] The element separator.
         * @returns {string} Returns the joined string.
         * @example
         *
         * _.join(['a', 'b', 'c'], '~');
         * // => 'a~b~c'
         */
        function join(array, separator) {
          return array == null ? '' : nativeJoin.call(array, separator);
        }

        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }

        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // Search from the `fromIndex`.
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value
            ? strictLastIndexOf(array, value, index)
            : baseFindIndex(array, baseIsNaN, index, true);
        }

        /**
         * Gets the element at index `n` of `array`. If `n` is negative, the nth
         * element from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.11.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=0] The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         *
         * _.nth(array, 1);
         * // => 'b'
         *
         * _.nth(array, -2);
         * // => 'c';
         */
        function nth(array, n) {
          return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
        }

        /**
         * Removes all given values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
         * to remove elements from an array by predicate.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pull(array, 'a', 'c');
         * console.log(array);
         * // => ['b', 'b']
         */
        var pull = baseRest(pullAll);

        /**
         * This method is like `_.pull` except that it accepts an array of values to remove.
         *
         * **Note:** Unlike `_.difference`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pullAll(array, ['a', 'c']);
         * console.log(array);
         * // => ['b', 'b']
         */
        function pullAll(array, values) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values)
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `iteratee` which is
         * invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The iteratee is invoked with one argument: (value).
         *
         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
         *
         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
         * console.log(array);
         * // => [{ 'x': 2 }]
         */
        function pullAllBy(array, values, iteratee) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, getIteratee(iteratee, 2))
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `comparator` which
         * is invoked to compare elements of `array` to `values`. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
         *
         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
         * console.log(array);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
         */
        function pullAllWith(array, values, comparator) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, undefined$1, comparator)
            : array;
        }

        /**
         * Removes elements from `array` corresponding to `indexes` and returns an
         * array of removed elements.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         * var pulled = _.pullAt(array, [1, 3]);
         *
         * console.log(array);
         * // => ['a', 'c']
         *
         * console.log(pulled);
         * // => ['b', 'd']
         */
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length,
              result = baseAt(array, indexes);

          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));

          return result;
        });

        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is invoked
         * with three arguments: (value, index, array).
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
         * to pull elements from an array by value.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;

          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }

        /**
         * Reverses `array` so that the first element becomes the last, the second
         * element becomes the second to last, and so on.
         *
         * **Note:** This method mutates `array` and is based on
         * [`Array#reverse`](https://mdn.io/Array/reverse).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.reverse(array);
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }

        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of
         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
         * returned.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }

        /**
         * Uses a binary search to determine the lowest index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         */
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }

        /**
         * This method is like `_.sortedIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
         * // => 0
         */
        function sortedIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }

        /**
         * This method is like `_.indexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
         * // => 1
         */
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
         * // => 4
         */
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }

        /**
         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 1
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
         * // => 1
         */
        function sortedLastIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
        }

        /**
         * This method is like `_.lastIndexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
         * // => 3
         */
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.uniq` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniq([1, 1, 2]);
         * // => [1, 2]
         */
        function sortedUniq(array) {
          return (array && array.length)
            ? baseSortedUniq(array)
            : [];
        }

        /**
         * This method is like `_.uniqBy` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
         * // => [1.1, 2.3]
         */
        function sortedUniqBy(array, iteratee) {
          return (array && array.length)
            ? baseSortedUniq(array, getIteratee(iteratee, 2))
            : [];
        }

        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.tail([1, 2, 3]);
         * // => [2, 3]
         */
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.takeRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeRightWhile(users, ['active', false]);
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeRightWhile(users, 'active');
         * // => []
         */
        function takeRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), false, true)
            : [];
        }

        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.takeWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeWhile(users, ['active', false]);
         * // => objects for ['barney', 'fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeWhile(users, 'active');
         * // => []
         */
        function takeWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3))
            : [];
        }

        /**
         * Creates an array of unique values, in order, from all given arrays using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([2], [1, 2]);
         * // => [2, 1]
         */
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });

        /**
         * This method is like `_.union` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which uniqueness is computed. Result values are chosen from the first
         * array in which the value occurs. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.unionBy([2.1], [1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        var unionBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.union` except that it accepts `comparator` which
         * is invoked to compare elements of `arrays`. Result values are chosen from
         * the first array in which the value occurs. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.unionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });

        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurrence of each element
         * is kept. The order of result values is determined by the order they occur
         * in the array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         */
        function uniq(array) {
          return (array && array.length) ? baseUniq(array) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * uniqueness is computed. The order of result values is determined by the
         * order they occur in the array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniqBy(array, iteratee) {
          return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `comparator` which
         * is invoked to compare elements of `array`. The order of result values is
         * determined by the order they occur in the array.The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.uniqWith(objects, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
         */
        function uniqWith(array, comparator) {
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
        }

        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @since 1.2.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         *
         * _.unzip(zipped);
         * // => [['a', 'b'], [1, 2], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }

        /**
         * This method is like `_.unzip` except that it accepts `iteratee` to specify
         * how regrouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  regrouped values.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee) {
          if (!(array && array.length)) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          return arrayMap(result, function(group) {
            return apply(iteratee, undefined$1, group);
          });
        }

        /**
         * Creates an array excluding all given values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.pull`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.xor
         * @example
         *
         * _.without([2, 1, 2, 3], 1, 2);
         * // => [3]
         */
        var without = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, values)
            : [];
        });

        /**
         * Creates an array of unique values that is the
         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the given arrays. The order of result values is determined by the order
         * they occur in the arrays.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.without
         * @example
         *
         * _.xor([2, 1], [2, 3]);
         * // => [1, 3]
         */
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });

        /**
         * This method is like `_.xor` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which by which they're compared. The order of result values is determined
         * by the order they occur in the arrays. The iteratee is invoked with one
         * argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2, 3.4]
         *
         * // The `_.property` iteratee shorthand.
         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var xorBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.xor` except that it accepts `comparator` which is
         * invoked to compare elements of `arrays`. The order of result values is
         * determined by the order they occur in the arrays. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.xorWith(objects, others, _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });

        /**
         * Creates an array of grouped elements, the first of which contains the
         * first elements of the given arrays, the second of which contains the
         * second elements of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         */
        var zip = baseRest(unzip);

        /**
         * This method is like `_.fromPairs` except that it accepts two arrays,
         * one of property identifiers and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 0.4.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject(['a', 'b'], [1, 2]);
         * // => { 'a': 1, 'b': 2 }
         */
        function zipObject(props, values) {
          return baseZipObject(props || [], values || [], assignValue);
        }

        /**
         * This method is like `_.zipObject` except that it supports property paths.
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
         */
        function zipObjectDeep(props, values) {
          return baseZipObject(props || [], values || [], baseSet);
        }

        /**
         * This method is like `_.zip` except that it accepts `iteratee` to specify
         * how grouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  grouped values.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
         *   return a + b + c;
         * });
         * // => [111, 222]
         */
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined$1;

          iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
          return unzipWith(arrays, iteratee);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` wrapper instance that wraps `value` with explicit method
         * chain sequences enabled. The result of such sequences must be unwrapped
         * with `_#value`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Seq
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _
         *   .chain(users)
         *   .sortBy('age')
         *   .map(function(o) {
         *     return o.user + ' is ' + o.age;
         *   })
         *   .head()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }

        /**
         * This method invokes `interceptor` and returns `value`. The interceptor
         * is invoked with one argument; (value). The purpose of this method is to
         * "tap into" a method chain sequence in order to modify intermediate results.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    // Mutate input array.
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }

        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         * The purpose of this method is to "pass thru" values replacing intermediate
         * results in a method chain sequence.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor) {
          return interceptor(value);
        }

        /**
         * This method is the wrapper version of `_.at`.
         *
         * @name at
         * @memberOf _
         * @since 1.0.0
         * @category Seq
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _(object).at(['a[0].b.c', 'a[1]']).value();
         * // => [3, 4]
         */
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function(object) { return baseAt(object, paths); };

          if (length > 1 || this.__actions__.length ||
              !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            'func': thru,
            'args': [interceptor],
            'thisArg': undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });

        /**
         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
         *
         * @name chain
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // A sequence without explicit chaining.
         * _(users).head();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // A sequence with explicit chaining.
         * _(users)
         *   .chain()
         *   .head()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }

        /**
         * Executes the chain sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }

        /**
         * Gets the next value on a wrapped object following the
         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
         *
         * @name next
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the next iterator value.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 1 }
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 2 }
         *
         * wrapped.next();
         * // => { 'done': true, 'value': undefined }
         */
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
              value = done ? undefined$1 : this.__values__[this.__index__++];

          return { 'done': done, 'value': value };
        }

        /**
         * Enables the wrapper to be iterable.
         *
         * @name Symbol.iterator
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the wrapper object.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped[Symbol.iterator]() === wrapped;
         * // => true
         *
         * Array.from(wrapped);
         * // => [1, 2]
         */
        function wrapperToIterator() {
          return this;
        }

        /**
         * Creates a clone of the chain sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @param {*} value The value to plant.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2]).map(square);
         * var other = wrapped.plant([3, 4]);
         *
         * other.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;

          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            clone.__index__ = 0;
            clone.__values__ = undefined$1;
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }

        /**
         * This method is the wrapper version of `_.reverse`.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [reverse],
              'thisArg': undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }

        /**
         * Executes the chain sequence to resolve the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @since 0.1.0
         * @alias toJSON, valueOf
         * @category Seq
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the number of times the key was returned by `iteratee`. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': 1, '6': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            ++result[key];
          } else {
            baseAssignValue(result, key, 1);
          }
        });

        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * Iteration is stopped once `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * **Note:** This method returns `true` for
         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
         * elements of empty collections.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.every(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * **Note:** Unlike `_.remove`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.reject
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, { 'age': 36, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.filter(users, 'active');
         * // => objects for ['barney']
         */
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.find(users, function(o) { return o.age < 40; });
         * // => object for 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.find(users, { 'age': 1, 'active': true });
         * // => object for 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.find(users, ['active', false]);
         * // => object for 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.find(users, 'active');
         * // => object for 'barney'
         */
        var find = createFind(findIndex);

        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=collection.length-1] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        var findLast = createFind(findLastIndex);

        /**
         * Creates a flattened array of values by running each element in `collection`
         * thru `iteratee` and flattening the mapped results. The iteratee is invoked
         * with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [n, n];
         * }
         *
         * _.flatMap([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMap(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDeep([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMapDeep(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), INFINITY);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDepth([1, 2], duplicate, 2);
         * // => [[1, 1], [2, 2]]
         */
        function flatMapDepth(collection, iteratee, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee), depth);
        }

        /**
         * Iterates over elements of `collection` and invokes `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length"
         * property are iterated like arrays. To avoid this behavior use `_.forIn`
         * or `_.forOwn` for object iteration.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEachRight
         * @example
         *
         * _.forEach([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `1` then `2`.
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forEach(collection, iteratee) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @alias eachRight
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEach
         * @example
         *
         * _.forEachRight([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `2` then `1`.
         */
        function forEachRight(collection, iteratee) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The order of grouped values
         * is determined by the order they occur in `collection`. The corresponding
         * value of each key is an array of elements responsible for generating the
         * key. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': [4.2], '6': [6.1, 6.3] }
         *
         * // The `_.property` iteratee shorthand.
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            baseAssignValue(result, key, [value]);
          }
        });

        /**
         * Checks if `value` is in `collection`. If `collection` is a string, it's
         * checked for a substring of `value`, otherwise
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * is used for equality comparisons. If `fromIndex` is negative, it's used as
         * the offset from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {boolean} Returns `true` if `value` is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'a': 1, 'b': 2 }, 1);
         * // => true
         *
         * _.includes('abcd', 'bc');
         * // => true
         */
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection)
            ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
            : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
        }

        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `path` is a function, it's invoked
         * for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke each method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invokeMap([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value) {
            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result;
        });

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the last element responsible for generating the key. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var array = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.keyBy(array, function(o) {
         *   return String.fromCharCode(o.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.keyBy(array, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         */
        var keyBy = createAggregator(function(result, value, key) {
          baseAssignValue(result, key, value);
        });

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.sortBy` except that it allows specifying the sort
         * orders of the iteratees to sort by. If `orders` is unspecified, all values
         * are sorted in ascending order. Otherwise, specify an order of "desc" for
         * descending or "asc" for ascending sort order of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @param {string[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // Sort by `user` in ascending order and by `age` in descending order.
         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         */
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }

        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, the second of which
         * contains elements `predicate` returns falsey for. The predicate is
         * invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * _.partition(users, function(o) { return o.active; });
         * // => objects for [['fred'], ['barney', 'pebbles']]
         *
         * // The `_.matches` iteratee shorthand.
         * _.partition(users, { 'age': 1, 'active': false });
         * // => objects for [['pebbles'], ['barney', 'fred']]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.partition(users, ['active', false]);
         * // => objects for [['barney', 'pebbles'], ['fred']]
         *
         * // The `_.property` iteratee shorthand.
         * _.partition(users, 'active');
         * // => objects for [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });

        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` thru `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not given, the first element of `collection` is used as the initial
         * value. The iteratee is invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
         * and `sortBy`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduceRight
         * @example
         *
         * _.reduce([1, 2], function(sum, n) {
         *   return sum + n;
         * }, 0);
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         *   return result;
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
         */
        function reduce(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }

        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduce
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        function reduceRight(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }

        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.filter
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * _.reject(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.reject(users, { 'age': 40, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.reject(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.reject(users, 'active');
         * // => objects for ['barney']
         */
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }

        /**
         * Gets a random element from `collection`.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         */
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }

        /**
         * Gets `n` random elements at unique keys from `collection` up to the
         * size of `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @param {number} [n=1] The number of elements to sample.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the random elements.
         * @example
         *
         * _.sampleSize([1, 2, 3], 2);
         * // => [3, 1]
         *
         * _.sampleSize([1, 2, 3], 4);
         * // => [2, 3, 1]
         */
        function sampleSize(collection, n, guard) {
          if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }

        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }

        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable string keyed properties for objects.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the collection size.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }

        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * Iteration is stopped once `predicate` returns truthy. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.some(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection thru each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, [function(o) { return o.user; }]);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
         */
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now = ctxNow || function() {
          return root.Date.now();
        };

        /*------------------------------------------------------------------------*/

        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it's called `n` or more times.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => Logs 'done saving!' after the two async saves have completed.
         */
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }

        /**
         * Creates a function that invokes `func`, with up to `n` arguments,
         * ignoring any additional arguments.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = (func && n == null) ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }

        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it's called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery(element).on('click', _.before(5, addContactToList));
         * // => Allows adding up to 4 contacts to the list.
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result;
          };
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and `partials` prepended to the arguments it receives.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * function greet(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * }
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });

        /**
         * Creates a function that invokes the method at `object[key]` with `partials`
         * prepended to the arguments it receives.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist. See
         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Function
         * @param {Object} object The object to invoke the method on.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });

        /**
         * Creates a function that accepts arguments of `func` and either invokes
         * `func` returning its result, if at least `arity` number of arguments have
         * been provided, or returns a function that accepts the remaining `func`
         * arguments, and so on. The arity of `func` may be specified if `func.length`
         * is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result.placeholder = curry.placeholder;
          return result;
        }

        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = false,
              maxing = false,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }

          function invokeFunc(time) {
            var args = lastArgs,
                thisArg = lastThis;

            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }

          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }

          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                timeWaiting = wait - timeSinceLastCall;

            return maxing
              ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
              : timeWaiting;
          }

          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
              (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
          }

          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }

          function trailingEdge(time) {
            timerId = undefined$1;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result;
          }

          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }

          function flush() {
            return timerId === undefined$1 ? result : trailingEdge(now());
          }

          function debounced() {
            var time = now(),
                isInvoking = shouldInvoke(time);

            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }

        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // => Logs 'deferred' after one millisecond.
         */
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });

        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => Logs 'later' after one second.
         */
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });

        /**
         * Creates a function that invokes `func` with arguments reversed.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to flip arguments for.
         * @returns {Function} Returns the new flipped function.
         * @example
         *
         * var flipped = _.flip(function() {
         *   return _.toArray(arguments);
         * });
         *
         * flipped('a', 'b', 'c', 'd');
         * // => ['d', 'c', 'b', 'a']
         */
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache);
          return memoized;
        }

        // Expose `MapCache`.
        memoize.Cache = MapCache;

        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new negated function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0: return !predicate.call(this);
              case 1: return !predicate.call(this, args[0]);
              case 2: return !predicate.call(this, args[0], args[1]);
              case 3: return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }

        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first invocation. The `func` is
         * invoked with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // => `createApplication` is invoked once
         */
        function once(func) {
          return before(2, func);
        }

        /**
         * Creates a function that invokes `func` with its arguments transformed.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms=[_.identity]]
         *  The argument transforms.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var func = _.overArgs(function(x, y) {
         *   return [x, y];
         * }, [square, doubled]);
         *
         * func(9, 3);
         * // => [81, 6]
         *
         * func(10, 5);
         * // => [100, 10]
         */
        var overArgs = castRest(function(func, transforms) {
          transforms = (transforms.length == 1 && isArray(transforms[0]))
            ? arrayMap(transforms[0], baseUnary(getIteratee()))
            : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1,
                length = nativeMin(args.length, funcsLength);

            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });

        /**
         * Creates a function that invokes `func` with `partials` prepended to the
         * arguments it receives. This method is like `_.bind` except it does **not**
         * alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 0.2.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // Partially applied with placeholders.
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });

        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to the arguments it receives.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // Partially applied with placeholders.
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });

        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified `indexes` where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, [2, 0, 1]);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         */
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as
         * an array.
         *
         * **Note:** This method is based on the
         * [rest parameter](https://mdn.io/rest_parameters).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.rest(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * create function and an array of arguments much like
         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
         *
         * **Note:** This method is based on the
         * [spread operator](https://mdn.io/spread_operator).
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @param {number} [start=0] The start position of the spread.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start],
                otherArgs = castSlice(args, 0, start);

            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }

        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide `options` to indicate whether `func`
         * should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the throttled function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=true]
         *  Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }

        /**
         * Creates a function that accepts up to one argument, ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.unary(parseInt));
         * // => [6, 8, 10]
         */
        function unary(func) {
          return ary(func, 1);
        }

        /**
         * Creates a function that provides `value` to `wrapper` as its first
         * argument. Any additional arguments provided to the function are appended
         * to those provided to the `wrapper`. The wrapper is invoked with the `this`
         * binding of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} [wrapper=identity] The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Casts `value` as an array if it's not one.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Lang
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the cast array.
         * @example
         *
         * _.castArray(1);
         * // => [1]
         *
         * _.castArray({ 'a': 1 });
         * // => [{ 'a': 1 }]
         *
         * _.castArray('abc');
         * // => ['abc']
         *
         * _.castArray(null);
         * // => [null]
         *
         * _.castArray(undefined);
         * // => [undefined]
         *
         * _.castArray();
         * // => []
         *
         * var array = [1, 2, 3];
         * console.log(_.castArray(array) === array);
         * // => true
         */
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }

        /**
         * Creates a shallow clone of `value`.
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
         * and supports cloning arrays, array buffers, booleans, date objects, maps,
         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
         * arrays. The own enumerable properties of `arguments` objects are cloned
         * as plain objects. An empty object is returned for uncloneable values such
         * as error objects, functions, DOM nodes, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to clone.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeep
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var shallow = _.clone(objects);
         * console.log(shallow[0] === objects[0]);
         * // => true
         */
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.clone` except that it accepts `customizer` which
         * is invoked to produce the cloned value. If `customizer` returns `undefined`,
         * cloning is handled by the method instead. The `customizer` is invoked with
         * up to four arguments; (value [, index|key, object, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeepWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * }
         *
         * var el = _.cloneWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 0
         */
        function cloneWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @see _.clone
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.cloneWith` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the deep cloned value.
         * @see _.cloneWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * }
         *
         * var el = _.cloneDeepWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 20
         */
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * Checks if `object` conforms to `source` by invoking the predicate
         * properties of `source` with the corresponding property values of `object`.
         *
         * **Note:** This method is equivalent to `_.conforms` when `source` is
         * partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
         * // => true
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
         * // => false
         */
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         * @see _.lt
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        var gt = createRelationalOperation(baseGt);

        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to
         *  `other`, else `false`.
         * @see _.lte
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
            !propertyIsEnumerable.call(value, 'callee');
        };

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;

        /**
         * Checks if `value` is classified as an `ArrayBuffer` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         * @example
         *
         * _.isArrayBuffer(new ArrayBuffer(2));
         * // => true
         *
         * _.isArrayBuffer(new Array(2));
         * // => false
         */
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false ||
            (isObjectLike(value) && baseGetTag(value) == boolTag);
        }

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse;

        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

        /**
         * Checks if `value` is likely a DOM element.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }

        /**
         * Checks if `value` is an empty object, collection, map, or set.
         *
         * Objects are considered empty if they have no own enumerable string keyed
         * properties.
         *
         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
         * jQuery-like collections are considered empty if they have a `length` of `0`.
         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) &&
              (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }

        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are compared by strict equality, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }

        /**
         * This method is like `_.isEqual` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with up to
         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, othValue) {
         *   if (isGreeting(objValue) && isGreeting(othValue)) {
         *     return true;
         *   }
         * }
         *
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqualWith(array, other, customizer);
         * // => true
         */
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          var result = customizer ? customizer(value, other) : undefined$1;
          return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
        }

        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag ||
            (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
        }

        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on
         * [`Number.isFinite`](https://mdn.io/Number/isFinite).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(3);
         * // => true
         *
         * _.isFinite(Number.MIN_VALUE);
         * // => true
         *
         * _.isFinite(Infinity);
         * // => false
         *
         * _.isFinite('3');
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }

        /**
         * Checks if `value` is an integer.
         *
         * **Note:** This method is based on
         * [`Number.isInteger`](https://mdn.io/Number/isInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
         * @example
         *
         * _.isInteger(3);
         * // => true
         *
         * _.isInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isInteger(Infinity);
         * // => false
         *
         * _.isInteger('3');
         * // => false
         */
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value);
        }

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == 'object';
        }

        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

        /**
         * Performs a partial deep comparison between `object` and `source` to
         * determine if `object` contains equivalent property values.
         *
         * **Note:** This method is equivalent to `_.matches` when `source` is
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.isMatch(object, { 'b': 2 });
         * // => true
         *
         * _.isMatch(object, { 'b': 1 });
         * // => false
         */
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }

        /**
         * This method is like `_.isMatch` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with five
         * arguments: (objValue, srcValue, index|key, object, source).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, srcValue) {
         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
         *     return true;
         *   }
         * }
         *
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatchWith(object, source, customizer);
         * // => true
         */
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }

        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is based on
         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
         * `undefined` and other non-number values.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some
          // ActiveX objects in IE.
          return isNumber(value) && value != +value;
        }

        /**
         * Checks if `value` is a pristine native function.
         *
         * **Note:** This method can't reliably detect native functions in the presence
         * of the core-js package because core-js circumvents this kind of detection.
         * Despite multiple requests, the core-js maintainer has made it clear: any
         * attempt to fix the detection will be obstructed. As a result, we're left
         * with little choice but to throw an error. Unfortunately, this also affects
         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
         * which rely on core-js.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }

        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }

        /**
         * Checks if `value` is `null` or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
         * @example
         *
         * _.isNil(null);
         * // => true
         *
         * _.isNil(void 0);
         * // => true
         *
         * _.isNil(NaN);
         * // => false
         */
        function isNil(value) {
          return value == null;
        }

        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
         * classified as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a number, else `false`.
         * @example
         *
         * _.isNumber(3);
         * // => true
         *
         * _.isNumber(Number.MIN_VALUE);
         * // => true
         *
         * _.isNumber(Infinity);
         * // => true
         *
         * _.isNumber('3');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' ||
            (isObjectLike(value) && baseGetTag(value) == numberTag);
        }

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString;
        }

        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

        /**
         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
         * double precision number which isn't the result of a rounded unsafe integer.
         *
         * **Note:** This method is based on
         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
         * @example
         *
         * _.isSafeInteger(3);
         * // => true
         *
         * _.isSafeInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isSafeInteger(Infinity);
         * // => false
         *
         * _.isSafeInteger('3');
         * // => false
         */
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' ||
            (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
        }

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
          return typeof value == 'symbol' ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag);
        }

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined$1;
        }

        /**
         * Checks if `value` is classified as a `WeakMap` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
         * @example
         *
         * _.isWeakMap(new WeakMap);
         * // => true
         *
         * _.isWeakMap(new Map);
         * // => false
         */
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }

        /**
         * Checks if `value` is classified as a `WeakSet` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
         * @example
         *
         * _.isWeakSet(new WeakSet);
         * // => true
         *
         * _.isWeakSet(new Set);
         * // => false
         */
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }

        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         * @see _.gt
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        var lt = createRelationalOperation(baseLt);

        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to
         *  `other`, else `false`.
         * @see _.gte
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });

        /**
         * Converts `value` to an array.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * _.toArray({ 'a': 1, 'b': 2 });
         * // => [1, 2]
         *
         * _.toArray('abc');
         * // => ['a', 'b', 'c']
         *
         * _.toArray(1);
         * // => []
         *
         * _.toArray(null);
         * // => []
         */
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value),
              func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

          return func(value);
        }

        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = (value < 0 ? -1 : 1);
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }

        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */
        function toInteger(value) {
          var result = toFinite(value),
              remainder = result % 1;

          return result === result ? (remainder ? result - remainder : result) : 0;
        }

        /**
         * Converts `value` to an integer suitable for use as the length of an
         * array-like object.
         *
         * **Note:** This method is based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toLength(3.2);
         * // => 3
         *
         * _.toLength(Number.MIN_VALUE);
         * // => 0
         *
         * _.toLength(Infinity);
         * // => 4294967295
         *
         * _.toLength('3.2');
         * // => 3
         */
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject(other) ? (other + '') : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, '');
          var isBinary = reIsBinary.test(value);
          return (isBinary || reIsOctal.test(value))
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : (reIsBadHex.test(value) ? NAN : +value);
        }

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        /**
         * Converts `value` to a safe integer. A safe integer can be compared and
         * represented correctly.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toSafeInteger(3.2);
         * // => 3
         *
         * _.toSafeInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toSafeInteger(Infinity);
         * // => 9007199254740991
         *
         * _.toSafeInteger('3.2');
         * // => 3
         */
        function toSafeInteger(value) {
          return value
            ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
            : (value === 0 ? value : 0);
        }

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
          return value == null ? '' : baseToString(value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Assigns own enumerable string keyed properties of source objects to the
         * destination object. Source objects are applied from left to right.
         * Subsequent sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object` and is loosely based on
         * [`Object.assign`](https://mdn.io/Object/assign).
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assignIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assign({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'c': 3 }
         */
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });

        /**
         * This method is like `_.assign` except that it iterates over own and
         * inherited source properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assign
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assignIn({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
         */
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });

        /**
         * This method is like `_.assignIn` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extendWith
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });

        /**
         * This method is like `_.assign` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignInWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });

        /**
         * Creates an array of values corresponding to `paths` of `object`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Array} Returns the picked values.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _.at(object, ['a[0].b.c', 'a[1]']);
         * // => [3, 4]
         */
        var at = flatRest(baseAt);

        /**
         * Creates an object that inherits from the `prototype` object. If a
         * `properties` object is given, its own enumerable string keyed properties
         * are assigned to the created object.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties == null ? result : baseAssign(result, properties);
        }

        /**
         * Assigns own and inherited enumerable string keyed properties of source
         * objects to the destination object for all destination properties that
         * resolve to `undefined`. Source objects are applied from left to right.
         * Once a property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaultsDeep
         * @example
         *
         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var defaults = baseRest(function(object, sources) {
          object = Object(object);

          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }

          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;

            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];

              if (value === undefined$1 ||
                  (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                object[key] = source[key];
              }
            }
          }

          return object;
        });

        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaults
         * @example
         *
         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
         * // => { 'a': { 'b': 2, 'c': 3 } }
         */
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });

        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(o) { return o.age < 40; });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // The `_.matches` iteratee shorthand.
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }

        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(o) { return o.age < 40; });
         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }

        /**
         * Iterates over own and inherited enumerable string keyed properties of an
         * object and invokes `iteratee` for each property. The iteratee is invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forInRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
         */
        function forIn(object, iteratee) {
          return object == null
            ? object
            : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
         */
        function forInRight(object, iteratee) {
          return object == null
            ? object
            : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * Iterates over own enumerable string keyed properties of an object and
         * invokes `iteratee` for each property. The iteratee is invoked with three
         * arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwnRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn(object, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
         */
        function forOwnRight(object, iteratee) {
          return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }

        /**
         * Creates an array of function property names from own enumerable properties
         * of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functionsIn
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functions(new Foo);
         * // => ['a', 'b']
         */
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }

        /**
         * Creates an array of function property names from own and inherited
         * enumerable properties of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functions
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functionsIn(new Foo);
         * // => ['a', 'b', 'c']
         */
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined$1 : baseGet(object, path);
          return result === undefined$1 ? defaultValue : result;
        }

        /**
         * Checks if `path` is a direct property of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': 2 } };
         * var other = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b');
         * // => true
         *
         * _.has(object, ['a', 'b']);
         * // => true
         *
         * _.has(other, 'a');
         * // => false
         */
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite
         * property assignments of previous values.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Object
         * @param {Object} object The object to invert.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         */
        var invert = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          result[value] = key;
        }, constant(identity));

        /**
         * This method is like `_.invert` except that the inverted object is generated
         * from the results of running each element of `object` thru `iteratee`. The
         * corresponding inverted value of each inverted key is an array of keys
         * responsible for generating the inverted value. The iteratee is invoked
         * with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Object
         * @param {Object} object The object to invert.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invertBy(object);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         *
         * _.invertBy(object, function(value) {
         *   return 'group' + value;
         * });
         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
         */
        var invertBy = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }, getIteratee);

        /**
         * Invokes the method at `path` of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
         *
         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
         * // => [2, 3]
         */
        var invoke = baseRest(baseInvoke);

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }

        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * string keyed property of `object` thru `iteratee`. The iteratee is invoked
         * with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapValues
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        function mapKeys(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, iteratee(value, key, object), value);
          });
          return result;
        }

        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
          });
          return result;
        }

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });

        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined`, merging is handled by the
         * method instead. The `customizer` is invoked with six arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = { 'a': [1], 'b': [2] };
         * var other = { 'a': [3], 'b': [4] };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'a': [1, 3], 'b': [2, 4] }
         */
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        var omit = flatRest(function(object, paths) {
          var result = {};
          if (object == null) {
            return result;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result);
          if (isDeep) {
            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result, paths[length]);
          }
          return result;
        });

        /**
         * The opposite of `_.pickBy`; this method creates an object composed of
         * the own and inherited enumerable string keyed properties of `object` that
         * `predicate` doesn't return truthy for. The predicate is invoked with two
         * arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omitBy(object, _.isNumber);
         * // => { 'b': '2' }
         */
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }

        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });

        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }

        /**
         * This method is like `_.get` except that if the resolved value is a
         * function it's invoked with the `this` binding of its parent object and
         * its result is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a[0].b.c3', 'default');
         * // => 'default'
         *
         * _.result(object, 'a[0].b.c3', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          path = castPath(path, object);

          var index = -1,
              length = path.length;

          // Ensure the loop is entered when path is empty.
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }

        /**
         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
         * it's created. Arrays are created for missing index properties while objects
         * are created for all other missing properties. Use `_.setWith` to customize
         * `path` creation.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, ['x', '0', 'y', 'z'], 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }

        /**
         * This method is like `_.set` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.setWith(object, '[0][1]', 'a', Object);
         * // => { '0': { '1': 'a' } }
         */
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }

        /**
         * Creates an array of own enumerable string keyed-value pairs for `object`
         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
         * entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entries
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairs(new Foo);
         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
         */
        var toPairs = createToPairs(keys);

        /**
         * Creates an array of own and inherited enumerable string keyed-value pairs
         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
         * or set, its entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entriesIn
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairsIn(new Foo);
         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
         */
        var toPairsIn = createToPairs(keysIn);

        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own
         * enumerable string keyed properties thru `iteratee`, with each invocation
         * potentially mutating the `accumulator` object. If `accumulator` is not
         * provided, a new object with the same `[[Prototype]]` will be used. The
         * iteratee is invoked with four arguments: (accumulator, value, key, object).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * }, []);
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function transform(object, iteratee, accumulator) {
          var isArr = isArray(object),
              isArrLike = isArr || isBuffer(object) || isTypedArray(object);

          iteratee = getIteratee(iteratee, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor : [];
            }
            else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
            else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }

        /**
         * Removes the property at `path` of `object`.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
         * _.unset(object, 'a[0].b.c');
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         *
         * _.unset(object, ['a', '0', 'b', 'c']);
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         */
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }

        /**
         * This method is like `_.set` except that accepts `updater` to produce the
         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
         * is invoked with one argument: (value).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
         * console.log(object.a[0].b.c);
         * // => 9
         *
         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
         * console.log(object.x[0].y.z);
         * // => 0
         */
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }

        /**
         * This method is like `_.update` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
         * // => { '0': { '1': 'a' } }
         */
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }

        /**
         * Creates an array of the own enumerable string keyed property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }

        /**
         * Creates an array of the own and inherited enumerable string keyed property
         * values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }

        /*------------------------------------------------------------------------*/

        /**
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Number
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         * // => 5
         */
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }

        /**
         * Checks if `n` is between `start` and up to, but not including, `end`. If
         * `end` is not specified, it's set to `start` with `start` then set to `0`.
         * If `start` is greater than `end` the params are swapped to support
         * negative ranges.
         *
         * @static
         * @memberOf _
         * @since 3.3.0
         * @category Number
         * @param {number} number The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         * @see _.range, _.rangeRight
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         *
         * _.inRange(-3, -2, -6);
         * // => true
         */
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }

        /**
         * Produces a random number between the inclusive `lower` and `upper` bounds.
         * If only one argument is provided a number between `0` and the given number
         * is returned. If `floating` is `true`, or either `lower` or `upper` are
         * floats, a floating-point number is returned instead of an integer.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Number
         * @param {number} [lower=0] The lower bound.
         * @param {number} [upper=1] The upper bound.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(lower, upper, floating) {
          if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == 'boolean') {
              floating = upper;
              upper = undefined$1;
            }
            else if (typeof lower == 'boolean') {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          }
          else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
          }
          return baseRandom(lower, upper);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar--');
         * // => 'fooBar'
         *
         * _.camelCase('__FOO_BAR__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? capitalize(word) : word);
        });

        /**
         * Converts the first character of `string` to upper case and the remaining
         * to lower case.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('FRED');
         * // => 'Fred'
         */
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }

        /**
         * Deburrs `string` by converting
         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
         * letters to basic Latin letters and removing
         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('dj vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
        }

        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search up to.
         * @returns {boolean} Returns `true` if `string` ends with `target`,
         *  else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);

          var length = string.length;
          position = position === undefined$1
            ? length
            : baseClamp(toInteger(position), 0, length);

          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }

        /**
         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
         * corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional
         * characters use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value. See
         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * When working with HTML you should always
         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
         * XSS vectors.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          string = toString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }

        /**
         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
         * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https://lodash\.com/\)'
         */
        function escapeRegExp(string) {
          string = toString(string);
          return (string && reHasRegExpChar.test(string))
            ? string.replace(reRegExpChar, '\\$&')
            : string;
        }

        /**
         * Converts `string` to
         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__FOO_BAR__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });

        /**
         * Converts `string`, as space separated words, to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.lowerCase('--Foo-Bar--');
         * // => 'foo bar'
         *
         * _.lowerCase('fooBar');
         * // => 'foo bar'
         *
         * _.lowerCase('__FOO_BAR__');
         * // => 'foo bar'
         */
        var lowerCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase();
        });

        /**
         * Converts the first character of `string` to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.lowerFirst('Fred');
         * // => 'fred'
         *
         * _.lowerFirst('FRED');
         * // => 'fRED'
         */
        var lowerFirst = createCaseFirst('toLowerCase');

        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return (
            createPadding(nativeFloor(mid), chars) +
            string +
            createPadding(nativeCeil(mid), chars)
          );
        }

        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padEnd('abc', 6);
         * // => 'abc   '
         *
         * _.padEnd('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padEnd('abc', 3);
         * // => 'abc'
         */
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (string + createPadding(length - strLength, chars))
            : string;
        }

        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padStart('abc', 6);
         * // => '   abc'
         *
         * _.padStart('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padStart('abc', 3);
         * // => 'abc'
         */
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (createPadding(length - strLength, chars) + string)
            : string;
        }

        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
         * hexadecimal, in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the
         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix=10] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
        }

        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=1] The number of times to repeat the string.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n, guard) {
          if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }

        /**
         * Replaces matches for `pattern` in `string` with `replacement`.
         *
         * **Note:** This method is based on
         * [`String#replace`](https://mdn.io/String/replace).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to modify.
         * @param {RegExp|string} pattern The pattern to replace.
         * @param {Function|string} replacement The match replacement.
         * @returns {string} Returns the modified string.
         * @example
         *
         * _.replace('Hi Fred', 'Fred', 'Barney');
         * // => 'Hi Barney'
         */
        function replace() {
          var args = arguments,
              string = toString(args[0]);

          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }

        /**
         * Converts `string` to
         * [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--FOO-BAR--');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });

        /**
         * Splits `string` by `separator`.
         *
         * **Note:** This method is based on
         * [`String#split`](https://mdn.io/String/split).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to split.
         * @param {RegExp|string} separator The separator pattern to split by.
         * @param {number} [limit] The length to truncate results to.
         * @returns {Array} Returns the string segments.
         * @example
         *
         * _.split('a-b-c', '-', 2);
         * // => ['a', 'b']
         */
        function split(string, separator, limit) {
          if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (
                typeof separator == 'string' ||
                (separator != null && !isRegExp(separator))
              )) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }

        /**
         * Converts `string` to
         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @since 3.1.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar--');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__FOO_BAR__');
         * // => 'FOO BAR'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + upperFirst(word);
        });

        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`,
         *  else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null
            ? 0
            : baseClamp(toInteger(position), 0, string.length);

          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }

        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is given, it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options={}] The options object.
         * @param {RegExp} [options.escape=_.templateSettings.escape]
         *  The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
         *  The "evaluate" delimiter.
         * @param {Object} [options.imports=_.templateSettings.imports]
         *  An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
         *  The "interpolate" delimiter.
         * @param {string} [options.sourceURL='lodash.templateSources[n]']
         *  The sourceURL of the compiled template.
         * @param {string} [options.variable='obj']
         *  The data object variable name.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // Use the "interpolate" delimiter to create a compiled template.
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // Use the HTML "escape" delimiter to escape data property values.
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the internal `print` function in "evaluate" delimiters.
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // Use the ES template literal delimiter as an "interpolate" delimiter.
         * // Disable support by replacing the "interpolate" delimiter.
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // Use backslashes to treat delimiters as plain text.
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // Use the `imports` option to import `jQuery` as `jq`.
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
         *
         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // Use custom template delimiters.
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // Use the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and stack traces.
         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, guard) {
          // Based on John Resig's `tmpl` implementation
          // (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;

          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);

          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);

          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";

          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');

          // Use a sourceURL for easier debugging.
          // The sourceURL gets injected into the source that's eval-ed, so be careful
          // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
          // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
          var sourceURL = '//# sourceURL=' +
            (hasOwnProperty.call(options, 'sourceURL')
              ? (options.sourceURL + '').replace(/[\r\n]/g, ' ')
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';

          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);

            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;

            // The JS engine embedded in Adobe products needs `match` returned in
            // order to produce the correct `offset` value.
            return match;
          });

          source += "';\n";

          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          // Like with sourceURL, we take care to not check the option's prototype,
          // as this configuration is a code injection vector.
          var variable = hasOwnProperty.call(options, 'variable') && options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');

          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';

          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source)
              .apply(undefined$1, importsValues);
          });

          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }

        /**
         * Converts `string`, as a whole, to lower case just like
         * [String#toLowerCase](https://mdn.io/toLowerCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.toLower('--Foo-Bar--');
         * // => '--foo-bar--'
         *
         * _.toLower('fooBar');
         * // => 'foobar'
         *
         * _.toLower('__FOO_BAR__');
         * // => '__foo_bar__'
         */
        function toLower(value) {
          return toString(value).toLowerCase();
        }

        /**
         * Converts `string`, as a whole, to upper case just like
         * [String#toUpperCase](https://mdn.io/toUpperCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.toUpper('--foo-bar--');
         * // => '--FOO-BAR--'
         *
         * _.toUpper('fooBar');
         * // => 'FOOBAR'
         *
         * _.toUpper('__foo_bar__');
         * // => '__FOO_BAR__'
         */
        function toUpper(value) {
          return toString(value).toUpperCase();
        }

        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrim, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars),
              start = charsStartIndex(strSymbols, chrSymbols),
              end = charsEndIndex(strSymbols, chrSymbols) + 1;

          return castSlice(strSymbols, start, end).join('');
        }

        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimEnd('  abc  ');
         * // => '  abc'
         *
         * _.trimEnd('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimEnd, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

          return castSlice(strSymbols, 0, end).join('');
        }

        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimStart('  abc  ');
         * // => 'abc  '
         *
         * _.trimStart('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              start = charsStartIndex(strSymbols, stringToArray(chars));

          return castSlice(strSymbols, start).join('');
        }

        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object} [options={}] The options object.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.truncate('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;

          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? toInteger(options.length) : length;
            omission = 'omission' in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);

          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result = strSymbols
            ? castSlice(strSymbols, 0, end).join('')
            : string.slice(0, end);

          if (separator === undefined$1) {
            return result + omission;
          }
          if (strSymbols) {
            end += (result.length - end);
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  substring = result;

              if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }

        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
         * their corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional
         * HTML entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @since 0.6.0
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = toString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }

        /**
         * Converts `string`, as space separated words, to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.upperCase('--foo-bar');
         * // => 'FOO BAR'
         *
         * _.upperCase('fooBar');
         * // => 'FOO BAR'
         *
         * _.upperCase('__foo_bar__');
         * // => 'FOO BAR'
         */
        var upperCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase();
        });

        /**
         * Converts the first character of `string` to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.upperFirst('fred');
         * // => 'Fred'
         *
         * _.upperFirst('FRED');
         * // => 'FRED'
         */
        var upperFirst = createCaseFirst('toUpperCase');

        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;

          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }

        /*------------------------------------------------------------------------*/

        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Function} func The function to attempt.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // Avoid throwing errors for invalid selectors.
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });

        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method.
         *
         * **Note:** This method doesn't set the "length" property of bound functions.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} methodNames The object method names to bind.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'click': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view, ['click']);
         * jQuery(element).on('click', view.click);
         * // => Logs 'clicked docs' when clicked.
         */
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });

        /**
         * Creates a function that iterates over `pairs` and invokes the corresponding
         * function of the first predicate to return truthy. The predicate-function
         * pairs are invoked with the `this` binding and arguments of the created
         * function.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Array} pairs The predicate-function pairs.
         * @returns {Function} Returns the new composite function.
         * @example
         *
         * var func = _.cond([
         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
         *   [_.stubTrue,                      _.constant('no match')]
         * ]);
         *
         * func({ 'a': 1, 'b': 2 });
         * // => 'matches A'
         *
         * func({ 'a': 0, 'b': 1 });
         * // => 'matches B'
         *
         * func({ 'a': '1', 'b': '2' });
         * // => 'no match'
         */
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length,
              toIteratee = getIteratee();

          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });

          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }

        /**
         * Creates a function that invokes the predicate properties of `source` with
         * the corresponding property values of a given object, returning `true` if
         * all predicates return truthy, else `false`.
         *
         * **Note:** The created function is equivalent to `_.conformsTo` with
         * `source` partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 2, 'b': 1 },
         *   { 'a': 1, 'b': 2 }
         * ];
         *
         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
         * // => [{ 'a': 1, 'b': 2 }]
         */
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }

        /**
         * Checks `value` to determine whether a default value should be returned in
         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
         * or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Util
         * @param {*} value The value to check.
         * @param {*} defaultValue The default value.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * _.defaultTo(1, 10);
         * // => 1
         *
         * _.defaultTo(undefined, 10);
         * // => 10
         */
        function defaultTo(value, defaultValue) {
          return (value == null || value !== value) ? defaultValue : value;
        }

        /**
         * Creates a function that returns the result of invoking the given functions
         * with the `this` binding of the created function, where each successive
         * invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flowRight
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow([_.add, square]);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();

        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the given functions from right to left.
         *
         * @static
         * @since 3.0.0
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flow
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight([square, _.add]);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        /**
         * Creates a function that invokes `func` with the arguments of the created
         * function. If `func` is a property name, the created function returns the
         * property value for a given element. If `func` is an array or object, the
         * created function returns `true` for elements that contain the equivalent
         * source properties, otherwise it returns `false`.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Util
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, _.iteratee(['user', 'fred']));
         * // => [{ 'user': 'fred', 'age': 40 }]
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, _.iteratee('user'));
         * // => ['barney', 'fred']
         *
         * // Create custom iteratee shorthands.
         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
         *     return func.test(string);
         *   };
         * });
         *
         * _.filter(['abc', 'def'], /ef/);
         * // => ['def']
         */
        function iteratee(func) {
          return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between a given
         * object and `source`, returning `true` if the given object has equivalent
         * property values, else `false`.
         *
         * **Note:** The created function is equivalent to `_.isMatch` with `source`
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between the
         * value at `path` of a given object to `srcValue`, returning `true` if the
         * object value is equivalent, else `false`.
         *
         * **Note:** Partial comparisons will match empty array and empty object
         * `srcValue` values against any array or object value, respectively. See
         * `_.isEqual` for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.find(objects, _.matchesProperty('a', 4));
         * // => { 'a': 4, 'b': 5, 'c': 6 }
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that invokes the method at `path` of a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': _.constant(2) } },
         *   { 'a': { 'b': _.constant(1) } }
         * ];
         *
         * _.map(objects, _.method('a.b'));
         * // => [2, 1]
         *
         * _.map(objects, _.method(['a', 'b']));
         * // => [2, 1]
         */
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path of `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * Adds all own enumerable string keyed function properties of a source
         * object to the destination object. If `object` is a function, then methods
         * are added to its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          var props = keys(source),
              methodNames = baseFunctions(source, props);

          if (options == null &&
              !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
              isFunc = isFunction(object);

          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__),
                      actions = result.__actions__ = copyArray(this.__actions__);

                  actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });

          return object;
        }

        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }

        /**
         * This method returns `undefined`.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Util
         * @example
         *
         * _.times(2, _.noop);
         * // => [undefined, undefined]
         */
        function noop() {
          // No operation performed.
        }

        /**
         * Creates a function that gets the argument at index `n`. If `n` is negative,
         * the nth argument from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [n=0] The index of the argument to return.
         * @returns {Function} Returns the new pass-thru function.
         * @example
         *
         * var func = _.nthArg(1);
         * func('a', 'b', 'c', 'd');
         * // => 'b'
         *
         * var func = _.nthArg(-2);
         * func('a', 'b', 'c', 'd');
         * // => 'c'
         */
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }

        /**
         * Creates a function that invokes `iteratees` with the arguments it receives
         * and returns their results.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.over([Math.max, Math.min]);
         *
         * func(1, 2, 3, 4);
         * // => [4, 1]
         */
        var over = createOver(arrayMap);

        /**
         * Creates a function that checks if **all** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overEvery([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => false
         *
         * func(NaN);
         * // => false
         */
        var overEvery = createOver(arrayEvery);

        /**
         * Creates a function that checks if **any** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overSome([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => true
         *
         * func(NaN);
         * // => false
         */
        var overSome = createOver(arraySome);

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }

        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the value at a given path of `object`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }

        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        var range = createRange();

        /**
         * This method is like `_.range` except that it populates values in
         * descending order.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.range
         * @example
         *
         * _.rangeRight(4);
         * // => [3, 2, 1, 0]
         *
         * _.rangeRight(-4);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 5);
         * // => [4, 3, 2, 1]
         *
         * _.rangeRight(0, 20, 5);
         * // => [15, 10, 5, 0]
         *
         * _.rangeRight(0, -4, -1);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.rangeRight(0);
         * // => []
         */
        var rangeRight = createRange(true);

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        /**
         * This method returns a new empty object.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Object} Returns the new empty object.
         * @example
         *
         * var objects = _.times(2, _.stubObject);
         *
         * console.log(objects);
         * // => [{}, {}]
         *
         * console.log(objects[0] === objects[1]);
         * // => false
         */
        function stubObject() {
          return {};
        }

        /**
         * This method returns an empty string.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {string} Returns the empty string.
         * @example
         *
         * _.times(2, _.stubString);
         * // => ['', '']
         */
        function stubString() {
          return '';
        }

        /**
         * This method returns `true`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `true`.
         * @example
         *
         * _.times(2, _.stubTrue);
         * // => [true, true]
         */
        function stubTrue() {
          return true;
        }

        /**
         * Invokes the iteratee `n` times, returning an array of the results of
         * each invocation. The iteratee is invoked with one argument; (index).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.times(3, String);
         * // => ['0', '1', '2']
         *
         *  _.times(4, _.constant(0));
         * // => [0, 0, 0, 0]
         */
        function times(n, iteratee) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);

          iteratee = getIteratee(iteratee);
          n -= MAX_ARRAY_LENGTH;

          var result = baseTimes(length, iteratee);
          while (++index < n) {
            iteratee(index);
          }
          return result;
        }

        /**
         * Converts `value` to a property path array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {*} value The value to convert.
         * @returns {Array} Returns the new property path array.
         * @example
         *
         * _.toPath('a.b.c');
         * // => ['a', 'b', 'c']
         *
         * _.toPath('a[0].b.c');
         * // => ['a', '0', 'b', 'c']
         */
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }

        /**
         * Generates a unique ID. If `prefix` is given, the ID is appended to it.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {string} [prefix=''] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {number} augend The first number in an addition.
         * @param {number} addend The second number in an addition.
         * @returns {number} Returns the total.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);

        /**
         * Computes `number` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        var ceil = createRound('ceil');

        /**
         * Divide two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} dividend The first number in a division.
         * @param {number} divisor The second number in a division.
         * @returns {number} Returns the quotient.
         * @example
         *
         * _.divide(6, 4);
         * // => 1.5
         */
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);

        /**
         * Computes `number` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        var floor = createRound('floor');

        /**
         * Computes the maximum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => undefined
         */
        function max(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseGt)
            : undefined$1;
        }

        /**
         * This method is like `_.max` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.maxBy(objects, function(o) { return o.n; });
         * // => { 'n': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.maxBy(objects, 'n');
         * // => { 'n': 2 }
         */
        function maxBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
            : undefined$1;
        }

        /**
         * Computes the mean of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the mean.
         * @example
         *
         * _.mean([4, 2, 8, 6]);
         * // => 5
         */
        function mean(array) {
          return baseMean(array, identity);
        }

        /**
         * This method is like `_.mean` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be averaged.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the mean.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.meanBy(objects, function(o) { return o.n; });
         * // => 5
         *
         * // The `_.property` iteratee shorthand.
         * _.meanBy(objects, 'n');
         * // => 5
         */
        function meanBy(array, iteratee) {
          return baseMean(array, getIteratee(iteratee, 2));
        }

        /**
         * Computes the minimum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => undefined
         */
        function min(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseLt)
            : undefined$1;
        }

        /**
         * This method is like `_.min` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.minBy(objects, function(o) { return o.n; });
         * // => { 'n': 1 }
         *
         * // The `_.property` iteratee shorthand.
         * _.minBy(objects, 'n');
         * // => { 'n': 1 }
         */
        function minBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
            : undefined$1;
        }

        /**
         * Multiply two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} multiplier The first number in a multiplication.
         * @param {number} multiplicand The second number in a multiplication.
         * @returns {number} Returns the product.
         * @example
         *
         * _.multiply(6, 4);
         * // => 24
         */
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);

        /**
         * Computes `number` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        var round = createRound('round');

        /**
         * Subtract two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {number} minuend The first number in a subtraction.
         * @param {number} subtrahend The second number in a subtraction.
         * @returns {number} Returns the difference.
         * @example
         *
         * _.subtract(6, 4);
         * // => 2
         */
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);

        /**
         * Computes the sum of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 2, 8, 6]);
         * // => 20
         */
        function sum(array) {
          return (array && array.length)
            ? baseSum(array, identity)
            : 0;
        }

        /**
         * This method is like `_.sum` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be summed.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the sum.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.sumBy(objects, function(o) { return o.n; });
         * // => 20
         *
         * // The `_.property` iteratee shorthand.
         * _.sumBy(objects, 'n');
         * // => 20
         */
        function sumBy(array, iteratee) {
          return (array && array.length)
            ? baseSum(array, getIteratee(iteratee, 2))
            : 0;
        }

        /*------------------------------------------------------------------------*/

        // Add methods that return wrapped values in chain sequences.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;

        // Add aliases.
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;

        // Add methods to `lodash.prototype`.
        mixin(lodash, lodash);

        /*------------------------------------------------------------------------*/

        // Add methods that return unwrapped values in chain sequences.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;

        // Add aliases.
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;

        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }()), { 'chain': false });

        /*------------------------------------------------------------------------*/

        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type {string}
         */
        lodash.VERSION = VERSION;

        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });

        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

            var result = (this.__filtered__ && !index)
              ? new LazyWrapper(this)
              : this.clone();

            if (result.__filtered__) {
              result.__takeCount__ = nativeMin(n, result.__takeCount__);
            } else {
              result.__views__.push({
                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };

          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });

        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

          LazyWrapper.prototype[methodName] = function(iteratee) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getIteratee(iteratee, 3),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });

        // Add `LazyWrapper` methods for `_.head` and `_.last`.
        arrayEach(['head', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');

          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });

        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
        arrayEach(['initial', 'tail'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');

          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });

        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };

        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };

        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };

        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == 'function') {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });

        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };

        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);

          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };

        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };

        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };

        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);

          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);

            var interceptor = function(value) {
              var result = lodashFunc.apply(lodash, arrayPush([value], args));
              return (isTaker && chainAll) ? result[0] : result;
            };

            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;

            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
              return new LodashWrapper(result, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result = this.thru(interceptor);
            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
          };
        });

        // Add `Array` methods to `lodash.prototype`.
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);

          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value) {
              return func.apply(isArray(value) ? value : [], args);
            });
          };
        });

        // Map minified method names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + '';
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ 'name': methodName, 'func': lodashFunc });
          }
        });

        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined$1
        }];

        // Add methods to `LazyWrapper`.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;

        // Add chain sequence methods to the `lodash` wrapper.
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

        // Add lazy aliases.
        lodash.prototype.first = lodash.prototype.head;

        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      });

      /*--------------------------------------------------------------------------*/

      // Export lodash.
      var _ = runInContext();

      // Some AMD build optimizers, like r.js, check for condition patterns like:
      if (freeModule) {
        // Export for Node.js.
        (freeModule.exports = _)._ = _;
        // Export for CommonJS support.
        freeExports._ = _;
      }
      else {
        // Export to the global object.
        root._ = _;
      }
    }.call(commonjsGlobal));
    });

    var index_umd = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory() ;
    }(commonjsGlobal, function () {
      var defaultExport = /*@__PURE__*/(function (Error) {
        function defaultExport(route, path) {
          var message = "Unreachable '" + route + "', segment '" + path + "' is not defined";
          Error.call(this, message);
          this.message = message;
        }

        if ( Error ) defaultExport.__proto__ = Error;
        defaultExport.prototype = Object.create( Error && Error.prototype );
        defaultExport.prototype.constructor = defaultExport;

        return defaultExport;
      }(Error));

      function buildMatcher(path, parent) {
        var regex;

        var _isSplat;

        var _priority = -100;

        var keys = [];
        regex = path.replace(/[-$.]/g, '\\$&').replace(/\(/g, '(?:').replace(/\)/g, ')?').replace(/([:*]\w+)(?:<([^<>]+?)>)?/g, function (_, key, expr) {
          keys.push(key.substr(1));

          if (key.charAt() === ':') {
            _priority += 100;
            return ("((?!#)" + (expr || '[^/]+?') + ")");
          }

          _isSplat = true;
          _priority += 500;
          return ("((?!#)" + (expr || '.+?') + ")");
        });

        try {
          regex = new RegExp(("^" + regex + "$"));
        } catch (e) {
          throw new TypeError(("Invalid route expression, given '" + parent + "'"));
        }

        var _hashed = path.includes('#') ? 0.5 : 1;

        var _depth = path.length * _priority * _hashed;

        return {
          keys: keys,
          regex: regex,
          _depth: _depth,
          _isSplat: _isSplat
        };
      }
      var PathMatcher = function PathMatcher(path, parent) {
        var ref = buildMatcher(path, parent);
        var keys = ref.keys;
        var regex = ref.regex;
        var _depth = ref._depth;
        var _isSplat = ref._isSplat;
        return {
          _isSplat: _isSplat,
          _depth: _depth,
          match: function (value) {
            var matches = value.match(regex);

            if (matches) {
              return keys.reduce(function (prev, cur, i) {
                prev[cur] = typeof matches[i + 1] === 'string' ? decodeURIComponent(matches[i + 1]) : null;
                return prev;
              }, {});
            }
          }
        };
      };

      PathMatcher.push = function push (key, prev, leaf, parent) {
        var root = prev[key] || (prev[key] = {});

        if (!root.pattern) {
          root.pattern = new PathMatcher(key, parent);
          root.route = leaf || '/';
        }

        prev.keys = prev.keys || [];

        if (!prev.keys.includes(key)) {
          prev.keys.push(key);
          PathMatcher.sort(prev);
        }

        return root;
      };

      PathMatcher.sort = function sort (root) {
        root.keys.sort(function (a, b) {
          return root[a].pattern._depth - root[b].pattern._depth;
        });
      };

      function merge(path, parent) {
        return ("" + (parent && parent !== '/' ? parent : '') + (path || ''));
      }
      function walk(path, cb) {
        var matches = path.match(/<[^<>]*\/[^<>]*>/);

        if (matches) {
          throw new TypeError(("RegExp cannot contain slashes, given '" + matches + "'"));
        }

        var parts = path !== '/' ? path.split('/') : [''];
        var root = [];
        parts.some(function (x, i) {
          var parent = root.concat(x).join('/') || null;
          var segment = parts.slice(i + 1).join('/') || null;
          var retval = cb(("/" + x), parent, segment ? ((x ? ("/" + x) : '') + "/" + segment) : null);
          root.push(x);
          return retval;
        });
      }
      function reduce(key, root, _seen) {
        var params = {};
        var out = [];
        var splat;
        walk(key, function (x, leaf, extra) {
          var found;

          if (!root.keys) {
            throw new defaultExport(key, x);
          }

          root.keys.some(function (k) {
            if (_seen.includes(k)) { return false; }
            var ref = root[k].pattern;
            var match = ref.match;
            var _isSplat = ref._isSplat;
            var matches = match(_isSplat ? extra || x : x);

            if (matches) {
              Object.assign(params, matches);

              if (root[k].route) {
                out.push(Object.assign({}, root[k].info, {
                  matches: x === leaf || _isSplat || !extra,
                  params: Object.assign({}, params),
                  route: root[k].route,
                  path: _isSplat ? extra : leaf || x
                }));
              }

              if (extra === null && !root[k].keys) {
                return true;
              }

              if (k !== '/') { _seen.push(k); }
              splat = _isSplat;
              root = root[k];
              found = true;
              return true;
            }

            return false;
          });

          if (!(found || root.keys.some(function (k) { return root[k].pattern.match(x); }))) {
            throw new defaultExport(key, x);
          }

          return splat || !found;
        });
        return out;
      }
      function find(path, routes, retries) {
        var get = reduce.bind(null, path, routes);
        var set = [];

        while (retries > 0) {
          retries -= 1;

          try {
            return get(set);
          } catch (e) {
            if (retries > 0) {
              return get(set);
            }

            throw e;
          }
        }
      }
      function add(path, routes, parent, routeInfo) {
        var fullpath = merge(path, parent);
        var root = routes;
        walk(fullpath, function (x, leaf) {
          root = PathMatcher.push(x, root, leaf, fullpath);

          if (x !== '/') {
            root.info = root.info || Object.assign({}, routeInfo);
          }
        });
        root.info = root.info || Object.assign({}, routeInfo);
        return fullpath;
      }
      function rm(path, routes, parent) {
        var fullpath = merge(path, parent);
        var root = routes;
        var leaf = null;
        var key = null;
        walk(fullpath, function (x) {
          if (!root) {
            leaf = null;
            return true;
          }

          key = x;
          leaf = x === '/' ? routes['/'] : root;

          if (!leaf.keys) {
            throw new defaultExport(path, x);
          }

          root = root[x];
        });

        if (!(leaf && key)) {
          throw new defaultExport(path, key);
        }

        delete leaf[key];

        if (key === '/') {
          delete leaf.info;
          delete leaf.route;
        }

        var offset = leaf.keys.indexOf(key);

        if (offset !== -1) {
          leaf.keys.splice(leaf.keys.indexOf(key), 1);
          PathMatcher.sort(leaf);
        }
      }

      var Router = function Router() {
        var routes = {};
        var stack = [];
        return {
          mount: function (path, cb) {
            if (path !== '/') {
              stack.push(path);
            }

            cb();
            stack.pop();
          },
          find: function (path, retries) { return find(path, routes, retries === true ? 2 : retries || 1); },
          add: function (path, routeInfo) { return add(path, routes, stack.join(''), routeInfo); },
          rm: function (path) { return rm(path, routes, stack.join('')); }
        };
      };

      return Router;

    }));
    });

    /* node_modules/svero/src/Router.svelte generated by Svelte v3.6.7 */



    const router = new index_umd();

    /* src/patterns/Aare.svelte generated by Svelte v3.6.7 */

    const file = "src/patterns/Aare.svelte";

    function create_fragment(ctx) {
    	var svg, g2, g1, g0, path0, path0_fill_value, path1, path1_fill_value, path2, path2_fill_value, path3, path3_fill_value, path4, path4_fill_value, path5, path5_fill_value, path6, path6_fill_value, path7, path7_fill_value, path8, path8_fill_value, path9, path9_fill_value, path10, path10_fill_value, path11, path11_fill_value, path12, path12_fill_value, path13, path13_fill_value, path14, path14_fill_value, path15, path15_fill_value, path16, path16_fill_value, path17, path17_fill_value, path18, path18_fill_value, path19, path19_fill_value, path20, path20_fill_value, path21, path21_fill_value, path22, path22_fill_value, path23, path23_fill_value, path24, path24_fill_value, path25, path25_fill_value, path26, path26_fill_value, path27, path27_fill_value, path28, path28_fill_value, path29, path29_fill_value, path30, path30_fill_value, path31, path31_fill_value, path32, path32_fill_value, path33, path33_fill_value, path34, path34_fill_value, path35, path35_fill_value, path36, path36_fill_value, path37, path37_fill_value, path38, path38_fill_value, path39, path39_fill_value, path40, path40_fill_value, path41, path41_fill_value, path42, path42_fill_value, path43, path43_fill_value, path44, path44_fill_value, path45, path45_fill_value, path46, path46_fill_value, path47, path47_fill_value, path48, path48_fill_value, path49, path49_fill_value, path50, path50_fill_value, path51, path51_fill_value, path52, path52_fill_value, path53, path53_fill_value, path54, path54_fill_value, path55, path55_fill_value, path56, path56_fill_value, path57, path57_fill_value, path58, path58_fill_value, path59, path59_fill_value, path60, path60_fill_value, path61, path61_fill_value, path62, path62_fill_value, path63, path63_fill_value, path64, path64_fill_value, path65, path65_fill_value, path66, path66_fill_value, path67, path67_fill_value, path68, path68_fill_value, path69, path69_fill_value, path70, path70_fill_value, path71, path71_fill_value, path72, path72_fill_value, path73, path73_fill_value, path74, path74_fill_value, path75, path75_fill_value, path76, path76_fill_value, path77, path77_fill_value, path78, path78_fill_value, path79, path79_fill_value, path80, path80_fill_value, path81, path81_fill_value, path82, path82_fill_value, path83, path83_fill_value, path84, path84_fill_value, path85, path85_fill_value, path86, path86_fill_value, path87, path87_fill_value, path88, path88_fill_value, path89, path89_fill_value, path90, path90_fill_value, path91, path91_fill_value, path92, path92_fill_value, path93, path93_fill_value, path94, path94_fill_value, path95, path95_fill_value, path96, path96_fill_value, path97, path97_fill_value, path98, path98_fill_value, path99, path99_fill_value, path100, path100_fill_value, path101, path101_fill_value, path102, path102_fill_value, path103, path103_fill_value, path104, path104_fill_value, path105, path105_fill_value, path106, path106_fill_value, path107, path107_fill_value, path108, path108_fill_value, path109, path109_fill_value, path110, path110_fill_value, path111, path111_fill_value, path112, path112_fill_value, path113, path113_fill_value, path114, path114_fill_value, path115, path115_fill_value, path116, path116_fill_value, path117, path117_fill_value, path118, path118_fill_value, path119, path119_fill_value, path120, path120_fill_value, path121, path121_fill_value, path122, path122_fill_value, path123, path123_fill_value, path124, path124_fill_value, path125, path125_fill_value, path126, path126_fill_value, path127, path127_fill_value, path128, path128_fill_value, path129, path129_fill_value, path130, path130_fill_value, path131, path131_fill_value, path132, path132_fill_value, path133, path133_fill_value, path134, path134_fill_value, path135, path135_fill_value, path136, path136_fill_value, path137, path137_fill_value, path138, path138_fill_value;

    	return {
    		c: function create() {
    			svg = svg_element("svg");
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			path13 = svg_element("path");
    			path14 = svg_element("path");
    			path15 = svg_element("path");
    			path16 = svg_element("path");
    			path17 = svg_element("path");
    			path18 = svg_element("path");
    			path19 = svg_element("path");
    			path20 = svg_element("path");
    			path21 = svg_element("path");
    			path22 = svg_element("path");
    			path23 = svg_element("path");
    			path24 = svg_element("path");
    			path25 = svg_element("path");
    			path26 = svg_element("path");
    			path27 = svg_element("path");
    			path28 = svg_element("path");
    			path29 = svg_element("path");
    			path30 = svg_element("path");
    			path31 = svg_element("path");
    			path32 = svg_element("path");
    			path33 = svg_element("path");
    			path34 = svg_element("path");
    			path35 = svg_element("path");
    			path36 = svg_element("path");
    			path37 = svg_element("path");
    			path38 = svg_element("path");
    			path39 = svg_element("path");
    			path40 = svg_element("path");
    			path41 = svg_element("path");
    			path42 = svg_element("path");
    			path43 = svg_element("path");
    			path44 = svg_element("path");
    			path45 = svg_element("path");
    			path46 = svg_element("path");
    			path47 = svg_element("path");
    			path48 = svg_element("path");
    			path49 = svg_element("path");
    			path50 = svg_element("path");
    			path51 = svg_element("path");
    			path52 = svg_element("path");
    			path53 = svg_element("path");
    			path54 = svg_element("path");
    			path55 = svg_element("path");
    			path56 = svg_element("path");
    			path57 = svg_element("path");
    			path58 = svg_element("path");
    			path59 = svg_element("path");
    			path60 = svg_element("path");
    			path61 = svg_element("path");
    			path62 = svg_element("path");
    			path63 = svg_element("path");
    			path64 = svg_element("path");
    			path65 = svg_element("path");
    			path66 = svg_element("path");
    			path67 = svg_element("path");
    			path68 = svg_element("path");
    			path69 = svg_element("path");
    			path70 = svg_element("path");
    			path71 = svg_element("path");
    			path72 = svg_element("path");
    			path73 = svg_element("path");
    			path74 = svg_element("path");
    			path75 = svg_element("path");
    			path76 = svg_element("path");
    			path77 = svg_element("path");
    			path78 = svg_element("path");
    			path79 = svg_element("path");
    			path80 = svg_element("path");
    			path81 = svg_element("path");
    			path82 = svg_element("path");
    			path83 = svg_element("path");
    			path84 = svg_element("path");
    			path85 = svg_element("path");
    			path86 = svg_element("path");
    			path87 = svg_element("path");
    			path88 = svg_element("path");
    			path89 = svg_element("path");
    			path90 = svg_element("path");
    			path91 = svg_element("path");
    			path92 = svg_element("path");
    			path93 = svg_element("path");
    			path94 = svg_element("path");
    			path95 = svg_element("path");
    			path96 = svg_element("path");
    			path97 = svg_element("path");
    			path98 = svg_element("path");
    			path99 = svg_element("path");
    			path100 = svg_element("path");
    			path101 = svg_element("path");
    			path102 = svg_element("path");
    			path103 = svg_element("path");
    			path104 = svg_element("path");
    			path105 = svg_element("path");
    			path106 = svg_element("path");
    			path107 = svg_element("path");
    			path108 = svg_element("path");
    			path109 = svg_element("path");
    			path110 = svg_element("path");
    			path111 = svg_element("path");
    			path112 = svg_element("path");
    			path113 = svg_element("path");
    			path114 = svg_element("path");
    			path115 = svg_element("path");
    			path116 = svg_element("path");
    			path117 = svg_element("path");
    			path118 = svg_element("path");
    			path119 = svg_element("path");
    			path120 = svg_element("path");
    			path121 = svg_element("path");
    			path122 = svg_element("path");
    			path123 = svg_element("path");
    			path124 = svg_element("path");
    			path125 = svg_element("path");
    			path126 = svg_element("path");
    			path127 = svg_element("path");
    			path128 = svg_element("path");
    			path129 = svg_element("path");
    			path130 = svg_element("path");
    			path131 = svg_element("path");
    			path132 = svg_element("path");
    			path133 = svg_element("path");
    			path134 = svg_element("path");
    			path135 = svg_element("path");
    			path136 = svg_element("path");
    			path137 = svg_element("path");
    			path138 = svg_element("path");
    			attr(path0, "d", "M1543.70108,477.111984 C1543.70108,458.099309 1528.29658,442.686194 1509.28532,442.686194 C1490.27405,442.686194 1474.86955,458.099309 1474.86955,477.111984 C1474.86955,496.12466 1490.27405,511.537775 1509.28532,511.537775 C1528.29658,511.537775 1543.70108,496.12466 1543.70108,477.111984 Z M1509.28532,401.375246 C1551.10735,401.375246 1585,435.283272 1585,477.111984 C1585,518.940697 1551.10735,552.848723 1509.28532,552.848723 C1467.46328,552.848723 1433.57063,518.940697 1433.57063,477.111984 C1433.57063,435.283272 1467.46328,401.375246 1509.28532,401.375246 Z");
    			attr(path0, "fill", path0_fill_value = ctx.colors[0]);
    			add_location(path0, file, 14, 8, 560);
    			attr(path1, "d", "M1507.81227,497.445972 C1496.42855,497.445972 1487.18959,488.209823 1487.18959,476.817289 C1487.18959,465.424754 1496.42855,456.188605 1507.81227,456.188605 C1519.19599,456.188605 1528.43494,465.424754 1528.43494,476.817289 C1528.43494,488.209823 1519.19599,497.445972 1507.81227,497.445972 Z");
    			attr(path1, "fill", path1_fill_value = ctx.colors[1]);
    			add_location(path1, file, 15, 8, 1171);
    			attr(path2, "d", "M243.347584,1178.78193 C243.347584,1167.38939 252.581043,1158.15324 263.97026,1158.15324 L387.70632,1158.15324 C399.095537,1158.15324 408.328996,1167.38939 408.328996,1178.78193 C408.328996,1190.17446 399.095537,1199.41061 387.70632,1199.41061 L263.97026,1199.41061 C252.581043,1199.41061 243.347584,1190.17446 243.347584,1178.78193 Z");
    			attr(path2, "fill", path2_fill_value = ctx.colors[2]);
    			add_location(path2, file, 16, 8, 1509);
    			attr(path3, "d", "M449.574349,663.948919 C449.574349,705.777632 415.720164,739.685658 373.957869,739.685658 L236.473358,739.685658 C194.711063,739.685658 160.856877,705.777632 160.856877,663.948919 C160.856877,622.120207 194.711063,588.212181 236.473358,588.212181 L373.957869,588.212181 C415.720164,588.212181 449.574349,622.120207 449.574349,663.948919 Z M373.957869,698.37471 C392.940355,698.37471 408.328996,682.961595 408.328996,663.948919 C408.328996,644.936244 392.940355,629.523129 373.957869,629.523129 L236.473358,629.523129 C217.490872,629.523129 202.10223,644.936244 202.10223,663.948919 C202.10223,682.961595 217.490872,698.37471 236.473358,698.37471 L373.957869,698.37471 Z");
    			attr(path3, "fill", path3_fill_value = ctx.colors[3]);
    			add_location(path3, file, 17, 8, 1889);
    			attr(path4, "d", "M83.0799257,1090.37328 C83.0799257,1101.76582 92.3156925,1111.00196 103.708677,1111.00196 L167.657805,1111.00196 C189.331746,1111.00196 208.8768,1101.88546 222.667807,1087.2776 C236.458815,1101.88546 256.003869,1111.00196 277.67781,1111.00196 L340.939313,1111.00196 C382.713909,1111.00196 416.578067,1077.13792 416.578067,1035.36346 C416.578067,1023.97092 407.341887,1014.73477 395.949316,1014.73477 C384.556744,1014.73477 375.320565,1023.97092 375.320565,1035.36346 C375.320565,1054.35147 359.927391,1069.7446 340.939313,1069.7446 L277.67781,1069.7446 C258.689732,1069.7446 243.296558,1054.35147 243.296558,1035.36346 L243.296558,896.463654 C243.296558,855.449705 210.047138,822.200393 169.033055,822.200393 L169.033055,863.45776 C187.261994,863.45776 202.039056,878.234774 202.039056,896.463654 L202.039056,1035.36346 C202.039056,1054.35147 186.645882,1069.7446 167.657805,1069.7446 L103.708677,1069.7446 C92.3156925,1069.7446 83.0799257,1078.98075 83.0799257,1090.37328 Z");
    			attr(path4, "fill", path4_fill_value = ctx.colors[3]);
    			add_location(path4, file, 18, 8, 2604);
    			attr(path5, "d", "M350.880112,924.111448 C369.88725,924.111448 385.295877,908.698334 385.295877,889.685658 C385.295877,870.672983 369.88725,855.259868 350.880112,855.259868 C331.872973,855.259868 316.464346,870.672983 316.464346,889.685658 C316.464346,901.092988 307.218895,910.341132 295.814887,910.341132 C284.410879,910.341132 275.165428,901.092988 275.165428,889.685658 C275.165428,847.856946 309.06358,813.948919 350.880112,813.948919 C392.696643,813.948919 426.594796,847.856946 426.594796,889.685658 C426.594796,931.51437 392.696643,965.422397 350.880112,965.422397 C339.476103,965.422397 330.230652,956.174253 330.230652,944.766923 C330.230652,933.359593 339.476103,924.111448 350.880112,924.111448 Z");
    			attr(path5, "fill", path5_fill_value = ctx.colors[4]);
    			attr(path5, "fill-rule", "nonzero");
    			add_location(path5, file, 19, 8, 3624);
    			attr(path6, "d", "M302.33106,643.614931 C327.715757,643.614931 348.126333,623.204912 348.126333,598.231827 C348.126333,573.258743 327.715757,552.848723 302.33106,552.848723 C288.307317,552.848723 275.794142,559.067583 267.374383,568.911591 C259.962129,577.578389 246.912812,578.608448 238.228428,571.212377 C229.542667,563.816306 228.510354,550.795481 235.922608,542.130059 C251.888312,523.462475 275.736255,511.591356 302.33106,511.591356 C350.367375,511.591356 389.473978,550.289391 389.473978,598.231827 C389.473978,646.174263 350.367375,684.872299 302.33106,684.872299 C290.913597,684.872299 281.657238,675.636149 281.657238,664.243615 C281.657238,652.851081 290.913597,643.614931 302.33106,643.614931 Z");
    			attr(path6, "fill", path6_fill_value = ctx.colors[4]);
    			attr(path6, "fill-rule", "nonzero");
    			add_location(path6, file, 20, 8, 4380);
    			attr(path7, "d", "M630.34758,112.772855 C643.787686,99.3654632 643.787686,77.6276665 630.34758,64.2202749 C616.907474,50.8128833 595.116689,50.8128833 581.676583,64.2202749 C568.236478,77.6276665 568.236478,99.3654632 581.676583,112.772855 C589.740922,120.817207 589.740922,133.860407 581.676583,141.903661 C573.612245,149.948288 560.536948,149.948288 552.473985,141.903661 C522.905202,112.407976 522.905202,64.5851533 552.473985,35.0887819 C582.041392,5.59254781 629.981395,5.59253408 659.550178,35.0887819 C689.118962,64.5851533 689.118962,112.407976 659.550178,141.903661 C651.485839,149.948288 638.411919,149.948288 630.34758,141.903661 C622.283241,133.860407 622.283241,120.817207 630.34758,112.772855 Z");
    			attr(path7, "fill", path7_fill_value = ctx.colors[1]);
    			add_location(path7, file, 21, 8, 5135);
    			attr(path8, "d", "M553.42514,113.311148 C561.478983,105.255158 574.535887,105.255158 582.58973,113.311148 C590.643572,121.367139 590.643572,134.428298 582.58973,142.484426 C574.535887,150.540555 561.478983,150.540555 553.42514,142.484426 C545.371298,134.428298 545.371298,121.367139 553.42514,113.311148 Z");
    			attr(path8, "fill", path8_fill_value = ctx.colors[0]);
    			add_location(path8, file, 22, 8, 5871);
    			attr(path9, "d", "M169.105948,863.45776 C157.716731,863.45776 148.483271,854.221611 148.483271,842.829077 C148.483271,831.436542 157.716731,822.200393 169.105948,822.200393 C180.495165,822.200393 189.728625,831.436542 189.728625,842.829077 C189.728625,854.221611 180.495165,863.45776 169.105948,863.45776 Z");
    			attr(path9, "fill", path9_fill_value = ctx.colors[0]);
    			add_location(path9, file, 23, 8, 6204);
    			attr(path10, "d", "M110.130453,929.764244 C110.130453,910.751568 94.7219639,895.338453 75.7146873,895.338453 C56.7074107,895.338453 41.2989219,910.751568 41.2989219,929.764244 C41.2989219,948.776919 56.7074107,964.190034 75.7146873,964.190034 C94.7219639,964.190034 110.130453,948.776919 110.130453,929.764244 Z M75.7146873,854.027505 C117.530806,854.027505 151.429371,887.935531 151.429371,929.764244 C151.429371,971.592956 117.530806,1005.50098 75.7146873,1005.50098 C33.8985686,1005.50098 0,971.592956 0,929.764244 C0,887.935531 33.8985686,854.027505 75.7146873,854.027505 Z");
    			attr(path10, "fill", path10_fill_value = ctx.colors[2]);
    			add_location(path10, file, 24, 8, 6538);
    			attr(path11, "d", "M139.055762,752.106853 C115.572439,752.106853 96.5353769,771.214235 96.5353769,794.784916 L96.5353769,874.634196 C96.5353769,886.038876 87.3239527,895.284872 75.960997,895.284872 C64.5980413,895.284872 55.3866171,886.038876 55.3866171,874.634196 L55.3866171,794.784916 C55.3866171,748.404875 92.8465278,710.805501 139.055762,710.805501 L139.055762,752.106853 Z");
    			attr(path11, "fill", path11_fill_value = ctx.colors[4]);
    			attr(path11, "fill-rule", "nonzero");
    			add_location(path11, file, 25, 8, 7142);
    			attr(path12, "d", "M76.0092937,895.284872 C64.6196644,895.284872 55.3866171,886.048723 55.3866171,874.656189 C55.3866171,863.263654 64.6196644,854.027505 76.0092937,854.027505 C87.398923,854.027505 96.6319703,863.263654 96.6319703,874.656189 C96.6319703,886.048723 87.398923,895.284872 76.0092937,895.284872 Z");
    			attr(path12, "fill", path12_fill_value = ctx.colors[0]);
    			add_location(path12, file, 26, 8, 7568);
    			attr(path13, "d", "M75.4200743,950.098232 C64.030445,950.098232 54.7973978,940.862083 54.7973978,929.469548 C54.7973978,918.077014 64.030445,908.840864 75.4200743,908.840864 C86.8097037,908.840864 96.0427509,918.077014 96.0427509,929.469548 C96.0427509,940.862083 86.8097037,950.098232 75.4200743,950.098232 Z");
    			attr(path13, "fill", path13_fill_value = ctx.colors[0]);
    			add_location(path13, file, 27, 8, 7904);
    			attr(path14, "d", "M79.5883583,538.061599 C98.6217786,537.813727 113.850583,522.2019 113.603118,503.190092 C113.355515,484.178283 97.7252529,468.965807 78.6919705,469.213679 C67.2719183,469.362403 57.8937608,460.235192 57.7452819,448.827556 C57.5966652,437.421298 66.7339753,428.0531 78.1540275,427.904377 C120.027414,427.360435 154.413578,460.825955 154.958139,502.653035 C155.502699,544.478738 121.99955,578.825582 80.1263012,579.369524 C68.706249,579.518248 59.3280916,570.391037 59.1794748,558.983401 C59.030996,547.577143 68.1683061,538.208945 79.5883583,538.061599 Z");
    			attr(path14, "fill", path14_fill_value = ctx.colors[2]);
    			add_location(path14, file, 28, 8, 8240);
    			attr(path15, "d", "M180.048593,686.081462 C161.030888,686.081462 145.613697,701.48592 145.613697,720.487918 C145.613697,739.489917 161.030888,754.894375 180.048593,754.894375 C255.359088,754.894375 316.410781,815.895647 316.410781,891.143945 C316.410781,902.544869 307.16019,911.787819 295.749843,911.787819 C284.339496,911.787819 275.088906,902.544869 275.088906,891.143945 C275.088906,838.697495 232.538393,796.182124 180.048593,796.182124 C138.208817,796.182124 104.291822,762.29314 104.291822,720.487918 C104.291822,678.682697 138.208817,644.793713 180.048593,644.793713 C191.45894,644.793713 200.70953,654.036664 200.70953,665.437587 C200.70953,676.838511 191.45894,686.081462 180.048593,686.081462 Z");
    			attr(path15, "fill", path15_fill_value = ctx.colors[2]);
    			add_location(path15, file, 29, 8, 8839);
    			attr(path16, "d", "M485.463163,1035.60202 C485.463163,1016.65276 470.054537,1001.29105 451.047398,1001.29105 C432.040259,1001.29105 416.631632,1016.65276 416.631632,1035.60202 C416.631632,1046.97131 407.386181,1056.18861 395.982173,1056.18861 C384.578165,1056.18861 375.332714,1046.97131 375.332714,1035.60202 C375.332714,993.912815 409.230866,960.117878 451.047398,960.117878 C492.863929,960.117878 526.762082,993.912815 526.762082,1035.60202 C526.762082,1046.97131 517.516631,1056.18861 506.112623,1056.18861 C494.708614,1056.18861 485.463163,1046.97131 485.463163,1035.60202 Z");
    			attr(path16, "fill", path16_fill_value = ctx.colors[1]);
    			add_location(path16, file, 30, 8, 9571);
    			attr(path17, "d", "M449.574349,668.369352 C449.574349,720.77721 492.046064,763.261297 544.438662,763.261297 C555.827879,763.261297 565.061338,772.497446 565.061338,783.88998 C565.061338,795.282515 555.827879,804.518664 544.438662,804.518664 C469.267631,804.518664 408.328996,743.562279 408.328996,668.369352 C408.328996,656.976817 417.562456,647.740668 428.951673,647.740668 C440.34089,647.740668 449.574349,656.976817 449.574349,668.369352 Z");
    			attr(path17, "fill", path17_fill_value = ctx.colors[4]);
    			attr(path17, "fill-rule", "nonzero");
    			add_location(path17, file, 31, 8, 10177);
    			attr(path18, "d", "M869.647097,51.3583091 C793.567535,51.3583091 731.891681,113.05144 731.891681,189.153851 C731.891681,200.568834 722.640027,209.823183 711.228368,209.823183 C699.816709,209.823183 690.565056,200.568834 690.565056,189.153851 C690.565056,90.2207859 770.742841,10.0196464 869.647097,10.0196464 C881.058755,10.0196464 890.310409,19.2735816 890.310409,30.6889777 C890.310409,42.1043738 881.058755,51.3583091 869.647097,51.3583091 Z");
    			attr(path18, "fill", path18_fill_value = ctx.colors[2]);
    			add_location(path18, file, 32, 8, 10666);
    			attr(path19, "d", "M1066.44398,178.563951 C1066.44398,108.614584 1009.75506,51.909426 939.826337,51.909426 C928.425244,51.909426 919.182156,42.6640586 919.182156,31.2592316 C919.182156,19.8544047 928.425244,10.6090373 939.826337,10.6090373 C1032.55862,10.6090373 1107.73234,85.8050679 1107.73234,178.563951 C1107.73234,189.968365 1098.48925,199.214145 1087.08816,199.214145 C1075.68707,199.214145 1066.44398,189.968365 1066.44398,178.563951 Z");
    			attr(path19, "fill", path19_fill_value = ctx.colors[3]);
    			add_location(path19, file, 33, 8, 11137);
    			attr(path20, "d", "M422.47026,570.530452 C422.47026,515.843811 378.152128,471.51277 323.481413,471.51277 C312.092196,471.51277 302.858736,462.276621 302.858736,450.884086 C302.858736,439.491552 312.092196,430.255403 323.481413,430.255403 C400.930562,430.255403 463.715613,493.058743 463.715613,570.530452 C463.715613,581.922986 454.482154,591.159136 443.092937,591.159136 C431.70372,591.159136 422.47026,581.922986 422.47026,570.530452 Z");
    			attr(path20, "fill", path20_fill_value = ctx.colors[2]);
    			add_location(path20, file, 34, 8, 11606);
    			attr(path21, "d", "M58.9237124,559.011497 C58.775642,547.618811 67.8878136,538.262892 79.2764469,538.115739 C90.6650803,537.96721 100.017437,547.082459 100.165507,558.473769 C100.313577,569.866454 91.2014058,579.220998 79.8127724,579.369527 C68.4242765,579.518055 59.0719203,570.402807 58.9237124,559.011497 Z");
    			attr(path21, "fill", path21_fill_value = ctx.colors[0]);
    			add_location(path21, file, 35, 8, 12070);
    			attr(path22, "d", "M295.788104,911.787819 C284.398887,911.787819 275.165428,902.55167 275.165428,891.159136 C275.165428,879.766601 284.398887,870.530452 295.788104,870.530452 C307.177321,870.530452 316.410781,879.766601 316.410781,891.159136 C316.410781,902.55167 307.177321,911.787819 295.788104,911.787819 Z");
    			attr(path22, "fill", path22_fill_value = ctx.colors[0]);
    			add_location(path22, file, 36, 8, 12406);
    			attr(path23, "d", "M395.95539,1056.18861 C384.566173,1056.18861 375.332714,1046.95246 375.332714,1035.55992 C375.332714,1024.16739 384.566173,1014.93124 395.95539,1014.93124 C407.344607,1014.93124 416.578067,1024.16739 416.578067,1035.55992 C416.578067,1046.95246 407.344607,1056.18861 395.95539,1056.18861 Z");
    			attr(path23, "fill", path23_fill_value = ctx.colors[0]);
    			add_location(path23, file, 37, 8, 12742);
    			attr(path24, "d", "M103.113383,1111.00196 C91.7237536,1111.00196 82.4907063,1101.76582 82.4907063,1090.37328 C82.4907063,1078.98075 91.7237536,1069.7446 103.113383,1069.7446 C114.503012,1069.7446 123.736059,1078.98075 123.736059,1090.37328 C123.736059,1101.76582 114.503012,1111.00196 103.113383,1111.00196 Z");
    			attr(path24, "fill", path24_fill_value = ctx.colors[0]);
    			add_location(path24, file, 38, 8, 13077);
    			attr(path25, "d", "M295.788104,966.601179 C284.398887,966.601179 275.165428,957.365029 275.165428,945.972495 C275.165428,934.579961 284.398887,925.343811 295.788104,925.343811 C307.177321,925.343811 316.410781,934.579961 316.410781,945.972495 C316.410781,957.365029 307.177321,966.601179 295.788104,966.601179 Z");
    			attr(path25, "fill", path25_fill_value = ctx.colors[1]);
    			add_location(path25, file, 39, 8, 13412);
    			attr(path26, "d", "M295.788104,1022.00393 C284.398887,1022.00393 275.165428,1012.76778 275.165428,1001.37525 C275.165428,989.982711 284.398887,980.746562 295.788104,980.746562 C307.177321,980.746562 316.410781,989.982711 316.410781,1001.37525 C316.410781,1012.76778 307.177321,1022.00393 295.788104,1022.00393 Z");
    			attr(path26, "fill", path26_fill_value = ctx.colors[1]);
    			add_location(path26, file, 40, 8, 13750);
    			attr(path27, "d", "M451.342007,1063.2613 C439.952791,1063.2613 430.719331,1054.02515 430.719331,1042.63261 C430.719331,1031.24008 439.952791,1022.00393 451.342007,1022.00393 C462.731224,1022.00393 471.964684,1031.24008 471.964684,1042.63261 C471.964684,1054.02515 462.731224,1063.2613 451.342007,1063.2613 Z");
    			attr(path27, "fill", path27_fill_value = ctx.colors[0]);
    			add_location(path27, file, 41, 8, 14088);
    			attr(path28, "d", "M451.342007,1118.07466 C439.952791,1118.07466 430.719331,1108.83851 430.719331,1097.44597 C430.719331,1086.05344 439.952791,1076.81729 451.342007,1076.81729 C462.731224,1076.81729 471.964684,1086.05344 471.964684,1097.44597 C471.964684,1108.83851 462.731224,1118.07466 451.342007,1118.07466 Z");
    			attr(path28, "fill", path28_fill_value = ctx.colors[0]);
    			add_location(path28, file, 42, 8, 14422);
    			attr(path29, "d", "M428.951673,688.998035 C417.562456,688.998035 408.328996,679.761886 408.328996,668.369352 C408.328996,656.976817 417.562456,647.740668 428.951673,647.740668 C440.34089,647.740668 449.574349,656.976817 449.574349,668.369352 C449.574349,679.761886 440.34089,688.998035 428.951673,688.998035 Z");
    			attr(path29, "fill", path29_fill_value = ctx.colors[0]);
    			add_location(path29, file, 43, 8, 14760);
    			attr(path30, "d", "M181.479554,686.051081 C170.090337,686.051081 160.856877,676.814931 160.856877,665.422397 C160.856877,654.029862 170.090337,644.793713 181.479554,644.793713 C192.868771,644.793713 202.10223,654.029862 202.10223,665.422397 C202.10223,676.814931 192.868771,686.051081 181.479554,686.051081 Z");
    			attr(path30, "fill", path30_fill_value = ctx.colors[0]);
    			add_location(path30, file, 44, 8, 15096);
    			attr(path31, "d", "M577.970598,661.591356 C577.970598,642.57868 562.561972,627.165565 543.554833,627.165565 C524.546317,627.165565 509.139067,642.57868 509.139067,661.591356 C509.139067,680.604031 524.546317,696.017146 543.554833,696.017146 C562.561972,696.017146 577.970598,680.604031 577.970598,661.591356 Z M543.554833,585.854617 C585.369988,585.854617 619.269517,619.762643 619.269517,661.591356 C619.269517,703.420068 585.369988,737.328094 543.554833,737.328094 C501.738301,737.328094 467.840149,703.420068 467.840149,661.591356 C467.840149,619.762643 501.738301,585.854617 543.554833,585.854617 Z");
    			attr(path31, "fill", path31_fill_value = ctx.colors[2]);
    			add_location(path31, file, 45, 8, 15431);
    			attr(path32, "d", "M635.767658,248.722986 C635.767658,260.115521 645.013201,269.35167 656.420397,269.35167 C675.430554,269.35167 690.841628,284.744794 690.841628,303.732809 L690.841628,441.257367 C690.841628,460.245383 675.430554,475.638507 656.420397,475.638507 C645.013201,475.638507 635.767658,484.874656 635.767658,496.267191 C635.767658,507.659725 645.013201,516.895874 656.420397,516.895874 C678.119541,516.895874 697.687323,507.779371 711.494367,493.171513 C725.300034,507.779371 744.869193,516.895874 766.568337,516.895874 L829.903403,516.895874 C871.726576,516.895874 905.630112,483.031827 905.630112,441.257367 C905.630112,429.864833 896.383192,420.628684 884.977373,420.628684 C873.571554,420.628684 864.324634,429.864833 864.324634,441.257367 C864.324634,460.245383 848.91356,475.638507 829.903403,475.638507 L766.568337,475.638507 C747.558179,475.638507 732.147106,460.245383 732.147106,441.257367 L732.147106,303.732809 C732.147106,261.95835 698.242193,228.094303 656.420397,228.094303 C645.013201,228.094303 635.767658,237.330452 635.767658,248.722986 Z");
    			attr(path32, "fill", path32_fill_value = ctx.colors[3]);
    			add_location(path32, file, 46, 8, 16060);
    			attr(path33, "d", "M677.013011,496.399295 C677.013011,485.001149 667.767878,475.76045 656.364263,475.76045 C637.357778,475.76045 621.949683,460.359743 621.949683,441.362374 L621.949683,303.77007 C621.949683,284.7727 637.357778,269.371994 656.364263,269.371994 C667.767878,269.371994 677.013011,260.131295 677.013011,248.733148 C677.013011,237.335002 667.767878,228.094303 656.364263,228.094303 C614.549171,228.094303 580.652186,261.975032 580.652186,303.77007 L580.652186,441.362374 C580.652186,443.056135 580.707249,444.736137 580.817376,446.401004 C546.450976,456.917184 521.459108,488.875748 521.459108,526.669602 L521.459108,606.473139 C521.459108,617.871285 530.704241,627.111984 542.107856,627.111984 C553.511471,627.111984 562.756604,617.871285 562.756604,606.473139 L562.756604,526.669602 C562.756604,506.797146 576.354493,490.097568 594.756658,485.361641 C608.492205,504.539256 630.967679,517.038141 656.364263,517.038141 C667.767878,517.038141 677.013011,507.797442 677.013011,496.399295 Z");
    			attr(path33, "fill", path33_fill_value = ctx.colors[4]);
    			attr(path33, "fill-rule", "nonzero");
    			add_location(path33, file, 47, 8, 17155);
    			attr(path34, "d", "M656.095725,516.949455 C637.087209,516.949455 621.679959,532.36257 621.679959,551.375246 C621.679959,570.387921 637.087209,585.801036 656.095725,585.801036 C675.102864,585.801036 690.51149,570.387921 690.51149,551.375246 C690.51149,539.967916 699.755565,530.719771 711.16095,530.719771 C722.564958,530.719771 731.810409,539.967916 731.810409,551.375246 C731.810409,593.203958 697.91088,627.111984 656.095725,627.111984 C614.279193,627.111984 580.381041,593.203958 580.381041,551.375246 C580.381041,509.546533 614.279193,475.638507 656.095725,475.638507 C667.499733,475.638507 676.745184,484.886651 676.745184,496.293981 C676.745184,507.701311 667.499733,516.949455 656.095725,516.949455 Z");
    			attr(path34, "fill", path34_fill_value = ctx.colors[1]);
    			add_location(path34, file, 48, 8, 18201);
    			attr(path35, "d", "M1153.1558,655.697446 C1153.1558,636.68477 1168.56442,621.271656 1187.57156,621.271656 C1206.5787,621.271656 1221.98733,636.68477 1221.98733,655.697446 C1221.98733,674.710121 1206.5787,690.123236 1187.57156,690.123236 C1176.16755,690.123236 1166.9221,699.371381 1166.9221,710.77871 C1166.9221,722.18604 1176.16755,731.434185 1187.57156,731.434185 C1229.38809,731.434185 1263.28625,697.526158 1263.28625,655.697446 C1263.28625,613.868734 1229.38809,579.960707 1187.57156,579.960707 C1145.75503,579.960707 1111.85688,613.868734 1111.85688,655.697446 C1111.85688,667.104776 1121.10233,676.35292 1132.50634,676.35292 C1143.91034,676.35292 1153.1558,667.104776 1153.1558,655.697446 Z");
    			attr(path35, "fill", path35_fill_value = ctx.colors[4]);
    			attr(path35, "fill-rule", "nonzero");
    			add_location(path35, file, 49, 8, 18935);
    			attr(path36, "d", "M656.390335,516.895874 C644.999743,516.895874 635.767658,507.659725 635.767658,496.267191 C635.767658,484.874656 644.999743,475.638507 656.390335,475.638507 C667.779551,475.638507 677.013011,484.874656 677.013011,496.267191 C677.013011,507.659725 667.779551,516.895874 656.390335,516.895874 Z");
    			attr(path36, "fill", path36_fill_value = ctx.colors[0]);
    			add_location(path36, file, 50, 8, 19679);
    			attr(path37, "d", "M656.390335,269.35167 C644.999743,269.35167 635.767658,260.115521 635.767658,248.722986 C635.767658,237.330452 644.999743,228.094303 656.390335,228.094303 C667.779551,228.094303 677.013011,237.330452 677.013011,248.722986 C677.013011,260.115521 667.779551,269.35167 656.390335,269.35167 Z");
    			attr(path37, "fill", path37_fill_value = ctx.colors[0]);
    			add_location(path37, file, 51, 8, 20017);
    			attr(path38, "d", "M542.081784,627.111984 C530.692568,627.111984 521.459108,617.875835 521.459108,606.483301 C521.459108,595.090766 530.692568,585.854617 542.081784,585.854617 C553.471001,585.854617 562.704461,595.090766 562.704461,606.483301 C562.704461,617.875835 553.471001,627.111984 542.081784,627.111984 Z");
    			attr(path38, "fill", path38_fill_value = ctx.colors[0]);
    			add_location(path38, file, 52, 8, 20351);
    			attr(path39, "d", "M543.260223,681.925344 C531.871006,681.925344 522.637546,672.689194 522.637546,661.29666 C522.637546,649.904126 531.871006,640.667976 543.260223,640.667976 C554.64944,640.667976 563.8829,649.904126 563.8829,661.29666 C563.8829,672.689194 554.64944,681.925344 543.260223,681.925344 Z");
    			attr(path39, "fill", path39_fill_value = ctx.colors[1]);
    			add_location(path39, file, 53, 8, 20689);
    			attr(path40, "d", "M1409.24004,478.33874 C1409.24004,520.140957 1375.337,554.027505 1333.51444,554.027505 L1195.83154,554.027505 C1154.00899,554.027505 1120.10595,520.140957 1120.10595,478.33874 C1120.10595,436.536523 1154.00899,402.649975 1195.83154,402.649975 L1239.89007,402.649975 L1239.89007,359.300955 C1239.89007,317.500114 1273.79311,283.61219 1315.61567,283.61219 L1453.29857,283.61219 C1472.31258,283.61219 1487.71929,268.208838 1487.71929,249.208206 L1487.71929,185.904875 C1487.71929,166.904243 1472.31258,151.500891 1453.29857,151.500891 C1441.89842,151.500891 1432.64613,142.258605 1432.64613,130.8585 C1432.64613,119.457983 1441.89842,110.21611 1453.29857,110.21611 C1495.12663,110.21611 1529.02416,144.102658 1529.02416,185.904875 L1529.02416,249.208206 C1529.02416,270.896477 1519.89579,290.45583 1505.27386,304.25458 C1519.89579,318.054706 1529.02416,337.612683 1529.02416,359.300955 L1529.02416,421.228126 C1529.02416,432.62823 1519.77187,441.870517 1508.37173,441.870517 C1496.97158,441.870517 1487.71929,432.62823 1487.71929,421.228126 L1487.71929,359.300955 C1487.71929,340.300323 1472.31258,324.896971 1453.29857,324.896971 L1315.61567,324.896971 C1296.60579,324.896971 1281.19494,340.300323 1281.19494,359.300955 L1281.19494,402.649975 L1333.51444,402.649975 C1375.337,402.649975 1409.24004,436.536523 1409.24004,478.33874 Z M1195.83154,443.934756 C1176.82167,443.934756 1161.41082,459.338108 1161.41082,478.33874 C1161.41082,497.339372 1176.82167,512.742724 1195.83154,512.742724 L1333.51444,512.742724 C1352.52432,512.742724 1367.93517,497.339372 1367.93517,478.33874 C1367.93517,459.338108 1352.52432,443.934756 1333.51444,443.934756 L1195.83154,443.934756 Z");
    			attr(path40, "fill", path40_fill_value = ctx.colors[3]);
    			add_location(path40, file, 54, 8, 21017);
    			attr(path41, "d", "M1100.16244,280.108858 C1123.64884,289.661191 1150.24748,278.455649 1159.68611,255.346453 C1169.12335,232.237256 1157.95096,205.6691 1134.46456,196.116768 C1121.48817,190.839691 1107.55883,191.885487 1096.04905,197.826321 C1085.91499,203.056673 1073.45225,199.098866 1068.21102,188.987218 C1062.96979,178.87557 1066.93583,166.43871 1077.06851,161.208358 C1098.89551,149.94235 1125.4487,147.930464 1150.05606,157.939044 C1194.50189,176.014405 1216.06173,226.542411 1197.94325,270.905582 C1179.82478,315.270128 1129.01539,336.363317 1084.56956,318.287956 C1074.00585,313.990712 1068.93124,301.960627 1073.23743,291.418842 C1077.54223,280.875684 1089.59735,275.812989 1100.16244,280.108858 Z");
    			attr(path41, "fill", path41_fill_value = ctx.colors[2]);
    			add_location(path41, file, 55, 8, 22729);
    			attr(path42, "d", "M1408.82342,482.711198 C1408.82342,535.119057 1451.29239,577.603143 1503.68773,577.603143 C1515.07145,577.603143 1524.31041,586.839293 1524.31041,598.231827 C1524.31041,609.624361 1515.07145,618.860511 1503.68773,618.860511 C1428.5112,618.860511 1367.57807,557.904126 1367.57807,482.711198 C1367.57807,471.318664 1376.81703,462.082515 1388.20074,462.082515 C1399.58446,462.082515 1408.82342,471.318664 1408.82342,482.711198 Z");
    			attr(path42, "fill", path42_fill_value = ctx.colors[2]);
    			add_location(path42, file, 56, 8, 23463);
    			attr(path43, "d", "M1388.20074,502.1611 C1376.81703,502.1611 1367.57807,492.924951 1367.57807,481.532417 C1367.57807,470.139882 1376.81703,460.903733 1388.20074,460.903733 C1399.58446,460.903733 1408.82342,470.139882 1408.82342,481.532417 C1408.82342,492.924951 1399.58446,502.1611 1388.20074,502.1611 Z");
    			attr(path43, "fill", path43_fill_value = ctx.colors[0]);
    			add_location(path43, file, 57, 8, 23934);
    			attr(path44, "d", "M635.714093,399.649172 C635.714093,380.699907 620.305466,365.338198 601.298327,365.338198 C582.289812,365.338198 566.882562,380.699907 566.882562,399.649172 C566.882562,411.018456 557.63711,420.235756 546.233102,420.235756 C534.827718,420.235756 525.583643,411.018456 525.583643,399.649172 C525.583643,357.959966 559.481795,324.165029 601.298327,324.165029 C643.113482,324.165029 677.013011,357.959966 677.013011,399.649172 C677.013011,411.018456 667.76756,420.235756 656.363552,420.235756 C644.958167,420.235756 635.714093,411.018456 635.714093,399.649172 Z");
    			attr(path44, "fill", path44_fill_value = ctx.colors[2]);
    			add_location(path44, file, 58, 8, 24264);
    			attr(path45, "d", "M974.515208,442.674712 C974.515208,423.725448 959.106581,408.363738 940.099442,408.363738 C921.092303,408.363738 905.683677,423.725448 905.683677,442.674712 C905.683677,454.043997 896.438226,463.261297 885.034218,463.261297 C873.63021,463.261297 864.384758,454.043997 864.384758,442.674712 C864.384758,400.985507 898.282911,367.19057 940.099442,367.19057 C981.915974,367.19057 1015.81413,400.985507 1015.81413,442.674712 C1015.81413,454.043997 1006.56868,463.261297 995.164667,463.261297 C983.760659,463.261297 974.515208,454.043997 974.515208,442.674712 Z");
    			attr(path45, "fill", path45_fill_value = ctx.colors[1]);
    			add_location(path45, file, 59, 8, 24868);
    			attr(path46, "d", "M455.466543,1156.97446 C507.85914,1156.97446 550.330855,1114.49037 550.330855,1062.08251 C550.330855,1050.68998 559.564315,1041.45383 570.953532,1041.45383 C582.342748,1041.45383 591.576208,1050.68998 591.576208,1062.08251 C591.576208,1137.27544 530.637574,1198.23183 455.466543,1198.23183 C444.077326,1198.23183 434.843866,1188.99568 434.843866,1177.60314 C434.843866,1166.21061 444.077326,1156.97446 455.466543,1156.97446 Z");
    			attr(path46, "fill", path46_fill_value = ctx.colors[4]);
    			attr(path46, "fill-rule", "nonzero");
    			add_location(path46, file, 60, 8, 25470);
    			attr(path47, "d", "M664.662974,669.500982 C725.477178,669.500982 774.776283,620.187517 774.776283,559.355599 C774.776283,547.950045 784.020295,538.70334 795.422528,538.70334 C806.824761,538.70334 816.068773,547.950045 816.068773,559.355599 C816.068773,642.998626 748.281644,710.805501 664.662974,710.805501 C653.260741,710.805501 644.016729,701.558796 644.016729,690.153242 C644.016729,678.747687 653.260741,669.500982 664.662974,669.500982 Z");
    			attr(path47, "fill", path47_fill_value = ctx.colors[3]);
    			add_location(path47, file, 61, 8, 25961);
    			attr(path48, "d", "M656.390335,420.235756 C644.999743,420.235756 635.767658,410.999607 635.767658,399.607073 C635.767658,388.214538 644.999743,378.978389 656.390335,378.978389 C667.779551,378.978389 677.013011,388.214538 677.013011,399.607073 C677.013011,410.999607 667.779551,420.235756 656.390335,420.235756 Z");
    			attr(path48, "fill", path48_fill_value = ctx.colors[0]);
    			add_location(path48, file, 62, 8, 26430);
    			attr(path49, "d", "M800.749071,289.980354 C789.359854,289.980354 780.126394,280.744204 780.126394,269.35167 C780.126394,257.959136 789.359854,248.722986 800.749071,248.722986 C812.138287,248.722986 821.371747,257.959136 821.371747,269.35167 C821.371747,280.744204 812.138287,289.980354 800.749071,289.980354 Z");
    			attr(path49, "fill", path49_fill_value = ctx.colors[0]);
    			add_location(path49, file, 63, 8, 26768);
    			attr(path50, "d", "M1114.21375,711.984283 C1114.21375,723.376817 1123.44721,732.612967 1134.83643,732.612967 C1146.22565,732.612967 1155.45911,723.376817 1155.45911,711.984283 C1155.45911,700.591749 1146.22565,691.355599 1134.83643,691.355599 C1123.44721,691.355599 1114.21375,700.591749 1114.21375,711.984283 Z");
    			attr(path50, "fill", path50_fill_value = ctx.colors[0]);
    			add_location(path50, file, 64, 8, 27104);
    			attr(path51, "d", "M1059.41636,711.984283 C1059.41636,723.376817 1068.64982,732.612967 1080.03903,732.612967 C1091.42825,732.612967 1100.66171,723.376817 1100.66171,711.984283 C1100.66171,700.591749 1091.42825,691.355599 1080.03903,691.355599 C1068.64982,691.355599 1059.41636,700.591749 1059.41636,711.984283 Z");
    			attr(path51, "fill", path51_fill_value = ctx.colors[0]);
    			add_location(path51, file, 65, 8, 27442);
    			attr(path52, "d", "M1463.91543,1198.23183 C1422.09339,1198.23183 1388.20074,1164.36778 1388.20074,1122.59332 L1388.20074,985.068762 C1388.20074,943.294303 1422.09339,909.430255 1463.91543,909.430255 C1505.73747,909.430255 1539.63011,943.294303 1539.63011,985.068762 L1539.63011,1122.59332 C1539.63011,1164.36778 1505.73747,1198.23183 1463.91543,1198.23183 Z M1498.33119,1122.59332 L1498.33119,985.068762 C1498.33119,966.080747 1482.9267,950.687623 1463.91543,950.687623 C1444.90416,950.687623 1429.49966,966.080747 1429.49966,985.068762 L1429.49966,1122.59332 C1429.49966,1141.58134 1444.90416,1156.97446 1463.91543,1156.97446 C1482.9267,1156.97446 1498.33119,1141.58134 1498.33119,1122.59332 Z");
    			attr(path52, "fill", path52_fill_value = ctx.colors[3]);
    			set_style(path52, "mix-blend-mode", "multiply");
    			add_location(path52, file, 66, 8, 27780);
    			attr(path53, "d", "M1484.95056,930.088409 C1484.95056,888.373627 1518.89595,854.557957 1560.78309,854.557957 C1572.19933,854.557957 1581.46468,845.335002 1581.46468,833.958743 C1581.46468,822.582483 1572.19933,813.359528 1560.78309,813.359528 C1496.06347,813.359528 1443.58736,865.621108 1443.58736,930.088409 C1443.58736,941.464668 1452.85272,950.687623 1464.26896,950.687623 C1475.6852,950.687623 1484.95056,941.464668 1484.95056,930.088409 Z");
    			attr(path53, "fill", path53_fill_value = ctx.colors[4]);
    			attr(path53, "fill-rule", "nonzero");
    			add_location(path53, file, 67, 8, 28535);
    			attr(path54, "d", "M1484.83271,930.058939 C1484.83271,918.665029 1475.59375,909.430255 1464.21004,909.430255 C1452.82632,909.430255 1443.58736,918.665029 1443.58736,930.058939 C1443.58736,941.451473 1452.82632,950.687623 1464.21004,950.687623 C1475.59375,950.687623 1484.83271,941.451473 1484.83271,930.058939 Z");
    			attr(path54, "fill", path54_fill_value = ctx.colors[0]);
    			add_location(path54, file, 68, 8, 29026);
    			attr(path55, "d", "M1279.48978,1088.0693 C1260.48264,1088.0693 1245.07401,1103.48241 1245.07401,1122.49509 C1245.07401,1141.50776 1260.48264,1156.92088 1279.48978,1156.92088 C1298.49692,1156.92088 1313.90554,1141.50776 1313.90554,1122.49509 C1313.90554,1103.48241 1298.49692,1088.0693 1279.48978,1088.0693 Z M1203.77509,1122.49509 C1203.77509,1080.66638 1237.67325,1046.75835 1279.48978,1046.75835 C1321.30631,1046.75835 1355.20446,1080.66638 1355.20446,1122.49509 C1355.20446,1164.3238 1321.30631,1198.23183 1279.48978,1198.23183 C1237.67325,1198.23183 1203.77509,1164.3238 1203.77509,1122.49509 Z");
    			attr(path55, "fill", path55_fill_value = ctx.colors[2]);
    			add_location(path55, file, 69, 8, 29364);
    			attr(path56, "d", "M866.751795,988.998035 C878.146622,988.998035 887.38463,998.257746 887.38463,1009.67934 C887.38463,1028.7158 902.780852,1044.14819 921.772689,1044.14819 L1059.32493,1044.14819 C1078.31676,1044.14819 1093.71299,1028.7158 1093.71299,1009.67934 C1093.71299,998.257746 1102.95099,988.998035 1114.34582,988.998035 C1125.74065,988.998035 1134.97866,998.257746 1134.97866,1009.67934 C1134.97866,1035.0622 1122.53706,1057.53175 1103.4338,1071.29585 C1108.28114,1089.08591 1124.61272,1102.05585 1144.60731,1102.05585 L1224.38761,1102.05585 C1235.78244,1102.05585 1245.02045,1111.31556 1245.02045,1122.73716 C1245.02045,1134.15876 1235.78244,1143.41847 1224.38761,1143.41847 L1144.60731,1143.41847 C1107.28802,1143.41847 1075.23284,1119.44332 1064.51477,1085.3357 C1062.7995,1085.45152 1061.06909,1085.51081 1059.32493,1085.51081 L921.772689,1085.51081 C879.989822,1085.51081 846.118959,1051.56037 846.118959,1009.67934 C846.118959,998.257746 855.356967,988.998035 866.751795,988.998035 Z");
    			attr(path56, "fill", path56_fill_value = ctx.colors[4]);
    			attr(path56, "fill-rule", "nonzero");
    			add_location(path56, file, 70, 8, 29989);
    			attr(path57, "d", "M697.341078,742.632613 C739.15761,742.632613 773.055762,776.49666 773.055762,818.27112 L773.055762,955.795678 C773.055762,997.570138 739.15761,1031.43418 697.341078,1031.43418 C655.524546,1031.43418 621.626394,997.570138 621.626394,955.795678 L621.626394,818.27112 C621.626394,776.49666 655.524546,742.632613 697.341078,742.632613 Z M731.756844,818.27112 C731.756844,799.283104 716.348217,783.88998 697.341078,783.88998 C678.333939,783.88998 662.925313,799.283104 662.925313,818.27112 L662.925313,955.795678 C662.925313,974.783694 678.333939,990.176817 697.341078,990.176817 C716.348217,990.176817 731.756844,974.783694 731.756844,955.795678 L731.756844,818.27112 Z");
    			attr(path57, "fill", path57_fill_value = ctx.colors[3]);
    			add_location(path57, file, 71, 8, 31033);
    			attr(path58, "d", "M866.741636,1030.2554 C878.130853,1030.2554 887.364312,1021.00579 887.364312,1009.59665 C887.364312,990.580953 902.752954,975.16539 921.73544,975.16539 C921.73544,975.16539 921.73544,975.16539 921.73544,975.16539 L1059.21995,975.16539 C1078.20244,975.16539 1093.59108,990.580953 1093.59108,1009.59665 C1093.59108,1021.00579 1102.82454,1030.2554 1114.21375,1030.2554 C1125.60297,1030.2554 1134.83643,1021.00579 1134.83643,1009.59665 C1134.83643,987.891183 1125.72258,968.317702 1111.11898,954.506636 C1125.72258,940.69557 1134.83643,921.122088 1134.83643,899.416623 L1134.83643,836.063109 C1134.83643,794.227753 1100.98225,760.314342 1059.21995,760.314342 C1047.83073,760.314342 1038.59727,769.563955 1038.59727,780.973097 C1038.59727,792.382238 1047.83073,801.631851 1059.21995,801.631851 C1078.20244,801.631851 1093.59108,817.047414 1093.59108,836.063109 L1093.59108,899.416623 C1093.59108,918.432318 1078.20244,933.847881 1059.21995,933.847881 L921.736815,933.847881 C921.73544,933.847881 921.736815,933.847881 921.736815,933.847881 C879.97452,933.847881 846.118959,967.761293 846.118959,1009.59665 C846.118959,1021.00579 855.352419,1030.2554 866.741636,1030.2554 Z");
    			attr(path58, "fill", path58_fill_value = ctx.colors[3]);
    			add_location(path58, file, 72, 8, 31744);
    			attr(path59, "d", "M1134.89,1009.33202 C1134.89,1028.3447 1150.29862,1043.75781 1169.30576,1043.75781 C1188.3129,1043.75781 1203.72153,1028.3447 1203.72153,1009.33202 C1203.72153,990.319348 1188.3129,974.906233 1169.30576,974.906233 C1157.90175,974.906233 1148.6563,965.658089 1148.6563,954.250759 C1148.6563,942.843429 1157.90175,933.595285 1169.30576,933.595285 C1211.12229,933.595285 1245.02045,967.503311 1245.02045,1009.33202 C1245.02045,1051.16074 1211.12229,1085.06876 1169.30576,1085.06876 C1127.48923,1085.06876 1093.59108,1051.16074 1093.59108,1009.33202 C1093.59108,997.924694 1102.83653,988.676549 1114.24054,988.676549 C1125.64455,988.676549 1134.89,997.924694 1134.89,1009.33202 Z");
    			attr(path59, "fill", path59_fill_value = ctx.colors[1]);
    			add_location(path59, file, 73, 8, 32957);
    			attr(path60, "d", "M959.195505,840.176817 C959.195505,821.164142 943.786879,805.751027 924.77974,805.751027 C905.772601,805.751027 890.363974,821.164142 890.363974,840.176817 C890.363974,859.189493 905.772601,874.602608 924.77974,874.602608 C936.183748,874.602608 945.429199,883.850752 945.429199,895.258082 C945.429199,906.665412 936.183748,915.913556 924.77974,915.913556 C882.963208,915.913556 849.065056,882.00553 849.065056,840.176817 C849.065056,798.348105 882.963208,764.440079 924.77974,764.440079 C966.596271,764.440079 1000.49442,798.348105 1000.49442,840.176817 C1000.49442,851.584147 991.248973,860.832291 979.844965,860.832291 C968.440956,860.832291 959.195505,851.584147 959.195505,840.176817 Z");
    			attr(path60, "fill", path60_fill_value = ctx.colors[1]);
    			add_location(path60, file, 74, 8, 33678);
    			attr(path61, "d", "M677.013011,951.804843 C677.013011,926.412752 656.608935,905.996231 631.643123,905.996231 C606.67731,905.996231 586.273234,926.412752 586.273234,951.804843 C586.273234,965.832671 592.490284,978.349492 602.331425,986.771703 C610.995699,994.186116 612.025458,1007.23923 604.631541,1015.92615 C597.237624,1024.61444 584.22059,1025.64705 575.557691,1018.23264 C556.895544,1002.26228 545.027881,978.407395 545.027881,951.804843 C545.027881,903.754536 583.714647,864.636542 631.643123,864.636542 C679.571598,864.636542 718.258364,903.754536 718.258364,951.804843 C718.258364,963.225632 709.024905,972.484688 697.635688,972.484688 C686.246471,972.484688 677.013011,963.225632 677.013011,951.804843 Z");
    			attr(path61, "fill", path61_fill_value = ctx.colors[0]);
    			add_location(path61, file, 75, 8, 34413);
    			attr(path62, "d", "M1134.83643,1009.03733 C1134.83643,1020.42986 1125.60297,1029.66601 1114.21375,1029.66601 C1102.82454,1029.66601 1093.59108,1020.42986 1093.59108,1009.03733 C1093.59108,997.644794 1102.82454,988.408644 1114.21375,988.408644 C1125.60297,988.408644 1134.83643,997.644794 1134.83643,1009.03733 Z");
    			attr(path62, "fill", path62_fill_value = ctx.colors[0]);
    			add_location(path62, file, 76, 8, 35151);
    			attr(path63, "d", "M887.364312,1009.62672 C887.364312,1021.01925 878.130853,1030.2554 866.741636,1030.2554 C855.352419,1030.2554 846.118959,1021.01925 846.118959,1009.62672 C846.118959,998.234185 855.352419,988.998035 866.741636,988.998035 C878.130853,988.998035 887.364312,998.234185 887.364312,1009.62672 Z");
    			attr(path63, "fill", path63_fill_value = ctx.colors[0]);
    			add_location(path63, file, 77, 8, 35489);
    			attr(path64, "d", "M1245.02045,1122.78978 C1245.02045,1134.18232 1235.78699,1143.41847 1224.39777,1143.41847 C1213.00855,1143.41847 1203.77509,1134.18232 1203.77509,1122.78978 C1203.77509,1111.39725 1213.00855,1102.1611 1224.39777,1102.1611 C1235.78699,1102.1611 1245.02045,1111.39725 1245.02045,1122.78978 Z");
    			attr(path64, "fill", path64_fill_value = ctx.colors[0]);
    			add_location(path64, file, 78, 8, 35824);
    			attr(path65, "d", "M1300.40706,1122.20039 C1300.40706,1133.59293 1291.1736,1142.82908 1279.78439,1142.82908 C1268.39517,1142.82908 1259.16171,1133.59293 1259.16171,1122.20039 C1259.16171,1110.80786 1268.39517,1101.57171 1279.78439,1101.57171 C1291.1736,1101.57171 1300.40706,1110.80786 1300.40706,1122.20039 Z");
    			attr(path65, "fill", path65_fill_value = ctx.colors[0]);
    			add_location(path65, file, 79, 8, 36159);
    			attr(path66, "d", "M1018.21309,1030.30898 C999.269344,1030.30898 983.912108,1045.7221 983.912108,1064.73477 C983.912108,1083.74745 999.269344,1099.16056 1018.21309,1099.16056 C1029.57906,1099.16056 1038.79368,1108.40871 1038.79368,1119.81604 C1038.79368,1131.22337 1029.57906,1140.47151 1018.21309,1140.47151 C976.536025,1140.47151 942.750929,1106.56349 942.750929,1064.73477 C942.750929,1022.90606 976.536025,988.998035 1018.21309,988.998035 C1029.57906,988.998035 1038.79368,998.24618 1038.79368,1009.65351 C1038.79368,1021.06084 1029.57906,1030.30898 1018.21309,1030.30898 Z");
    			attr(path66, "fill", path66_fill_value = ctx.colors[2]);
    			add_location(path66, file, 80, 8, 36495);
    			attr(path67, "d", "M1060.55797,661.29666 C1034.31902,661.29666 1012.35246,683.075049 1012.35246,710.805501 C1012.35246,738.535953 1034.31902,760.314342 1060.55797,760.314342 C1071.96752,760.314342 1081.21747,769.550491 1081.21747,780.943026 C1081.21747,792.33556 1071.96752,801.571709 1060.55797,801.571709 C1010.73138,801.571709 971.033457,760.546758 971.033457,710.805501 C971.033457,661.064244 1010.73138,620.039293 1060.55797,620.039293 C1071.96752,620.039293 1081.21747,629.275442 1081.21747,640.667976 C1081.21747,652.060511 1071.96752,661.29666 1060.55797,661.29666 Z");
    			attr(path67, "fill", path67_fill_value = ctx.colors[2]);
    			add_location(path67, file, 81, 8, 37099);
    			attr(path68, "d", "M924.469944,915.9901 C872.038766,915.9901 829.535776,958.553007 829.535776,1011.0581 C829.535776,1052.91006 795.656661,1086.83694 753.863613,1086.83694 C712.070565,1086.83694 678.19145,1052.91006 678.19145,1011.0581 C678.19145,999.644426 687.431709,990.391141 698.829312,990.391141 C710.226916,990.391141 719.467175,999.644426 719.467175,1011.0581 C719.467175,1030.08134 734.867148,1045.50302 753.863613,1045.50302 C772.860077,1045.50302 788.260051,1030.08134 788.260051,1011.0581 C788.260051,935.725665 849.243559,874.656189 924.469944,874.656189 C935.867548,874.656189 945.107807,883.909474 945.107807,895.323144 C945.107807,906.736815 935.867548,915.9901 924.469944,915.9901 Z");
    			attr(path68, "fill", path68_fill_value = ctx.colors[2]);
    			add_location(path68, file, 82, 8, 37700);
    			attr(path69, "d", "M701.760223,742.632613 C788.320471,742.632613 858.492565,672.440079 858.492565,585.854617 C858.492565,574.462083 867.726025,565.225933 879.115242,565.225933 C890.504458,565.225933 899.737918,574.462083 899.737918,585.854617 C899.737918,695.226523 811.100279,783.88998 701.760223,783.88998 C690.371006,783.88998 681.137546,774.653831 681.137546,763.261297 C681.137546,751.868762 690.371006,742.632613 701.760223,742.632613 Z");
    			attr(path69, "fill", path69_fill_value = ctx.colors[4]);
    			attr(path69, "fill-rule", "nonzero");
    			add_location(path69, file, 83, 8, 38425);
    			attr(path70, "d", "M1309.79308,50.1812446 C1235.99168,50.1812446 1176.16477,110.02613 1176.16477,183.848474 C1176.16477,195.263931 1166.91273,204.518664 1155.5006,204.518664 C1144.08847,204.518664 1134.83643,195.263931 1134.83643,183.848474 C1134.83643,87.1943894 1213.16742,8.84086444 1309.79308,8.84086444 C1321.20521,8.84086444 1330.45725,18.0951842 1330.45725,29.5110545 C1330.45725,40.9269249 1321.20521,50.1812446 1309.79308,50.1812446 Z");
    			attr(path70, "fill", path70_fill_value = ctx.colors[4]);
    			attr(path70, "fill-rule", "nonzero");
    			add_location(path70, file, 84, 8, 38914);
    			attr(path71, "d", "M1273.89219,994.302554 C1273.89219,941.894695 1231.42048,899.410609 1179.02788,899.410609 C1167.63866,899.410609 1158.4052,890.17446 1158.4052,878.781925 C1158.4052,867.389391 1167.63866,858.153242 1179.02788,858.153242 C1254.19891,858.153242 1315.13755,919.109627 1315.13755,994.302554 C1315.13755,1005.69509 1305.90409,1014.93124 1294.51487,1014.93124 C1283.12565,1014.93124 1273.89219,1005.69509 1273.89219,994.302554 Z");
    			attr(path71, "fill", path71_fill_value = ctx.colors[0]);
    			add_location(path71, file, 85, 8, 39404);
    			attr(path72, "d", "M42.4237509,1062.08251 C42.4237509,1114.49037 84.8957923,1156.97446 137.287871,1156.97446 C148.67734,1156.97446 157.910781,1166.21061 157.910781,1177.60314 C157.910781,1188.99568 148.67734,1198.23183 137.287871,1198.23183 C62.1167173,1198.23183 1.17843866,1137.27544 1.17843866,1062.08251 C1.17843866,1050.68998 10.4115098,1041.45383 21.8011161,1041.45383 C33.1905848,1041.45383 42.4237509,1050.68998 42.4237509,1062.08251 Z");
    			attr(path72, "fill", path72_fill_value = ctx.colors[3]);
    			add_location(path72, file, 86, 8, 39872);
    			attr(path73, "d", "M586.305609,852.783955 C551.432501,852.783955 523.162016,881.062674 523.162016,915.94594 C523.162016,927.32059 513.943052,936.54224 502.571715,936.54224 C491.200377,936.54224 481.981413,927.32059 481.981413,915.94594 C481.981413,858.312002 528.688453,811.591356 586.305609,811.591356 C597.676946,811.591356 606.895911,820.813005 606.895911,832.187655 C606.895911,843.562305 597.676946,852.783955 586.305609,852.783955 Z");
    			attr(path73, "fill", path73_fill_value = ctx.colors[2]);
    			add_location(path73, file, 87, 8, 40342);
    			attr(path74, "d", "M1038.79368,1009.62672 C1038.79368,1021.01925 1029.56022,1030.2554 1018.171,1030.2554 C1006.78179,1030.2554 997.548327,1021.01925 997.548327,1009.62672 C997.548327,998.234185 1006.78179,988.998035 1018.171,988.998035 C1029.56022,988.998035 1038.79368,998.234185 1038.79368,1009.62672 Z");
    			attr(path74, "fill", path74_fill_value = ctx.colors[0]);
    			add_location(path74, file, 88, 8, 40807);
    			attr(path75, "d", "M945.697026,895.284872 C945.697026,906.677407 936.463566,915.913556 925.074349,915.913556 C913.685133,915.913556 904.451673,906.677407 904.451673,895.284872 C904.451673,883.892338 913.685133,874.656189 925.074349,874.656189 C936.463566,874.656189 945.697026,883.892338 945.697026,895.284872 Z");
    			attr(path75, "fill", path75_fill_value = ctx.colors[0]);
    			add_location(path75, file, 89, 8, 41138);
    			attr(path76, "d", "M945.107807,726.129666 C945.107807,737.5222 935.874347,746.75835 924.48513,746.75835 C913.095913,746.75835 903.862454,737.5222 903.862454,726.129666 C903.862454,714.737132 913.095913,705.500982 924.48513,705.500982 C935.874347,705.500982 945.107807,714.737132 945.107807,726.129666 Z");
    			attr(path76, "fill", path76_fill_value = ctx.colors[0]);
    			add_location(path76, file, 90, 8, 41476);
    			attr(path77, "d", "M945.107807,670.726916 C945.107807,682.11945 935.874347,691.355599 924.48513,691.355599 C913.095913,691.355599 903.862454,682.11945 903.862454,670.726916 C903.862454,659.334381 913.095913,650.098232 924.48513,650.098232 C935.874347,650.098232 945.107807,659.334381 945.107807,670.726916 Z");
    			attr(path77, "fill", path77_fill_value = ctx.colors[0]);
    			add_location(path77, file, 91, 8, 41805);
    			attr(path78, "d", "M905.630112,443.222004 C905.630112,454.614538 896.396652,463.850688 885.007435,463.850688 C873.618218,463.850688 864.384758,454.614538 864.384758,443.222004 C864.384758,431.82947 873.618218,422.59332 885.007435,422.59332 C896.396652,422.59332 905.630112,431.82947 905.630112,443.222004 Z");
    			attr(path78, "fill", path78_fill_value = ctx.colors[0]);
    			add_location(path78, file, 92, 8, 42139);
    			attr(path79, "d", "M1081.21747,780.943026 C1081.21747,792.33556 1071.98401,801.571709 1060.5948,801.571709 C1049.20558,801.571709 1039.97212,792.33556 1039.97212,780.943026 C1039.97212,769.550491 1049.20558,760.314342 1060.5948,760.314342 C1071.98401,760.314342 1081.21747,769.550491 1081.21747,780.943026 Z");
    			attr(path79, "fill", path79_fill_value = ctx.colors[0]);
    			add_location(path79, file, 93, 8, 42472);
    			attr(path80, "d", "M433.370818,123.12913 C414.363679,123.12913 398.955052,107.716153 398.955052,88.7033399 C398.955052,69.6905267 414.363679,54.2775496 433.370818,54.2775496 C452.377957,54.2775496 467.786583,69.6905267 467.786583,88.7033399 C467.786583,107.716153 452.377957,123.12913 433.370818,123.12913 Z M357.656134,88.7033399 C357.656134,130.531639 391.554286,164.440079 433.370818,164.440079 C475.18735,164.440079 509.085502,130.531639 509.085502,88.7033399 C509.085502,46.8751784 475.18735,12.9666012 433.370818,12.9666012 C391.554286,12.9666012 357.656134,46.8750407 357.656134,88.7033399 Z");
    			attr(path80, "fill", path80_fill_value = ctx.colors[2]);
    			add_location(path80, file, 94, 8, 42806);
    			attr(path81, "d", "M20.6226793,180.943026 C32.0123084,180.943026 41.2453556,190.18973 41.2453556,201.595285 C41.2453556,220.605001 56.6338593,236.015717 75.6164829,236.015717 L213.100992,236.015717 C232.083478,236.015717 247.472119,220.605001 247.472119,201.595285 C247.472119,190.18973 256.705579,180.943026 268.094796,180.943026 C279.484012,180.943026 288.717472,190.18973 288.717472,201.595285 C288.717472,243.417487 254.863287,277.320236 213.100992,277.320236 L78.3918827,277.320236 C78.3833587,277.320236 78.3746971,277.320236 78.3661731,277.320236 C59.3835494,277.320236 43.9950458,292.730952 43.9950458,311.740668 L43.9950458,449.422397 C43.9950458,468.432113 59.3835494,483.842829 78.3661731,483.842829 C89.7558023,483.842829 98.9888495,493.089534 98.9888495,504.495088 C98.9888495,515.900643 89.7558023,525.147348 78.3661731,525.147348 C36.6042911,525.147348 2.74967932,491.244599 2.74967932,449.422397 L2.74967932,311.740668 C2.74967932,290.713914 11.3077326,271.687676 25.1259844,257.966315 C9.70228469,244.103142 0,223.983711 0,201.595285 C0,190.18973 9.23309131,180.943026 20.6226793,180.943026 Z");
    			attr(path81, "fill", path81_fill_value = ctx.colors[3]);
    			add_location(path81, file, 95, 8, 43431);
    			attr(path82, "d", "M218.521983,126.320653 C229.414693,92.6932889 261.073632,68.3693517 298.430797,68.3693517 L378.256825,68.3693517 C389.658183,68.3693517 398.901487,77.5835044 398.901487,88.9498258 C398.901487,100.31601 389.658183,109.5303 378.256825,109.5303 L298.430797,109.5303 C278.91658,109.5303 262.462498,122.590095 257.383355,140.420263 C276.367071,154.133471 288.717472,176.433679 288.717472,201.613809 C288.717472,212.983093 279.484012,222.200393 268.094796,222.200393 C256.705578,222.200393 247.472119,212.983093 247.472119,201.613809 C247.472119,182.664544 232.083477,167.302835 213.100991,167.302835 L75.6164795,167.302835 C56.6338555,167.302835 41.2453532,182.664544 41.2453532,201.613809 C41.2453532,212.983093 32.0123043,222.200393 20.6226766,222.200393 C9.23308677,222.200393 0,212.983093 0,201.613809 C0,159.924603 33.8545967,126.129666 75.6164795,126.129666 L213.100991,126.129666 C214.923771,126.129666 216.731487,126.194046 218.521979,126.320653 L218.521983,126.320653 Z");
    			attr(path82, "fill", path82_fill_value = ctx.colors[4]);
    			attr(path82, "fill-rule", "nonzero");
    			add_location(path82, file, 96, 8, 44567);
    			attr(path83, "d", "M288.771038,201.866405 C288.771038,182.853729 304.179664,167.440614 323.186803,167.440614 C342.193942,167.440614 357.602568,182.853729 357.602568,201.866405 C357.602568,220.87908 342.193942,236.292195 323.186803,236.292195 C311.782795,236.292195 302.537344,245.540339 302.537344,256.947669 C302.537344,268.354999 311.782795,277.603143 323.186803,277.603143 C365.003335,277.603143 398.901487,243.695117 398.901487,201.866405 C398.901487,160.037692 365.003335,126.129666 323.186803,126.129666 C281.370271,126.129666 247.472119,160.037692 247.472119,201.866405 C247.472119,213.273735 256.71757,222.521879 268.121578,222.521879 C279.525586,222.521879 288.771038,213.273735 288.771038,201.866405 Z");
    			attr(path83, "fill", path83_fill_value = ctx.colors[1]);
    			add_location(path83, file, 97, 8, 45606);
    			attr(path84, "d", "M288.717472,202.1611 C288.717472,190.768566 279.484012,181.532417 268.094796,181.532417 C256.705579,181.532417 247.472119,190.768566 247.472119,202.1611 C247.472119,213.553635 256.705579,222.789784 268.094796,222.789784 C279.484012,222.789784 288.717472,213.553635 288.717472,202.1611 Z");
    			attr(path84, "fill", path84_fill_value = ctx.colors[0]);
    			add_location(path84, file, 98, 8, 46344);
    			attr(path85, "d", "M41.2453532,201.571709 C41.2453532,190.179175 32.0118934,180.943026 20.6226766,180.943026 C9.23345973,180.943026 0,190.179175 0,201.571709 C0,212.964244 9.23345973,222.200393 20.6226766,222.200393 C32.0118934,222.200393 41.2453532,212.964244 41.2453532,201.571709 Z");
    			attr(path85, "fill", path85_fill_value = ctx.colors[1]);
    			add_location(path85, file, 99, 8, 46676);
    			attr(path86, "d", "M268.094796,327.111984 C268.094796,315.71945 258.861336,306.483301 247.472119,306.483301 C236.082902,306.483301 226.849442,315.71945 226.849442,327.111984 C226.849442,338.504519 236.082902,347.740668 247.472119,347.740668 C258.861336,347.740668 268.094796,338.504519 268.094796,327.111984 Z");
    			attr(path86, "fill", path86_fill_value = ctx.colors[1]);
    			add_location(path86, file, 100, 8, 46987);
    			attr(path87, "d", "M268.094796,381.925344 C268.094796,370.532809 258.861336,361.29666 247.472119,361.29666 C236.082902,361.29666 226.849442,370.532809 226.849442,381.925344 C226.849442,393.317878 236.082902,402.554028 247.472119,402.554028 C258.861336,402.554028 268.094796,393.317878 268.094796,381.925344 Z");
    			attr(path87, "fill", path87_fill_value = ctx.colors[1]);
    			add_location(path87, file, 101, 8, 47323);
    			attr(path88, "d", "M447.217472,405.500982 C447.217472,394.108448 437.984012,384.872299 426.594796,384.872299 C415.205579,384.872299 405.972119,394.108448 405.972119,405.500982 C405.972119,416.893517 415.205579,426.129666 426.594796,426.129666 C437.984012,426.129666 447.217472,416.893517 447.217472,405.500982 Z");
    			attr(path88, "fill", path88_fill_value = ctx.colors[1]);
    			add_location(path88, file, 102, 8, 47658);
    			attr(path89, "d", "M503.782528,402.554028 C503.782528,391.161493 494.549068,381.925344 483.159851,381.925344 C471.770634,381.925344 462.537175,391.161493 462.537175,402.554028 C462.537175,413.946562 471.770634,423.182711 483.159851,423.182711 C494.549068,423.182711 503.782528,413.946562 503.782528,402.554028 Z");
    			attr(path89, "fill", path89_fill_value = ctx.colors[1]);
    			add_location(path89, file, 103, 8, 47996);
    			attr(path90, "d", "M503.782528,460.314342 C503.782528,448.921807 494.549068,439.685658 483.159851,439.685658 C471.770634,439.685658 462.537175,448.921807 462.537175,460.314342 C462.537175,471.706876 471.770634,480.943026 483.159851,480.943026 C494.549068,480.943026 503.782528,471.706876 503.782528,460.314342 Z");
    			attr(path90, "fill", path90_fill_value = ctx.colors[1]);
    			add_location(path90, file, 104, 8, 48334);
    			attr(path91, "d", "M222.724907,1178.78193 C222.724907,1167.38939 213.491447,1158.15324 202.10223,1158.15324 C190.713014,1158.15324 181.479554,1167.38939 181.479554,1178.78193 C181.479554,1190.17446 190.713014,1199.41061 202.10223,1199.41061 C213.491447,1199.41061 222.724907,1190.17446 222.724907,1178.78193 Z");
    			attr(path91, "fill", path91_fill_value = ctx.colors[1]);
    			add_location(path91, file, 105, 8, 48672);
    			attr(path92, "d", "M284.592937,1178.78193 C284.592937,1167.38939 275.359477,1158.15324 263.97026,1158.15324 C252.581043,1158.15324 243.347584,1167.38939 243.347584,1178.78193 C243.347584,1190.17446 252.581043,1199.41061 263.97026,1199.41061 C275.359477,1199.41061 284.592937,1190.17446 284.592937,1178.78193 Z");
    			attr(path92, "fill", path92_fill_value = ctx.colors[0]);
    			add_location(path92, file, 106, 8, 49008);
    			attr(path93, "d", "M470.786245,1177.60314 C470.786245,1166.21061 461.552786,1156.97446 450.163569,1156.97446 C438.774352,1156.97446 429.540892,1166.21061 429.540892,1177.60314 C429.540892,1188.99568 438.774352,1198.23183 450.163569,1198.23183 C461.552786,1198.23183 470.786245,1188.99568 470.786245,1177.60314 Z");
    			attr(path93, "fill", path93_fill_value = ctx.colors[1]);
    			add_location(path93, file, 107, 8, 49344);
    			attr(path94, "d", "M398.901487,88.9980354 C398.901487,77.6052259 389.668027,68.3693517 378.27881,68.3693517 C366.889594,68.3693517 357.656134,77.6052259 357.656134,88.9980354 C357.656134,100.390982 366.889594,109.626719 378.27881,109.626719 C389.668027,109.626719 398.901487,100.390982 398.901487,88.9980354 Z");
    			attr(path94, "fill", path94_fill_value = ctx.colors[0]);
    			add_location(path94, file, 108, 8, 49682);
    			attr(path95, "d", "M454.288104,88.9980354 C454.288104,77.6050884 445.054644,68.3693517 433.665428,68.3693517 C422.276211,68.3693517 413.042751,77.6050884 413.042751,88.9980354 C413.042751,100.390982 422.276211,109.626719 433.665428,109.626719 C445.054644,109.626719 454.288104,100.390982 454.288104,88.9980354 Z");
    			attr(path95, "fill", path95_fill_value = ctx.colors[0]);
    			add_location(path95, file, 109, 8, 50018);
    			attr(path96, "d", "M199.198221,180.889445 C180.254474,180.889445 164.897238,165.47633 164.897238,146.463654 C164.897238,127.450841 180.254474,112.037864 199.198221,112.037864 C210.564194,112.037864 219.77881,102.790133 219.77881,91.3823897 C219.77881,79.9746467 210.564194,70.7269155 199.198221,70.7269155 C157.521155,70.7269155 123.736059,104.635355 123.736059,146.463654 C123.736059,188.292366 157.521155,222.200393 199.198221,222.200393 C210.564194,222.200393 219.77881,212.952249 219.77881,201.544919 C219.77881,190.137589 210.564194,180.889445 199.198221,180.889445 Z");
    			attr(path96, "fill", path96_fill_value = ctx.colors[2]);
    			add_location(path96, file, 110, 8, 50356);
    			attr(path97, "d", "M96.6319703,388.998035 C149.024568,388.998035 191.496283,431.482122 191.496283,483.88998 C191.496283,495.282515 200.729742,504.518664 212.118959,504.518664 C223.508176,504.518664 232.741636,495.282515 232.741636,483.88998 C232.741636,408.697053 171.803001,347.740668 96.6319703,347.740668 C85.242341,347.740668 76.0092937,356.976817 76.0092937,368.369352 C76.0092937,379.761886 85.242341,388.998035 96.6319703,388.998035 Z");
    			attr(path97, "fill", path97_fill_value = ctx.colors[0]);
    			add_location(path97, file, 111, 8, 50955);
    			attr(path98, "d", "M100.167286,504.518664 C100.167286,493.12613 90.934239,483.88998 79.5446097,483.88998 C68.1549804,483.88998 58.9219331,493.12613 58.9219331,504.518664 C58.9219331,515.911198 68.1549804,525.147348 79.5446097,525.147348 C90.934239,525.147348 100.167286,515.911198 100.167286,504.518664 Z");
    			attr(path98, "fill", path98_fill_value = ctx.colors[0]);
    			add_location(path98, file, 112, 8, 51423);
    			attr(path99, "d", "M1000.49442,895.284872 C1000.49442,906.677407 991.260964,915.913556 979.871747,915.913556 C968.48253,915.913556 959.249071,906.677407 959.249071,895.284872 C959.249071,883.892338 968.48253,874.656189 979.871747,874.656189 C991.260964,874.656189 1000.49442,883.892338 1000.49442,895.284872 Z");
    			attr(path99, "fill", path99_fill_value = ctx.colors[1]);
    			add_location(path99, file, 113, 8, 51754);
    			attr(path100, "d", "M1055.29182,895.284872 C1055.29182,906.677407 1046.05836,915.913556 1034.66914,915.913556 C1023.27993,915.913556 1014.04647,906.677407 1014.04647,895.284872 C1014.04647,883.892338 1023.27993,874.656189 1034.66914,874.656189 C1046.05836,874.656189 1055.29182,883.892338 1055.29182,895.284872 Z");
    			attr(path100, "fill", path100_fill_value = ctx.colors[1]);
    			add_location(path100, file, 114, 8, 52090);
    			attr(path101, "d", "M718.258364,763.261297 C718.258364,774.653831 709.024905,783.88998 697.635688,783.88998 C686.246471,783.88998 677.013011,774.653831 677.013011,763.261297 C677.013011,751.868762 686.246471,742.632613 697.635688,742.632613 C709.024905,742.632613 718.258364,751.868762 718.258364,763.261297 Z");
    			attr(path101, "fill", path101_fill_value = ctx.colors[0]);
    			add_location(path101, file, 115, 8, 52428);
    			attr(path102, "d", "M719.436803,1010.8055 C719.436803,1022.19804 710.203343,1031.43418 698.814126,1031.43418 C687.42491,1031.43418 678.19145,1022.19804 678.19145,1010.8055 C678.19145,999.412967 687.42491,990.176817 698.814126,990.176817 C710.203343,990.176817 719.436803,999.412967 719.436803,1010.8055 Z");
    			attr(path102, "fill", path102_fill_value = ctx.colors[0]);
    			add_location(path102, file, 116, 8, 52763);
    			attr(path103, "d", "M949.300897,196.267191 C925.994367,196.267191 906.877064,215.290963 906.877064,239.034578 C906.877064,262.776817 925.994367,281.800589 949.300897,281.800589 C1033.99432,281.800589 1102.42937,350.765029 1102.42937,435.559921 C1102.42937,446.952456 1093.18057,456.188605 1081.77243,456.188605 C1070.3643,456.188605 1061.1155,446.952456 1061.1155,435.559921 C1061.1155,373.303929 1010.93155,323.057957 949.300897,323.057957 C902.93159,323.057957 865.563197,285.315717 865.563197,239.034578 C865.563197,192.752063 902.93159,155.009823 949.300897,155.009823 C960.71041,155.009823 969.957831,164.245972 969.957831,175.638507 C969.957831,187.031041 960.71041,196.267191 949.300897,196.267191 Z");
    			attr(path103, "fill", path103_fill_value = ctx.colors[2]);
    			add_location(path103, file, 117, 8, 53093);
    			attr(path104, "d", "M1060.5948,435.60633 C1060.5948,498.229807 1010.53531,548.630169 949.232342,548.630169 C937.843125,548.630169 928.609665,557.887097 928.609665,569.305261 C928.609665,580.723426 937.843125,589.980354 949.232342,589.980354 C1033.71657,589.980354 1101.84015,520.662282 1101.84015,435.60633 C1101.84015,424.188166 1092.60669,414.931238 1081.21747,414.931238 C1069.82826,414.931238 1060.5948,424.188166 1060.5948,435.60633 Z");
    			attr(path104, "fill", path104_fill_value = ctx.colors[0]);
    			add_location(path104, file, 118, 8, 53825);
    			attr(path105, "d", "M1081.21747,456.188605 C1069.82826,456.188605 1060.5948,446.952456 1060.5948,435.559921 C1060.5948,424.167387 1069.82826,414.931238 1081.21747,414.931238 C1092.60669,414.931238 1101.84015,424.167387 1101.84015,435.559921 C1101.84015,446.952456 1092.60669,456.188605 1081.21747,456.188605 Z");
    			attr(path105, "fill", path105_fill_value = ctx.colors[1]);
    			add_location(path105, file, 119, 8, 54290);
    			attr(path106, "d", "M800.749071,310.609037 C812.138287,310.609037 821.371747,319.859076 821.371747,331.268742 L821.371747,420.794127 C821.371747,432.203793 812.138287,441.453831 800.749071,441.453831 C789.359854,441.453831 780.126394,432.203793 780.126394,420.794127 L780.126394,331.268742 C780.126394,319.859076 789.359854,310.609037 800.749071,310.609037 Z");
    			attr(path106, "fill", path106_fill_value = ctx.colors[3]);
    			add_location(path106, file, 120, 8, 54625);
    			attr(path107, "d", "M462.496817,194.519202 C462.496817,271.306837 400.266866,333.554916 323.501591,333.554916 C312.10123,333.554916 302.858736,342.800102 302.858736,354.203784 C302.858736,365.607466 312.10123,374.852652 323.501591,374.852652 C423.067587,374.852652 503.782528,294.114201 503.782528,194.519202 C503.782528,183.115521 494.540033,173.870334 483.139673,173.870334 C471.739312,173.870334 462.496817,183.115521 462.496817,194.519202 Z");
    			attr(path107, "fill", path107_fill_value = ctx.colors[3]);
    			add_location(path107, file, 121, 8, 55009);
    			attr(path108, "d", "M1141.90706,238.70334 C1141.90706,250.095874 1132.6568,259.332024 1121.24686,259.332024 L946.323775,259.332024 C934.913832,259.332024 925.663569,250.095874 925.663569,238.70334 C925.663569,227.310806 934.913832,218.074656 946.323775,218.074656 L1121.24686,218.074656 C1132.6568,218.074656 1141.90706,227.310806 1141.90706,238.70334 Z");
    			attr(path108, "fill", path108_fill_value = ctx.colors[4]);
    			attr(path108, "fill-rule", "nonzero");
    			add_location(path108, file, 122, 8, 55479);
    			attr(path109, "d", "M503.782528,194.499018 C503.782528,183.106483 494.549068,173.870334 483.159851,173.870334 C471.770634,173.870334 462.537175,183.106483 462.537175,194.499018 C462.537175,205.891552 471.770634,215.127701 483.159851,215.127701 C494.549068,215.127701 503.782528,205.891552 503.782528,194.499018 Z");
    			attr(path109, "fill", path109_fill_value = ctx.colors[0]);
    			add_location(path109, file, 123, 8, 55878);
    			attr(path110, "d", "M1100.51352,194.350786 C1092.45968,202.406974 1079.4014,202.406974 1071.34893,194.350786 C1063.29509,186.294597 1063.29509,173.232515 1071.34893,165.177701 C1079.4014,157.121513 1092.45968,157.121513 1100.51352,165.177701 C1108.56736,173.232515 1108.56736,186.294597 1100.51352,194.350786 Z");
    			attr(path110, "fill", path110_fill_value = ctx.colors[1]);
    			add_location(path110, file, 124, 8, 56216);
    			attr(path111, "d", "M960.279321,132.464584 C952.225478,140.520974 939.167199,140.520974 931.114731,132.464584 C923.060889,124.408607 923.060889,111.347469 931.114731,103.291492 C939.167199,95.2355145 952.225478,95.2355145 960.279321,103.291492 C968.333163,111.347469 968.333163,124.408607 960.279321,132.464584 Z");
    			attr(path111, "fill", path111_fill_value = ctx.colors[1]);
    			add_location(path111, file, 125, 8, 56552);
    			attr(path112, "d", "M0,640.667976 C0,629.275442 9.23308852,620.039293 20.6226766,620.039293 L86.6152416,620.039293 C98.0048709,620.039293 107.237918,629.275442 107.237918,640.667976 C107.237918,652.060511 98.0048709,661.29666 86.6152416,661.29666 L20.6226766,661.29666 C9.23308852,661.29666 0,652.060511 0,640.667976 Z");
    			attr(path112, "fill", path112_fill_value = ctx.colors[1]);
    			add_location(path112, file, 126, 8, 56890);
    			attr(path113, "d", "M656.390335,1195.28487 C645.001118,1195.28487 635.767658,1186.0668 635.767658,1174.69656 L635.767658,1115.67672 C635.767658,1104.30648 645.001118,1095.08841 656.390335,1095.08841 C667.779551,1095.08841 677.013011,1104.30648 677.013011,1115.67672 L677.013011,1174.69656 C677.013011,1186.0668 667.779551,1195.28487 656.390335,1195.28487 Z");
    			attr(path113, "fill", path113_fill_value = ctx.colors[3]);
    			add_location(path113, file, 127, 8, 57234);
    			attr(path114, "d", "M755.379182,1178.78193 C755.379182,1167.38939 764.621495,1158.15324 776.021631,1158.15324 L939.78506,1158.15324 C951.185197,1158.15324 960.427509,1167.38939 960.427509,1178.78193 C960.427509,1190.17446 951.185197,1199.41061 939.78506,1199.41061 L776.021631,1199.41061 C764.621495,1199.41061 755.379182,1190.17446 755.379182,1178.78193 Z");
    			attr(path114, "fill", path114_fill_value = ctx.colors[2]);
    			add_location(path114, file, 128, 8, 57616);
    			attr(path115, "d", "M0,31.237721 C0,19.8447741 9.23308947,10.6090373 20.6226774,10.6090373 L115.486989,10.6090373 C126.876618,10.6090373 136.109665,19.8447741 136.109665,31.237721 C136.109665,42.630668 126.876618,51.8664047 115.486989,51.8664047 L20.6226774,51.8664047 C9.23308947,51.8664047 0,42.630668 0,31.237721 Z");
    			attr(path115, "fill", path115_fill_value = ctx.colors[0]);
    			add_location(path115, file, 129, 8, 57998);
    			attr(path116, "d", "M945.107807,1199.41061 C933.71859,1199.41061 924.48513,1190.17446 924.48513,1178.78193 C924.48513,1167.38939 933.71859,1158.15324 945.107807,1158.15324 C956.497024,1158.15324 965.730483,1167.38939 965.730483,1178.78193 C965.730483,1190.17446 956.497024,1199.41061 945.107807,1199.41061 Z");
    			attr(path116, "fill", path116_fill_value = ctx.colors[0]);
    			add_location(path116, file, 130, 8, 58341);
    			attr(path117, "d", "M885.03981,141.389063 C850.165329,141.389063 821.896217,169.667782 821.896217,204.551048 C821.896217,215.925698 812.677253,225.147348 801.305915,225.147348 C789.933205,225.147348 780.715613,215.925698 780.715613,204.551048 C780.715613,146.91711 827.422654,100.196464 885.03981,100.196464 C896.411147,100.196464 905.630112,109.417702 905.630112,120.792763 C905.630112,132.167825 896.411147,141.389063 885.03981,141.389063 Z");
    			attr(path117, "fill", path117_fill_value = ctx.colors[0]);
    			add_location(path117, file, 131, 8, 58674);
    			attr(path118, "d", "M786.755995,189.932122 C794.808463,181.875933 807.866742,181.875933 815.920585,189.932122 C823.974427,197.98831 823.974427,211.049018 815.920585,219.105206 C807.866742,227.161395 794.808463,227.161395 786.755995,219.105206 C778.702153,211.049018 778.702153,197.98831 786.755995,189.932122 Z");
    			attr(path118, "fill", path118_fill_value = ctx.colors[1]);
    			add_location(path118, file, 132, 8, 59142);
    			attr(path119, "d", "M1195.52602,793.320236 C1268.41893,793.320236 1327.51115,734.210806 1327.51115,661.29666 C1327.51115,649.904126 1336.74461,640.667976 1348.13383,640.667976 C1359.52305,640.667976 1368.75651,649.904126 1368.75651,661.29666 C1368.75651,756.99725 1291.19874,834.577603 1195.52602,834.577603 C1184.13681,834.577603 1174.90335,825.341454 1174.90335,813.948919 C1174.90335,802.556385 1184.13681,793.320236 1195.52602,793.320236 Z");
    			attr(path119, "fill", path119_fill_value = ctx.colors[3]);
    			add_location(path119, file, 133, 8, 59478);
    			attr(path120, "d", "M1362.71612,675.883202 C1354.66228,683.939391 1341.604,683.939391 1333.55153,675.883202 C1325.49769,667.827014 1325.49769,654.764931 1333.55153,646.710118 C1341.604,638.653929 1354.66228,638.653929 1362.71612,646.710118 C1370.76997,654.764931 1370.76997,667.827014 1362.71612,675.883202 Z");
    			attr(path120, "fill", path120_fill_value = ctx.colors[1]);
    			add_location(path120, file, 134, 8, 59947);
    			attr(path121, "d", "M1421.04678,675.883202 C1412.99018,683.939391 1399.92915,683.939391 1391.88631,675.883202 C1383.82972,667.827014 1383.82972,654.764931 1391.88631,646.710118 C1399.92915,638.653929 1412.99018,638.653929 1421.04678,646.710118 C1429.10337,654.764931 1429.10337,667.827014 1421.04678,675.883202 Z");
    			attr(path121, "fill", path121_fill_value = ctx.colors[1]);
    			add_location(path121, file, 135, 8, 60281);
    			attr(path122, "d", "M1559.04068,753.309009 C1460.16564,753.309009 1380.01901,833.483111 1380.01901,932.382823 C1380.01901,943.793958 1370.77048,953.045187 1359.36267,953.045187 C1347.95485,953.045187 1338.70632,943.793958 1338.70632,932.382823 C1338.70632,810.659464 1437.34726,711.984283 1559.04068,711.984283 C1570.44298,711.984283 1579.69703,721.235512 1579.69703,732.646646 C1579.69703,744.057781 1570.44298,753.309009 1559.04068,753.309009 Z");
    			attr(path122, "fill", path122_fill_value = ctx.colors[2]);
    			add_location(path122, file, 136, 8, 60619);
    			attr(path123, "d", "M1141.90706,238.599507 C1141.96454,249.992271 1132.77901,259.275367 1121.38819,259.332024 C1109.99874,259.389514 1100.71973,250.201313 1100.66171,238.807173 C1100.60424,227.414408 1109.79114,218.132688 1121.18058,218.074656 C1132.57003,218.017166 1141.85042,227.206742 1141.90706,238.599507 Z");
    			attr(path123, "fill", path123_fill_value = ctx.colors[0]);
    			add_location(path123, file, 137, 8, 61091);
    			attr(path124, "d", "M1330.45725,29.3653045 C1330.51472,40.758117 1321.3292,50.040477 1309.93838,50.0982318 C1298.54893,50.1555851 1289.26991,40.9666043 1289.2119,29.5737918 C1289.15442,18.1811168 1298.34132,8.89875677 1309.73077,8.84086444 C1321.12022,8.78351116 1330.40061,17.9726295 1330.45725,29.3653045 Z");
    			attr(path124, "fill", path124_fill_value = ctx.colors[0]);
    			add_location(path124, file, 138, 8, 61429);
    			attr(path125, "d", "M1141.90706,31.1334774 C1141.96454,42.5262899 1132.77901,51.8086499 1121.38819,51.8664047 C1109.99874,51.923758 1100.71973,42.7347771 1100.66171,31.3419647 C1100.60424,19.9492897 1109.79114,10.6669297 1121.18058,10.6090373 C1132.57003,10.5516841 1141.85042,19.7408024 1141.90706,31.1334774 Z");
    			attr(path125, "fill", path125_fill_value = ctx.colors[0]);
    			add_location(path125, file, 139, 8, 61763);
    			attr(path126, "d", "M1141.90706,85.9468369 C1141.96454,97.3396494 1132.77901,106.622009 1121.38819,106.679764 C1109.99874,106.737118 1100.71973,97.5481367 1100.66171,86.1553242 C1100.60424,74.7626492 1109.79114,65.4802892 1121.18058,65.4223969 C1132.57003,65.3650436 1141.85042,74.554162 1141.90706,85.9468369 Z");
    			attr(path126, "fill", path126_fill_value = ctx.colors[0]);
    			add_location(path126, file, 140, 8, 62100);
    			attr(path127, "d", "M1548.45194,681.925344 L1466.58337,681.925344 C1455.19057,681.925344 1445.94424,672.689194 1445.94424,661.29666 C1445.94424,649.904126 1455.19057,640.667976 1466.58337,640.667976 L1548.45194,640.667976 C1559.84475,640.667976 1569.09108,649.904126 1569.09108,661.29666 C1569.09108,672.689194 1559.84475,681.925344 1548.45194,681.925344 Z");
    			attr(path127, "fill", path127_fill_value = ctx.colors[4]);
    			attr(path127, "fill-rule", "nonzero");
    			add_location(path127, file, 141, 8, 62437);
    			attr(path128, "d", "M1579.69703,732.612967 C1579.69703,744.005501 1570.45807,753.24165 1559.07435,753.24165 C1547.69063,753.24165 1538.45167,744.005501 1538.45167,732.612967 C1538.45167,721.220432 1547.69063,711.984283 1559.07435,711.984283 C1570.45807,711.984283 1579.69703,721.220432 1579.69703,732.612967 Z");
    			attr(path128, "fill", path128_fill_value = ctx.colors[0]);
    			add_location(path128, file, 142, 8, 62839);
    			attr(path129, "d", "M1343.95573,183.595285 C1343.95573,164.582609 1328.5471,149.169495 1309.53996,149.169495 C1290.53282,149.169495 1275.1242,164.582609 1275.1242,183.595285 C1275.1242,202.60796 1290.53282,218.021075 1309.53996,218.021075 C1320.94397,218.021075 1330.18942,227.26922 1330.18942,238.676549 C1330.18942,250.083879 1320.94397,259.332024 1309.53996,259.332024 C1267.72343,259.332024 1233.82528,225.423997 1233.82528,183.595285 C1233.82528,141.766573 1267.72343,107.858546 1309.53996,107.858546 C1351.35649,107.858546 1385.25465,141.766573 1385.25465,183.595285 C1385.25465,195.002615 1376.00369,204.250759 1364.60519,204.250759 C1353.20118,204.250759 1343.95573,195.002615 1343.95573,183.595285 Z");
    			attr(path129, "fill", path129_fill_value = ctx.colors[1]);
    			add_location(path129, file, 143, 8, 63174);
    			attr(path130, "d", "M1450.11086,41.3109484 C1431.163,41.3109484 1415.80988,56.7239255 1415.80988,75.7367387 C1415.80988,94.7495519 1431.163,110.162529 1450.11086,110.162529 C1461.47135,110.162529 1470.69145,119.41026 1470.69145,130.818003 C1470.69145,142.225333 1461.47135,151.473477 1450.11086,151.473477 C1408.42831,151.473477 1374.6487,117.565038 1374.6487,75.7367387 C1374.6487,33.9084395 1408.42831,0 1450.11086,0 C1461.47135,0 1470.69145,9.24777251 1470.69145,20.6554742 C1470.69145,32.0632172 1461.47135,41.3109484 1450.11086,41.3109484 Z");
    			attr(path130, "fill", path130_fill_value = ctx.colors[4]);
    			attr(path130, "fill-rule", "nonzero");
    			add_location(path130, file, 144, 8, 63908);
    			attr(path131, "d", "M1331.63569,238.70334 C1331.63569,250.095874 1322.40223,259.332024 1311.01301,259.332024 C1299.62379,259.332024 1290.39033,250.095874 1290.39033,238.70334 C1290.39033,227.310806 1299.62379,218.074656 1311.01301,218.074656 C1322.40223,218.074656 1331.63569,227.310806 1331.63569,238.70334 Z");
    			attr(path131, "fill", path131_fill_value = ctx.colors[0]);
    			add_location(path131, file, 145, 8, 64499);
    			attr(path132, "d", "M1471.86989,130.844794 C1471.86989,142.237328 1462.63093,151.473477 1451.24721,151.473477 C1439.86349,151.473477 1430.62454,142.237328 1430.62454,130.844794 C1430.62454,119.451847 1439.86349,110.21611 1451.24721,110.21611 C1462.63093,110.21611 1471.86989,119.451847 1471.86989,130.844794 Z");
    			attr(path132, "fill", path132_fill_value = ctx.colors[1]);
    			add_location(path132, file, 146, 8, 64834);
    			attr(path133, "d", "M1387.0223,238.70334 C1387.0223,250.095874 1377.78335,259.332024 1366.39963,259.332024 C1355.01041,259.332024 1345.77695,250.095874 1345.77695,238.70334 C1345.77695,227.310806 1355.01041,218.074656 1366.39963,218.074656 C1377.78335,218.074656 1387.0223,227.310806 1387.0223,238.70334 Z");
    			attr(path133, "fill", path133_fill_value = ctx.colors[1]);
    			add_location(path133, file, 147, 8, 65169);
    			attr(path134, "d", "M1441.8197,238.70334 C1441.8197,250.095874 1432.58074,259.332024 1421.19703,259.332024 C1409.81331,259.332024 1400.57435,250.095874 1400.57435,238.70334 C1400.57435,227.310806 1409.81331,218.074656 1421.19703,218.074656 C1432.58074,218.074656 1441.8197,227.310806 1441.8197,238.70334 Z");
    			attr(path134, "fill", path134_fill_value = ctx.colors[1]);
    			add_location(path134, file, 148, 8, 65500);
    			attr(path135, "d", "M1473.63755,74.8526523 C1473.63755,86.2455992 1464.39859,95.481336 1453.01487,95.481336 C1441.63115,95.481336 1432.39219,86.2455992 1432.39219,74.8526523 C1432.39219,63.4597053 1441.63115,54.2239686 1453.01487,54.2239686 C1464.39859,54.2239686 1473.63755,63.4597053 1473.63755,74.8526523 Z");
    			attr(path135, "fill", path135_fill_value = ctx.colors[0]);
    			add_location(path135, file, 149, 8, 65831);
    			attr(path136, "d", "M1528.43494,74.8526523 C1528.43494,86.2455992 1519.19599,95.481336 1507.81227,95.481336 C1496.42855,95.481336 1487.18959,86.2455992 1487.18959,74.8526523 C1487.18959,63.4597053 1496.42855,54.2239686 1507.81227,54.2239686 C1519.19599,54.2239686 1528.43494,63.4597053 1528.43494,74.8526523 Z");
    			attr(path136, "fill", path136_fill_value = ctx.colors[0]);
    			add_location(path136, file, 150, 8, 66166);
    			attr(path137, "d", "M1583.82156,74.8526523 C1583.82156,86.2455992 1574.5826,95.481336 1563.19888,95.481336 C1551.81517,95.481336 1542.57621,86.2455992 1542.57621,74.8526523 C1542.57621,63.4597053 1551.81517,54.2239686 1563.19888,54.2239686 C1574.5826,54.2239686 1583.82156,63.4597053 1583.82156,74.8526523 Z");
    			attr(path137, "fill", path137_fill_value = ctx.colors[0]);
    			add_location(path137, file, 151, 8, 66501);
    			attr(path138, "d", "M1508.40149,442.632613 C1497.01777,442.632613 1487.77881,433.396464 1487.77881,422.003929 C1487.77881,410.611395 1497.01777,401.375246 1508.40149,401.375246 C1519.7852,401.375246 1529.02416,410.611395 1529.02416,422.003929 C1529.02416,433.396464 1519.7852,442.632613 1508.40149,442.632613 Z");
    			attr(path138, "fill", path138_fill_value = ctx.colors[1]);
    			add_location(path138, file, 152, 8, 66834);
    			attr(g0, "transform", "translate(0.589219, 1.178782)");
    			attr(g0, "id", "Shape");
    			add_location(g0, file, 13, 6, 495);
    			attr(g1, "id", "Aare");
    			attr(g1, "transform", "translate(0.000000, -1.000000)");
    			add_location(g1, file, 12, 4, 432);
    			attr(g2, "id", "Patterns");
    			attr(g2, "stroke", "none");
    			attr(g2, "stroke-width", "1");
    			attr(g2, "fill", "none");
    			attr(g2, "fill-rule", "evenodd");
    			add_location(g2, file, 11, 2, 347);
    			attr(svg, "viewBox", "0 0 1586 1199");
    			attr(svg, "version", "1.1");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr(svg, "style", ctx.styles);
    			add_location(svg, file, 10, 0, 206);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g2);
    			append(g2, g1);
    			append(g1, g0);
    			append(g0, path0);
    			append(g0, path1);
    			append(g0, path2);
    			append(g0, path3);
    			append(g0, path4);
    			append(g0, path5);
    			append(g0, path6);
    			append(g0, path7);
    			append(g0, path8);
    			append(g0, path9);
    			append(g0, path10);
    			append(g0, path11);
    			append(g0, path12);
    			append(g0, path13);
    			append(g0, path14);
    			append(g0, path15);
    			append(g0, path16);
    			append(g0, path17);
    			append(g0, path18);
    			append(g0, path19);
    			append(g0, path20);
    			append(g0, path21);
    			append(g0, path22);
    			append(g0, path23);
    			append(g0, path24);
    			append(g0, path25);
    			append(g0, path26);
    			append(g0, path27);
    			append(g0, path28);
    			append(g0, path29);
    			append(g0, path30);
    			append(g0, path31);
    			append(g0, path32);
    			append(g0, path33);
    			append(g0, path34);
    			append(g0, path35);
    			append(g0, path36);
    			append(g0, path37);
    			append(g0, path38);
    			append(g0, path39);
    			append(g0, path40);
    			append(g0, path41);
    			append(g0, path42);
    			append(g0, path43);
    			append(g0, path44);
    			append(g0, path45);
    			append(g0, path46);
    			append(g0, path47);
    			append(g0, path48);
    			append(g0, path49);
    			append(g0, path50);
    			append(g0, path51);
    			append(g0, path52);
    			append(g0, path53);
    			append(g0, path54);
    			append(g0, path55);
    			append(g0, path56);
    			append(g0, path57);
    			append(g0, path58);
    			append(g0, path59);
    			append(g0, path60);
    			append(g0, path61);
    			append(g0, path62);
    			append(g0, path63);
    			append(g0, path64);
    			append(g0, path65);
    			append(g0, path66);
    			append(g0, path67);
    			append(g0, path68);
    			append(g0, path69);
    			append(g0, path70);
    			append(g0, path71);
    			append(g0, path72);
    			append(g0, path73);
    			append(g0, path74);
    			append(g0, path75);
    			append(g0, path76);
    			append(g0, path77);
    			append(g0, path78);
    			append(g0, path79);
    			append(g0, path80);
    			append(g0, path81);
    			append(g0, path82);
    			append(g0, path83);
    			append(g0, path84);
    			append(g0, path85);
    			append(g0, path86);
    			append(g0, path87);
    			append(g0, path88);
    			append(g0, path89);
    			append(g0, path90);
    			append(g0, path91);
    			append(g0, path92);
    			append(g0, path93);
    			append(g0, path94);
    			append(g0, path95);
    			append(g0, path96);
    			append(g0, path97);
    			append(g0, path98);
    			append(g0, path99);
    			append(g0, path100);
    			append(g0, path101);
    			append(g0, path102);
    			append(g0, path103);
    			append(g0, path104);
    			append(g0, path105);
    			append(g0, path106);
    			append(g0, path107);
    			append(g0, path108);
    			append(g0, path109);
    			append(g0, path110);
    			append(g0, path111);
    			append(g0, path112);
    			append(g0, path113);
    			append(g0, path114);
    			append(g0, path115);
    			append(g0, path116);
    			append(g0, path117);
    			append(g0, path118);
    			append(g0, path119);
    			append(g0, path120);
    			append(g0, path121);
    			append(g0, path122);
    			append(g0, path123);
    			append(g0, path124);
    			append(g0, path125);
    			append(g0, path126);
    			append(g0, path127);
    			append(g0, path128);
    			append(g0, path129);
    			append(g0, path130);
    			append(g0, path131);
    			append(g0, path132);
    			append(g0, path133);
    			append(g0, path134);
    			append(g0, path135);
    			append(g0, path136);
    			append(g0, path137);
    			append(g0, path138);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colors) && path0_fill_value !== (path0_fill_value = ctx.colors[0])) {
    				attr(path0, "fill", path0_fill_value);
    			}

    			if ((changed.colors) && path1_fill_value !== (path1_fill_value = ctx.colors[1])) {
    				attr(path1, "fill", path1_fill_value);
    			}

    			if ((changed.colors) && path2_fill_value !== (path2_fill_value = ctx.colors[2])) {
    				attr(path2, "fill", path2_fill_value);
    			}

    			if ((changed.colors) && path3_fill_value !== (path3_fill_value = ctx.colors[3])) {
    				attr(path3, "fill", path3_fill_value);
    			}

    			if ((changed.colors) && path4_fill_value !== (path4_fill_value = ctx.colors[3])) {
    				attr(path4, "fill", path4_fill_value);
    			}

    			if ((changed.colors) && path5_fill_value !== (path5_fill_value = ctx.colors[4])) {
    				attr(path5, "fill", path5_fill_value);
    			}

    			if ((changed.colors) && path6_fill_value !== (path6_fill_value = ctx.colors[4])) {
    				attr(path6, "fill", path6_fill_value);
    			}

    			if ((changed.colors) && path7_fill_value !== (path7_fill_value = ctx.colors[1])) {
    				attr(path7, "fill", path7_fill_value);
    			}

    			if ((changed.colors) && path8_fill_value !== (path8_fill_value = ctx.colors[0])) {
    				attr(path8, "fill", path8_fill_value);
    			}

    			if ((changed.colors) && path9_fill_value !== (path9_fill_value = ctx.colors[0])) {
    				attr(path9, "fill", path9_fill_value);
    			}

    			if ((changed.colors) && path10_fill_value !== (path10_fill_value = ctx.colors[2])) {
    				attr(path10, "fill", path10_fill_value);
    			}

    			if ((changed.colors) && path11_fill_value !== (path11_fill_value = ctx.colors[4])) {
    				attr(path11, "fill", path11_fill_value);
    			}

    			if ((changed.colors) && path12_fill_value !== (path12_fill_value = ctx.colors[0])) {
    				attr(path12, "fill", path12_fill_value);
    			}

    			if ((changed.colors) && path13_fill_value !== (path13_fill_value = ctx.colors[0])) {
    				attr(path13, "fill", path13_fill_value);
    			}

    			if ((changed.colors) && path14_fill_value !== (path14_fill_value = ctx.colors[2])) {
    				attr(path14, "fill", path14_fill_value);
    			}

    			if ((changed.colors) && path15_fill_value !== (path15_fill_value = ctx.colors[2])) {
    				attr(path15, "fill", path15_fill_value);
    			}

    			if ((changed.colors) && path16_fill_value !== (path16_fill_value = ctx.colors[1])) {
    				attr(path16, "fill", path16_fill_value);
    			}

    			if ((changed.colors) && path17_fill_value !== (path17_fill_value = ctx.colors[4])) {
    				attr(path17, "fill", path17_fill_value);
    			}

    			if ((changed.colors) && path18_fill_value !== (path18_fill_value = ctx.colors[2])) {
    				attr(path18, "fill", path18_fill_value);
    			}

    			if ((changed.colors) && path19_fill_value !== (path19_fill_value = ctx.colors[3])) {
    				attr(path19, "fill", path19_fill_value);
    			}

    			if ((changed.colors) && path20_fill_value !== (path20_fill_value = ctx.colors[2])) {
    				attr(path20, "fill", path20_fill_value);
    			}

    			if ((changed.colors) && path21_fill_value !== (path21_fill_value = ctx.colors[0])) {
    				attr(path21, "fill", path21_fill_value);
    			}

    			if ((changed.colors) && path22_fill_value !== (path22_fill_value = ctx.colors[0])) {
    				attr(path22, "fill", path22_fill_value);
    			}

    			if ((changed.colors) && path23_fill_value !== (path23_fill_value = ctx.colors[0])) {
    				attr(path23, "fill", path23_fill_value);
    			}

    			if ((changed.colors) && path24_fill_value !== (path24_fill_value = ctx.colors[0])) {
    				attr(path24, "fill", path24_fill_value);
    			}

    			if ((changed.colors) && path25_fill_value !== (path25_fill_value = ctx.colors[1])) {
    				attr(path25, "fill", path25_fill_value);
    			}

    			if ((changed.colors) && path26_fill_value !== (path26_fill_value = ctx.colors[1])) {
    				attr(path26, "fill", path26_fill_value);
    			}

    			if ((changed.colors) && path27_fill_value !== (path27_fill_value = ctx.colors[0])) {
    				attr(path27, "fill", path27_fill_value);
    			}

    			if ((changed.colors) && path28_fill_value !== (path28_fill_value = ctx.colors[0])) {
    				attr(path28, "fill", path28_fill_value);
    			}

    			if ((changed.colors) && path29_fill_value !== (path29_fill_value = ctx.colors[0])) {
    				attr(path29, "fill", path29_fill_value);
    			}

    			if ((changed.colors) && path30_fill_value !== (path30_fill_value = ctx.colors[0])) {
    				attr(path30, "fill", path30_fill_value);
    			}

    			if ((changed.colors) && path31_fill_value !== (path31_fill_value = ctx.colors[2])) {
    				attr(path31, "fill", path31_fill_value);
    			}

    			if ((changed.colors) && path32_fill_value !== (path32_fill_value = ctx.colors[3])) {
    				attr(path32, "fill", path32_fill_value);
    			}

    			if ((changed.colors) && path33_fill_value !== (path33_fill_value = ctx.colors[4])) {
    				attr(path33, "fill", path33_fill_value);
    			}

    			if ((changed.colors) && path34_fill_value !== (path34_fill_value = ctx.colors[1])) {
    				attr(path34, "fill", path34_fill_value);
    			}

    			if ((changed.colors) && path35_fill_value !== (path35_fill_value = ctx.colors[4])) {
    				attr(path35, "fill", path35_fill_value);
    			}

    			if ((changed.colors) && path36_fill_value !== (path36_fill_value = ctx.colors[0])) {
    				attr(path36, "fill", path36_fill_value);
    			}

    			if ((changed.colors) && path37_fill_value !== (path37_fill_value = ctx.colors[0])) {
    				attr(path37, "fill", path37_fill_value);
    			}

    			if ((changed.colors) && path38_fill_value !== (path38_fill_value = ctx.colors[0])) {
    				attr(path38, "fill", path38_fill_value);
    			}

    			if ((changed.colors) && path39_fill_value !== (path39_fill_value = ctx.colors[1])) {
    				attr(path39, "fill", path39_fill_value);
    			}

    			if ((changed.colors) && path40_fill_value !== (path40_fill_value = ctx.colors[3])) {
    				attr(path40, "fill", path40_fill_value);
    			}

    			if ((changed.colors) && path41_fill_value !== (path41_fill_value = ctx.colors[2])) {
    				attr(path41, "fill", path41_fill_value);
    			}

    			if ((changed.colors) && path42_fill_value !== (path42_fill_value = ctx.colors[2])) {
    				attr(path42, "fill", path42_fill_value);
    			}

    			if ((changed.colors) && path43_fill_value !== (path43_fill_value = ctx.colors[0])) {
    				attr(path43, "fill", path43_fill_value);
    			}

    			if ((changed.colors) && path44_fill_value !== (path44_fill_value = ctx.colors[2])) {
    				attr(path44, "fill", path44_fill_value);
    			}

    			if ((changed.colors) && path45_fill_value !== (path45_fill_value = ctx.colors[1])) {
    				attr(path45, "fill", path45_fill_value);
    			}

    			if ((changed.colors) && path46_fill_value !== (path46_fill_value = ctx.colors[4])) {
    				attr(path46, "fill", path46_fill_value);
    			}

    			if ((changed.colors) && path47_fill_value !== (path47_fill_value = ctx.colors[3])) {
    				attr(path47, "fill", path47_fill_value);
    			}

    			if ((changed.colors) && path48_fill_value !== (path48_fill_value = ctx.colors[0])) {
    				attr(path48, "fill", path48_fill_value);
    			}

    			if ((changed.colors) && path49_fill_value !== (path49_fill_value = ctx.colors[0])) {
    				attr(path49, "fill", path49_fill_value);
    			}

    			if ((changed.colors) && path50_fill_value !== (path50_fill_value = ctx.colors[0])) {
    				attr(path50, "fill", path50_fill_value);
    			}

    			if ((changed.colors) && path51_fill_value !== (path51_fill_value = ctx.colors[0])) {
    				attr(path51, "fill", path51_fill_value);
    			}

    			if ((changed.colors) && path52_fill_value !== (path52_fill_value = ctx.colors[3])) {
    				attr(path52, "fill", path52_fill_value);
    			}

    			if ((changed.colors) && path53_fill_value !== (path53_fill_value = ctx.colors[4])) {
    				attr(path53, "fill", path53_fill_value);
    			}

    			if ((changed.colors) && path54_fill_value !== (path54_fill_value = ctx.colors[0])) {
    				attr(path54, "fill", path54_fill_value);
    			}

    			if ((changed.colors) && path55_fill_value !== (path55_fill_value = ctx.colors[2])) {
    				attr(path55, "fill", path55_fill_value);
    			}

    			if ((changed.colors) && path56_fill_value !== (path56_fill_value = ctx.colors[4])) {
    				attr(path56, "fill", path56_fill_value);
    			}

    			if ((changed.colors) && path57_fill_value !== (path57_fill_value = ctx.colors[3])) {
    				attr(path57, "fill", path57_fill_value);
    			}

    			if ((changed.colors) && path58_fill_value !== (path58_fill_value = ctx.colors[3])) {
    				attr(path58, "fill", path58_fill_value);
    			}

    			if ((changed.colors) && path59_fill_value !== (path59_fill_value = ctx.colors[1])) {
    				attr(path59, "fill", path59_fill_value);
    			}

    			if ((changed.colors) && path60_fill_value !== (path60_fill_value = ctx.colors[1])) {
    				attr(path60, "fill", path60_fill_value);
    			}

    			if ((changed.colors) && path61_fill_value !== (path61_fill_value = ctx.colors[0])) {
    				attr(path61, "fill", path61_fill_value);
    			}

    			if ((changed.colors) && path62_fill_value !== (path62_fill_value = ctx.colors[0])) {
    				attr(path62, "fill", path62_fill_value);
    			}

    			if ((changed.colors) && path63_fill_value !== (path63_fill_value = ctx.colors[0])) {
    				attr(path63, "fill", path63_fill_value);
    			}

    			if ((changed.colors) && path64_fill_value !== (path64_fill_value = ctx.colors[0])) {
    				attr(path64, "fill", path64_fill_value);
    			}

    			if ((changed.colors) && path65_fill_value !== (path65_fill_value = ctx.colors[0])) {
    				attr(path65, "fill", path65_fill_value);
    			}

    			if ((changed.colors) && path66_fill_value !== (path66_fill_value = ctx.colors[2])) {
    				attr(path66, "fill", path66_fill_value);
    			}

    			if ((changed.colors) && path67_fill_value !== (path67_fill_value = ctx.colors[2])) {
    				attr(path67, "fill", path67_fill_value);
    			}

    			if ((changed.colors) && path68_fill_value !== (path68_fill_value = ctx.colors[2])) {
    				attr(path68, "fill", path68_fill_value);
    			}

    			if ((changed.colors) && path69_fill_value !== (path69_fill_value = ctx.colors[4])) {
    				attr(path69, "fill", path69_fill_value);
    			}

    			if ((changed.colors) && path70_fill_value !== (path70_fill_value = ctx.colors[4])) {
    				attr(path70, "fill", path70_fill_value);
    			}

    			if ((changed.colors) && path71_fill_value !== (path71_fill_value = ctx.colors[0])) {
    				attr(path71, "fill", path71_fill_value);
    			}

    			if ((changed.colors) && path72_fill_value !== (path72_fill_value = ctx.colors[3])) {
    				attr(path72, "fill", path72_fill_value);
    			}

    			if ((changed.colors) && path73_fill_value !== (path73_fill_value = ctx.colors[2])) {
    				attr(path73, "fill", path73_fill_value);
    			}

    			if ((changed.colors) && path74_fill_value !== (path74_fill_value = ctx.colors[0])) {
    				attr(path74, "fill", path74_fill_value);
    			}

    			if ((changed.colors) && path75_fill_value !== (path75_fill_value = ctx.colors[0])) {
    				attr(path75, "fill", path75_fill_value);
    			}

    			if ((changed.colors) && path76_fill_value !== (path76_fill_value = ctx.colors[0])) {
    				attr(path76, "fill", path76_fill_value);
    			}

    			if ((changed.colors) && path77_fill_value !== (path77_fill_value = ctx.colors[0])) {
    				attr(path77, "fill", path77_fill_value);
    			}

    			if ((changed.colors) && path78_fill_value !== (path78_fill_value = ctx.colors[0])) {
    				attr(path78, "fill", path78_fill_value);
    			}

    			if ((changed.colors) && path79_fill_value !== (path79_fill_value = ctx.colors[0])) {
    				attr(path79, "fill", path79_fill_value);
    			}

    			if ((changed.colors) && path80_fill_value !== (path80_fill_value = ctx.colors[2])) {
    				attr(path80, "fill", path80_fill_value);
    			}

    			if ((changed.colors) && path81_fill_value !== (path81_fill_value = ctx.colors[3])) {
    				attr(path81, "fill", path81_fill_value);
    			}

    			if ((changed.colors) && path82_fill_value !== (path82_fill_value = ctx.colors[4])) {
    				attr(path82, "fill", path82_fill_value);
    			}

    			if ((changed.colors) && path83_fill_value !== (path83_fill_value = ctx.colors[1])) {
    				attr(path83, "fill", path83_fill_value);
    			}

    			if ((changed.colors) && path84_fill_value !== (path84_fill_value = ctx.colors[0])) {
    				attr(path84, "fill", path84_fill_value);
    			}

    			if ((changed.colors) && path85_fill_value !== (path85_fill_value = ctx.colors[1])) {
    				attr(path85, "fill", path85_fill_value);
    			}

    			if ((changed.colors) && path86_fill_value !== (path86_fill_value = ctx.colors[1])) {
    				attr(path86, "fill", path86_fill_value);
    			}

    			if ((changed.colors) && path87_fill_value !== (path87_fill_value = ctx.colors[1])) {
    				attr(path87, "fill", path87_fill_value);
    			}

    			if ((changed.colors) && path88_fill_value !== (path88_fill_value = ctx.colors[1])) {
    				attr(path88, "fill", path88_fill_value);
    			}

    			if ((changed.colors) && path89_fill_value !== (path89_fill_value = ctx.colors[1])) {
    				attr(path89, "fill", path89_fill_value);
    			}

    			if ((changed.colors) && path90_fill_value !== (path90_fill_value = ctx.colors[1])) {
    				attr(path90, "fill", path90_fill_value);
    			}

    			if ((changed.colors) && path91_fill_value !== (path91_fill_value = ctx.colors[1])) {
    				attr(path91, "fill", path91_fill_value);
    			}

    			if ((changed.colors) && path92_fill_value !== (path92_fill_value = ctx.colors[0])) {
    				attr(path92, "fill", path92_fill_value);
    			}

    			if ((changed.colors) && path93_fill_value !== (path93_fill_value = ctx.colors[1])) {
    				attr(path93, "fill", path93_fill_value);
    			}

    			if ((changed.colors) && path94_fill_value !== (path94_fill_value = ctx.colors[0])) {
    				attr(path94, "fill", path94_fill_value);
    			}

    			if ((changed.colors) && path95_fill_value !== (path95_fill_value = ctx.colors[0])) {
    				attr(path95, "fill", path95_fill_value);
    			}

    			if ((changed.colors) && path96_fill_value !== (path96_fill_value = ctx.colors[2])) {
    				attr(path96, "fill", path96_fill_value);
    			}

    			if ((changed.colors) && path97_fill_value !== (path97_fill_value = ctx.colors[0])) {
    				attr(path97, "fill", path97_fill_value);
    			}

    			if ((changed.colors) && path98_fill_value !== (path98_fill_value = ctx.colors[0])) {
    				attr(path98, "fill", path98_fill_value);
    			}

    			if ((changed.colors) && path99_fill_value !== (path99_fill_value = ctx.colors[1])) {
    				attr(path99, "fill", path99_fill_value);
    			}

    			if ((changed.colors) && path100_fill_value !== (path100_fill_value = ctx.colors[1])) {
    				attr(path100, "fill", path100_fill_value);
    			}

    			if ((changed.colors) && path101_fill_value !== (path101_fill_value = ctx.colors[0])) {
    				attr(path101, "fill", path101_fill_value);
    			}

    			if ((changed.colors) && path102_fill_value !== (path102_fill_value = ctx.colors[0])) {
    				attr(path102, "fill", path102_fill_value);
    			}

    			if ((changed.colors) && path103_fill_value !== (path103_fill_value = ctx.colors[2])) {
    				attr(path103, "fill", path103_fill_value);
    			}

    			if ((changed.colors) && path104_fill_value !== (path104_fill_value = ctx.colors[0])) {
    				attr(path104, "fill", path104_fill_value);
    			}

    			if ((changed.colors) && path105_fill_value !== (path105_fill_value = ctx.colors[1])) {
    				attr(path105, "fill", path105_fill_value);
    			}

    			if ((changed.colors) && path106_fill_value !== (path106_fill_value = ctx.colors[3])) {
    				attr(path106, "fill", path106_fill_value);
    			}

    			if ((changed.colors) && path107_fill_value !== (path107_fill_value = ctx.colors[3])) {
    				attr(path107, "fill", path107_fill_value);
    			}

    			if ((changed.colors) && path108_fill_value !== (path108_fill_value = ctx.colors[4])) {
    				attr(path108, "fill", path108_fill_value);
    			}

    			if ((changed.colors) && path109_fill_value !== (path109_fill_value = ctx.colors[0])) {
    				attr(path109, "fill", path109_fill_value);
    			}

    			if ((changed.colors) && path110_fill_value !== (path110_fill_value = ctx.colors[1])) {
    				attr(path110, "fill", path110_fill_value);
    			}

    			if ((changed.colors) && path111_fill_value !== (path111_fill_value = ctx.colors[1])) {
    				attr(path111, "fill", path111_fill_value);
    			}

    			if ((changed.colors) && path112_fill_value !== (path112_fill_value = ctx.colors[1])) {
    				attr(path112, "fill", path112_fill_value);
    			}

    			if ((changed.colors) && path113_fill_value !== (path113_fill_value = ctx.colors[3])) {
    				attr(path113, "fill", path113_fill_value);
    			}

    			if ((changed.colors) && path114_fill_value !== (path114_fill_value = ctx.colors[2])) {
    				attr(path114, "fill", path114_fill_value);
    			}

    			if ((changed.colors) && path115_fill_value !== (path115_fill_value = ctx.colors[0])) {
    				attr(path115, "fill", path115_fill_value);
    			}

    			if ((changed.colors) && path116_fill_value !== (path116_fill_value = ctx.colors[0])) {
    				attr(path116, "fill", path116_fill_value);
    			}

    			if ((changed.colors) && path117_fill_value !== (path117_fill_value = ctx.colors[0])) {
    				attr(path117, "fill", path117_fill_value);
    			}

    			if ((changed.colors) && path118_fill_value !== (path118_fill_value = ctx.colors[1])) {
    				attr(path118, "fill", path118_fill_value);
    			}

    			if ((changed.colors) && path119_fill_value !== (path119_fill_value = ctx.colors[3])) {
    				attr(path119, "fill", path119_fill_value);
    			}

    			if ((changed.colors) && path120_fill_value !== (path120_fill_value = ctx.colors[1])) {
    				attr(path120, "fill", path120_fill_value);
    			}

    			if ((changed.colors) && path121_fill_value !== (path121_fill_value = ctx.colors[1])) {
    				attr(path121, "fill", path121_fill_value);
    			}

    			if ((changed.colors) && path122_fill_value !== (path122_fill_value = ctx.colors[2])) {
    				attr(path122, "fill", path122_fill_value);
    			}

    			if ((changed.colors) && path123_fill_value !== (path123_fill_value = ctx.colors[0])) {
    				attr(path123, "fill", path123_fill_value);
    			}

    			if ((changed.colors) && path124_fill_value !== (path124_fill_value = ctx.colors[0])) {
    				attr(path124, "fill", path124_fill_value);
    			}

    			if ((changed.colors) && path125_fill_value !== (path125_fill_value = ctx.colors[0])) {
    				attr(path125, "fill", path125_fill_value);
    			}

    			if ((changed.colors) && path126_fill_value !== (path126_fill_value = ctx.colors[0])) {
    				attr(path126, "fill", path126_fill_value);
    			}

    			if ((changed.colors) && path127_fill_value !== (path127_fill_value = ctx.colors[4])) {
    				attr(path127, "fill", path127_fill_value);
    			}

    			if ((changed.colors) && path128_fill_value !== (path128_fill_value = ctx.colors[0])) {
    				attr(path128, "fill", path128_fill_value);
    			}

    			if ((changed.colors) && path129_fill_value !== (path129_fill_value = ctx.colors[1])) {
    				attr(path129, "fill", path129_fill_value);
    			}

    			if ((changed.colors) && path130_fill_value !== (path130_fill_value = ctx.colors[4])) {
    				attr(path130, "fill", path130_fill_value);
    			}

    			if ((changed.colors) && path131_fill_value !== (path131_fill_value = ctx.colors[0])) {
    				attr(path131, "fill", path131_fill_value);
    			}

    			if ((changed.colors) && path132_fill_value !== (path132_fill_value = ctx.colors[1])) {
    				attr(path132, "fill", path132_fill_value);
    			}

    			if ((changed.colors) && path133_fill_value !== (path133_fill_value = ctx.colors[1])) {
    				attr(path133, "fill", path133_fill_value);
    			}

    			if ((changed.colors) && path134_fill_value !== (path134_fill_value = ctx.colors[1])) {
    				attr(path134, "fill", path134_fill_value);
    			}

    			if ((changed.colors) && path135_fill_value !== (path135_fill_value = ctx.colors[0])) {
    				attr(path135, "fill", path135_fill_value);
    			}

    			if ((changed.colors) && path136_fill_value !== (path136_fill_value = ctx.colors[0])) {
    				attr(path136, "fill", path136_fill_value);
    			}

    			if ((changed.colors) && path137_fill_value !== (path137_fill_value = ctx.colors[0])) {
    				attr(path137, "fill", path137_fill_value);
    			}

    			if ((changed.colors) && path138_fill_value !== (path138_fill_value = ctx.colors[1])) {
    				attr(path138, "fill", path138_fill_value);
    			}

    			if (changed.styles) {
    				attr(svg, "style", ctx.styles);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(svg);
    			}
    		}
    	};
    }

    function instance($$self, $$props, $$invalidate) {

      let { colors, styles } = $$props;

    	const writable_props = ['colors', 'styles'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Aare> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('colors' in $$props) $$invalidate('colors', colors = $$props.colors);
    		if ('styles' in $$props) $$invalidate('styles', styles = $$props.styles);
    	};

    	return { colors, styles };
    }

    class Aare extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, ["colors", "styles"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.colors === undefined && !('colors' in props)) {
    			console.warn("<Aare> was created without expected prop 'colors'");
    		}
    		if (ctx.styles === undefined && !('styles' in props)) {
    			console.warn("<Aare> was created without expected prop 'styles'");
    		}
    	}

    	get colors() {
    		throw new Error("<Aare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colors(value) {
    		throw new Error("<Aare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Aare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Aare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/patterns/Clarence.svelte generated by Svelte v3.6.7 */

    const file$1 = "src/patterns/Clarence.svelte";

    function create_fragment$1(ctx) {
    	var svg, g2, g1, g0, path0, path0_fill_value, path1, path1_fill_value, path2, path2_fill_value, path3, path3_fill_value, path4, path4_fill_value, path5, path5_fill_value, path6, path6_fill_value, path7, path7_fill_value, path8, path8_fill_value, path9, path9_fill_value, path10, path10_fill_value, path11, path11_fill_value, path12, path12_fill_value;

    	return {
    		c: function create() {
    			svg = svg_element("svg");
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			attr(path0, "d", "M30.6611014,616.767081 C80.253118,749.104545 118.850817,886.059116 158.046246,1021.74913 C199.838372,1166.36947 199.955958,1318.52815 215.692923,1466.29518 C225.119424,1555.34359 243.600069,1641.15708 302.530396,1711.94292 C343.793384,1761.45674 393.277613,1794.80578 454.687052,1814.04862 C540.240875,1840.85921 633.310421,1841.40817 717.17884,1872.70843 C736.590376,1879.95268 756.227286,1889.71625 769.112784,1906.54761 C779.803337,1920.54597 784.898743,1938.13215 791.983317,1953.66955 C798.293781,1967.50127 808.93534,1973.01043 822.428366,1974.47104 C863.583567,1978.9117 916.448402,1954.14989 959.171419,1946.60175 C968.196167,1945.0039 979.74902,1943.30802 987.686094,1938.55367 C993.349833,1935.15211 993.183253,1930.31934 992.879488,1926.11395 C990.517964,1893.46091 991.997591,1859.20021 983.815545,1827.0275 C974.438039,1790.14946 951.038368,1764.64264 919.0353,1748.6053 C864.161699,1721.15753 793.384553,1719.11855 731.044223,1708.23747 C669.517199,1697.45442 607.578622,1685.69109 548.5993,1664.56611 C498.674122,1646.71525 451.884579,1621.4339 412.551966,1585.55574 C363.283311,1540.5708 336.669615,1478.43101 320.315322,1415.69325 C280.140007,1261.37797 283.471619,1095.99535 245.118892,939.405818 C226.040516,861.493361 201.866736,784.218085 178.026116,707.648609 C157.615096,642.077846 135.832236,575.938522 106.406268,514.357489 C98.1262337,497.01638 88.0236119,473.675972 69.5919613,464.363336 C60.6456047,459.844257 51.6208571,460.66769 42.9880639,462.294951 C30.1711586,464.716236 17.2954601,470.450859 9.60335717,481.26332 C-15.8736717,517.023844 15.7374418,581.555512 30.6611014,616.718067");
    			attr(path0, "fill", path0_fill_value = ctx.colors[1]);
    			attr(path0, "transform", "translate(496.500000, 1218.000000) rotate(-360.000000) translate(-496.500000, -1218.000000) ");
    			add_location(path0, file$1, 14, 8, 591);
    			attr(path1, "d", "M128.555583,510.760006 C158.964923,581.105776 182.821541,654.049683 205.295024,727.160262 C220.058268,775.201276 234.242754,823.467788 248.505715,871.675475 C270.272917,945.207639 283.378362,1020.54379 294.041249,1096.32114 C305.616418,1178.55951 314.955028,1261.93518 331.533023,1342.94802 C350.347576,1434.88283 380.580345,1522.59199 455.818938,1584.29038 C515.656672,1633.31182 589.002038,1660.28342 663.171399,1679.11746 C709.275882,1690.81398 756.02779,1699.49077 802.809126,1707.72637 C846.441624,1715.41294 892.075253,1719.41309 933.275004,1736.76668 C988.688669,1760.11069 1014.9388,1805.91632 1041.91482,1855.86917 C1051.91067,1874.37967 1068.40038,1887.14485 1086.37132,1896.6158 C1129.44468,1919.32253 1179.9438,1929.46997 1228.60855,1937.48988 C1234.96508,1938.53893 1241.55704,1939.56839 1248.37462,1940.34292 C1261.94934,1941.87162 1275.62238,1942.34364 1289.27028,1941.75474 C1290.25123,1941.75474 1291.23217,1941.68611 1292.21312,1941.61748 C1301.78716,1940.90177 1313.14652,1940.31351 1321.58266,1934.87213 C1326.56586,1931.65632 1326.40891,1926.40123 1325.50644,1921.21476 C1307.91807,1823.48561 1283.68869,1721.20727 1197.86569,1663.69531 C1146.85647,1629.49796 1082.97724,1624.88994 1022.80599,1615.43861 C953.766975,1604.65389 884.492537,1593.54563 816.463901,1578.79998 C732.985358,1560.71107 646.956354,1537.96512 572.208234,1494.54192 C493.938517,1449.05983 451.993247,1380.46903 423.428086,1297.36788 C386.838784,1190.92272 371.222116,1077.27141 349.759008,966.257446 C328.374375,855.635659 295.669621,748.48459 262.062395,641.255086 C241.854898,576.791889 220.793978,511.211003 191.512726,451.228366 C182.978492,433.747319 173.100362,416.383925 158.611782,402.716746 C148.174512,392.824219 135.2064,383.019931 121.031724,379.666864 C111.987398,377.558942 98.6661449,380.441403 92.8981797,388.412289 C82.0391025,403.393242 91.7995197,426.50195 97.5871038,441.649576 C106.592192,465.179868 117.843648,487.974839 128.585012,510.760006");
    			attr(path1, "fill", path1_fill_value = ctx.colors[2]);
    			attr(path1, "transform", "translate(707.000000, 1160.500000) rotate(-360.000000) translate(-707.000000, -1160.500000) ");
    			add_location(path1, file$1, 15, 8, 2356);
    			attr(path2, "d", "M197.910457,430.410511 C229.056402,493.25542 252.134009,559.51986 273.456776,626.097838 C288.162132,672.148832 302.161632,718.601546 316.337596,764.848501 C339.287756,839.735255 354.806809,916.464048 370.110183,993.212438 C386.835076,1077.02525 404.491307,1161.25937 430.362931,1242.30912 C445.587877,1289.98659 464.09702,1337.57589 490.566662,1380.57968 C517.604911,1424.48489 558.113267,1456.1131 602.876372,1480.59851 C694.049584,1530.45116 798.614473,1554.53485 899.708898,1574.66012 C953.873629,1585.43801 1008.37168,1594.41305 1062.88934,1603.18234 C1113.73066,1611.36374 1166.33662,1615.91985 1213.15848,1638.98454 C1287.42053,1675.4726 1330.14449,1746.38133 1369.64308,1815.69298 C1383.03476,1839.20838 1400.60276,1859.40223 1420.30793,1877.36212 C1463.54168,1916.76021 1509.29495,1948.03569 1564.96943,1968.17075 C1571.92733,1970.84092 1579.0536,1973.05027 1586.302,1974.78446 C1598.94861,1977.50833 1612.27166,1979.35037 1625.33002,1976.74408 C1626.0947,1976.59711 1626.83977,1976.41094 1627.55543,1976.22478 C1637.05509,1973.70667 1641.28043,1968.66066 1643.48623,1961.41008 C1644.90775,1956.74619 1643.18232,1950.44602 1640.72162,1943.94009 C1595.6252,1824.63863 1551.31306,1689.63083 1445.83643,1612.14759 C1391.3874,1572.15181 1325.95837,1566.60609 1260.07837,1557.11175 C1178.27737,1545.35405 1096.2803,1533.52776 1015.18516,1518.60528 C911.404559,1499.51861 804.241723,1477.53171 707.725565,1432.78387 C661.648781,1411.40445 618.062104,1382.0004 587.651426,1340.5937 C561.622945,1305.13443 541.878553,1264.32541 525.143857,1224.08468 C482.066965,1120.46015 455.989466,1010.17292 428.24536,901.110451 C401.69729,796.682475 368.551416,694.762809 334.484006,592.725565 C315.386649,535.534151 296.004989,477.215957 268.996151,424.198526 C260.653312,407.806332 250.68308,391.992225 238.261956,377.990763 C223.06642,360.863713 205.821939,341.336132 185.557957,332.223915 C177.371975,328.549633 164.450869,323.013716 156.147244,327.961748 C137.03028,339.317727 189.744082,415.086308 197.930064,430.508492");
    			attr(path2, "fill", path2_fill_value = ctx.colors[3]);
    			attr(path2, "transform", "translate(898.000000, 1152.000000) rotate(-360.000000) translate(-898.000000, -1152.000000) ");
    			add_location(path2, file$1, 16, 8, 4464);
    			attr(path3, "d", "M272.460994,394.897687 C305.117618,451.389571 328.641374,512.039163 350.056037,573.365364 C365.75162,618.256849 380.593757,663.795524 395.406464,708.951769 C420.225106,784.594607 438.118071,862.806596 458.277087,939.841874 C481.025873,1026.79093 507.855512,1113.31834 542.640849,1195.9626 C562.103373,1242.16808 584.145859,1288.67754 613.722224,1329.73491 C647.752212,1376.96021 696.555668,1408.80982 749.420356,1431.47129 C861.25139,1479.39281 984.638298,1501.23058 1103.97378,1521.12679 C1166.6384,1531.57009 1229.53845,1540.60134 1292.40908,1549.56394 C1340.94767,1556.48692 1393.10606,1559.04627 1438.79001,1578.06974 C1528.79438,1615.55776 1584.66085,1703.58547 1632.15961,1783.81748 C1647.12927,1809.12655 1663.4723,1833.61192 1680.76687,1857.45991 C1713.47254,1902.56713 1748.10092,1960.21611 1799.67072,1985.43692 C1804.57559,1987.85899 1809.8238,1990.27124 1814.82677,1991.32047 C1825.41148,1993.62486 1833.46528,1989.82017 1837.49708,1983.65225 C1837.85226,1983.15418 1838.17975,1982.63696 1838.47805,1982.10291 C1842.46081,1974.30721 1840.92068,1961.93214 1839.31188,1953.92071 C1837.7154,1946.80556 1835.30943,1939.89645 1832.14096,1933.32828 C1770.57504,1801.92901 1693.31352,1658.7136 1573.16383,1576.12817 C1519.39665,1539.17948 1459.37085,1532.60951 1394.68542,1524.20584 C1312.79372,1513.56643 1230.49981,1504.85877 1148.90239,1493.34663 C1044.1638,1478.56911 935.52093,1461.86963 837.354864,1420.0474 C741.71971,1379.29401 684.4014,1304.8475 646.761428,1211.24022 C606.32568,1110.67074 585.313218,1003.00178 557.796897,897.90197 C531.340029,797.09715 493.307668,701.087424 455.471501,604.30303 C434.459038,550.566609 412.720655,495.859401 383.958497,446.770984 C374.423373,430.692761 363.174715,415.693821 350.409187,402.036394 C326.610758,376.295864 300.53647,351.173106 270.606953,332.787013 C257.952389,325.010922 243.904842,316.32288 229.543382,312.478961 C212.866825,308.017269 233.03565,336.101413 235.497895,339.778632 C247.809118,358.164725 260.875692,376.001686 272.421755,394.897687");
    			attr(path3, "fill", path3_fill_value = ctx.colors[4]);
    			attr(path3, "transform", "translate(1032.000000, 1152.000000) rotate(-360.000000) translate(-1032.000000, -1152.000000) ");
    			add_location(path3, file$1, 17, 8, 6628);
    			attr(path4, "d", "M382.550514,406.428836 C422.375731,459.549206 454.171197,517.306213 480.799776,577.641308 C499.898625,620.939459 515.86989,666.443197 532.880415,710.211873 C561.479666,783.731485 575.578303,863.71102 592.206459,941.475165 C610.942547,1029.11054 631.217916,1118.01046 663.25849,1201.24446 C681.07297,1247.4834 701.495404,1292.56562 735.153693,1330.18806 C771.802306,1371.14338 818.078777,1399.04163 869.237808,1418.19594 C974.536388,1457.54363 1089.41381,1470.28703 1200.46753,1482.44227 C1258.67588,1488.84338 1316.99208,1494.29363 1375.19062,1500.79277 C1424.21231,1506.27243 1477.72438,1508.32118 1524.42244,1525.29931 C1616.82832,1558.84385 1689.88043,1640.85253 1752.02032,1713.39188 C1772.9918,1737.89842 1794.55153,1761.98344 1816.05245,1785.93123 C1867.15265,1842.7864 1914.69388,1919.50166 1991.39321,1944.16504 C1999.23668,1946.69412 2007.6488,1948.90951 2016.0217,1949 C2030.41447,1949.13497 2048.02306,1943.04754 2055.88614,1929.84342 C2056.42505,1928.96892 2056.90965,1928.0621 2057.33718,1927.1281 C2063.60215,1912.95352 2057.49405,1897.61242 2052.52325,1883.99659 C2049.49371,1875.70358 2044.10133,1867.1753 2038.89522,1860.07821 C1981.89281,1782.29446 1911.24275,1711.16669 1838.02396,1647.25364 C1760.84422,1579.80185 1677.63481,1516.19268 1587.79767,1468.32651 C1557.16892,1452.02476 1524.77539,1436.61505 1490.73474,1427.91033 C1459.03731,1419.81337 1424.84959,1418.49982 1392.309,1416.35304 C1317.86466,1411.45174 1243.03796,1411.21647 1168.64265,1408.51095 C1074.90339,1405.16826 976.477647,1401.14919 887.140527,1369.30049 C842.344511,1353.33203 801.029034,1327.49234 769.400243,1291.69319 C740.153905,1258.57996 726.682746,1214.65444 718.731429,1172.16991 C700.142406,1073.01645 708.015288,970.157616 702.446425,869.386734 C699.671798,819.128728 694.122543,768.615853 680.749427,719.975277 C668.454788,675.245945 647.630376,633.447595 626.688312,592.472665 C600.216602,540.636437 570.5977,489.074682 534.449109,444.325745 C522.288303,429.419348 508.547348,415.874724 493.46698,403.929169 C459.298865,376.638689 422.277688,350.338273 380.991625,334.987378 C366.069423,329.439098 349.509898,324.91029 334.234741,323.175227 C312.067135,320.646152 332.077787,346.230977 336.999564,352.387019 C351.70607,370.786528 367.932248,387.921499 382.550514,406.399428");
    			attr(path4, "fill", path4_fill_value = ctx.colors[5]);
    			attr(path4, "transform", "translate(1192.000000, 1136.000000) rotate(-360.000000) translate(-1192.000000, -1136.000000) ");
    			add_location(path4, file$1, 18, 8, 8791);
    			attr(path5, "d", "M512.307622,377.049904 C565.084289,425.843072 612.12436,479.742959 649.309258,540.543285 C673.726556,580.46586 697.359363,624.387553 709.813165,669.014973 C730.876762,744.488536 725.502995,827.803509 723.541767,907.060552 C721.374609,994.453057 718.236643,1083.28642 732.66148,1168.2971 C740.447559,1214.17914 757.588698,1256.51295 792.871204,1289.13321 C825.996357,1319.78332 866.093679,1340.35722 909.299549,1352.65843 C1000.24173,1378.53508 1098.14627,1376.31008 1191.80475,1375.26129 C1242.12007,1374.69279 1292.4452,1373.57539 1342.76052,1374.45755 C1388.0453,1375.25149 1436.33075,1375.02605 1480.53685,1385.92561 C1603.64318,1416.31107 1718.10049,1495.88177 1820.81004,1566.60148 C1857.03393,1591.54696 1893.65988,1616.34542 1929.56017,1641.67317 C1987.41642,1682.4779 2042.33083,1727.78164 2099.86347,1769.34111 C2149.59043,1805.27437 2203.56344,1837.55157 2264.10657,1849.9802 C2277.17816,1852.66589 2291.30882,1854.9791 2304.13525,1853.57745 C2322.12953,1851.6171 2348.81204,1845.04012 2351.79311,1822.32944 C2351.97433,1821.03091 2352.0367,1819.71858 2351.97943,1818.40873 C2350.99881,1795.9921 2329.50375,1775.72206 2315.13775,1760.9018 C2306.01522,1751.63215 2296.39421,1742.86619 2286.31749,1734.64288 C2182.97054,1648.91667 2065.39488,1576.53066 1948.14281,1509.20236 C1828.29212,1440.49202 1704.35227,1375.61416 1576.27423,1325.64478 C1504.94434,1297.81758 1436.58571,1278.85117 1359.3231,1279.5765 C1294.3672,1280.21361 1229.60743,1288.21185 1165.16145,1294.27914 C1085.2708,1301.80689 1000.07502,1310.05017 921.772964,1286.8396 C880.175302,1274.50899 841.421422,1250.73971 812.297174,1218.45271 C782.878743,1185.91086 774.474878,1141.10701 774.827899,1099.56715 C775.661421,1000.84381 810.463426,901.571566 828.398863,802.867828 C836.900789,756.08402 843.225752,708.153406 839.705346,660.526647 C836.283002,614.262333 819.622364,574.614208 798.901982,534.083924 C770.728931,478.919611 737.388042,425.137345 697.192658,378.794617 C683.623779,363.196726 668.385591,349.132188 651.750988,336.85288 C607.62334,304.19341 556.856934,275.248809 500.383352,270.602774 C482.545976,269.13251 461.649083,269.926452 445.361079,277.826672 C399.25259,300.18449 495.78427,362.425675 512.307622,377.049904");
    			attr(path5, "fill", path5_fill_value = ctx.colors[0]);
    			attr(path5, "transform", "translate(1392.500000, 1062.000000) rotate(-360.000000) translate(-1392.500000, -1062.000000) ");
    			add_location(path5, file$1, 19, 8, 11219);
    			attr(path6, "d", "M643.996761,279.471182 C705.210281,332.252449 762.30432,389.80795 805.460783,457.353071 C831.491977,498.10562 857.856652,544.81861 865.124593,592.129604 C877.600734,673.291585 851.304716,761.237489 831.109453,842.007336 C809.325248,929.110151 776.751926,1024.34975 785.991333,1112.18782 C790.542378,1155.64609 807.569564,1190.77152 843.37962,1219.11302 C874.948222,1243.9748 912.307988,1260.43101 951.967167,1266.94359 C1028.47181,1279.76638 1108.08567,1264.67901 1183.66833,1252.23856 C1262.94872,1239.23931 1345.0735,1223.4363 1425.68782,1232.43578 C1482.8407,1238.80796 1538.99315,1261.36548 1592.17368,1282.07017 C1672.327,1313.28405 1750.65598,1349.34079 1827.82759,1386.96607 C1877.10442,1410.97449 1926.48915,1435.38485 1975.13825,1460.6579 C2071.85777,1510.90009 2166.24291,1566.08318 2261.96199,1618.55074 C2332.65031,1657.30341 2407.66409,1699.47744 2486.94448,1716.18236 C2497.94937,1718.49595 2510.13127,1720.18213 2521.13617,1717.95677 C2544.40142,1713.24136 2535.07374,1683.18427 2528.32564,1670.7144 C2527.31466,1668.92313 2526.2012,1667.1916 2524.99082,1665.52842 C2504.65824,1636.61833 2473.41885,1614.55097 2444.64133,1595.16974 C2431.2236,1586.11144 2417.11928,1577.32763 2403.1817,1568.80852 C2270.76983,1487.85241 2131.35484,1416.19968 1990.86093,1349.0761 C1861.02864,1287.04047 1728.63638,1226.85767 1592.64448,1180.62504 C1525.27135,1157.7244 1462.02752,1140.05876 1390.32894,1145.4506 C1331.70481,1149.86211 1273.99285,1163.00841 1216.55552,1174.39011 C1144.68039,1188.63438 1067.65591,1203.97664 994.66264,1187.55602 C955.331409,1178.733 917.412571,1157.9989 889.07643,1129.24566 C857.591828,1097.30632 849.274401,1053.89706 851.128167,1011.95831 C855.502663,913.326748 899.590914,814.401086 929.800438,717.700786 C944.767884,669.831001 958.921242,620.696582 963.148614,570.513205 C966.875763,526.672598 959.146833,489.086533 940.118756,450.265244 C913.791283,396.524051 879.618589,346.992281 838.720684,303.293337 C824.349729,288.125391 809.017121,273.897467 792.817901,260.697756 C741.079186,218.219816 679.934325,180.829818 614.012827,164.536641 C597.387781,160.438838 575.073928,156.782186 559.08642,164.585658 C509.476104,188.799946 627.558072,265.717074 644.006569,279.471182");
    			attr(path6, "fill", path6_fill_value = ctx.colors[6]);
    			attr(path6, "transform", "translate(1541.500000, 939.500000) rotate(-360.000000) translate(-1541.500000, -939.500000) ");
    			add_location(path6, file$1, 20, 8, 13579);
    			attr(path7, "d", "M1429.441,60.3618885 C1488.10716,99.9003527 1505.38904,155.846936 1516.60608,222.392065 C1530.34522,303.677024 1550.78711,383.332947 1586.64628,457.149856 C1610.1991,505.716712 1641.35753,566.609283 1687.50143,598.463801 C1740.81913,635.264308 1819.92718,617.168272 1876.21842,600.956422 C1959.93889,576.844731 2046.76049,538.876421 2122.27672,492.919949 C2151.92384,474.882794 2168.74448,465.187087 2197.73408,486.24679 C2201.84601,489.190831 2207.06689,493.400809 2212.71956,490.446955 C2217.06702,488.180044 2220.5705,482.174201 2223.97585,476.560897 C2231.38332,464.15012 2239.75047,452.337914 2249.00072,441.232411 C2257.41104,431.2423 2268,418.612366 2268,404.696868 C2268,395.560529 2263.53478,389.132707 2259.75651,384.333921 C2253.18135,375.963032 2238.74543,351.05645 2224.97684,356.679567 C2213.33782,361.439099 2202.64092,371.507718 2191.61035,378.808938 C2162.62075,398.05315 2131.64878,414.902875 2100.89272,430.359088 C1997.56453,482.301776 1848.19056,544.941145 1743.58659,461.438342 C1670.36675,402.969697 1621.61241,325.708261 1604.47773,234.747222 C1593.00554,173.815397 1585.76305,113.060214 1553.29941,59.0861376 C1541.14027,38.8802062 1524.83975,22.4328331 1504.76097,11.2552926 C1484.27001,-0.128330744 1453.56302,-4.9565572 1431.57057,6.75091061 C1412.46335,16.9569177 1412.56148,47.7908355 1429.441,60.3618885 Z");
    			attr(path7, "fill", path7_fill_value = ctx.colors[2]);
    			attr(path7, "transform", "translate(1842.500000, 310.000000) rotate(-360.000000) translate(-1842.500000, -310.000000) ");
    			add_location(path7, file$1, 21, 8, 15937);
    			attr(path8, "d", "M1317.74422,80.0164729 C1303.03462,80.290881 1293.32629,95.3441231 1298.32755,108.280503 C1299.3013,110.638386 1300.76925,112.760405 1302.63256,114.503686 C1335.10154,143.982952 1362.06913,181.831663 1376.08247,223.120276 C1382.25069,241.31941 1387.23234,260.126163 1391.90018,278.893714 C1400.72594,314.341355 1409.83608,349.994802 1418.03423,385.579647 C1427.14437,425.104208 1435.68574,465.118784 1445.49214,504.437538 C1449.80695,521.656644 1454.40615,539.012954 1459.2211,556.075255 C1474.29353,608.996809 1492.82762,661.536152 1517.76528,710.282784 C1536.15227,746.24004 1558.03034,777.238351 1600.44301,785.745 C1643.23812,794.320252 1690.44611,784.38276 1731.40743,774.082658 C1844.76937,745.55402 1955.77778,692.906874 2064.37381,646.914123 C2083.6826,638.740683 2105.99215,626.833333 2125.96778,628.803191 C2142.63866,630.449639 2158.32889,639.044492 2174.2937,647.061127 C2177.64749,648.736976 2181.3347,650.461827 2184.90422,650.853839 C2187.51175,651.251645 2190.15773,650.431613 2192.08251,648.629173 C2195.41668,645.483281 2197.14261,638.740683 2198.49589,632.047086 C2200.68272,621.26677 2202.75186,610.39825 2204.77198,599.568932 C2205.48785,595.776221 2206.1841,592.032511 2206.91958,588.367203 C2209.68499,574.529197 2211.88162,559.064343 2207.56681,545.245937 C2204.95148,537.138666 2200.47494,529.755122 2194.49488,523.685304 C2182.66837,511.023332 2164.90898,489.119688 2144.48226,493.461216 C2129.13525,496.724712 2114.52372,505.054956 2100.28483,511.856356 C2068.28656,527.125205 2035.77836,541.580629 2003.58396,556.271261 C1965.24095,573.774575 1926.24091,590.797675 1886.88784,605.184497 C1826.8727,627.097941 1754.39362,652.010273 1689.11244,640.465534 C1632.03922,630.322236 1594.79452,579.04713 1566.16965,533.907004 C1528.42483,474.389856 1506.47812,406.973676 1491.01343,337.744442 C1483.84496,305.687701 1478.66718,272.690132 1471.33199,240.897998 C1464.96764,213.300388 1456.50472,185.830181 1443.67796,161.133455 C1433.85996,142.086545 1420.21215,125.270951 1403.58941,111.740005 C1380.8778,93.1684592 1347.40857,79.4578565 1317.74422,80.0164729 Z");
    			attr(path8, "fill", path8_fill_value = ctx.colors[7]);
    			attr(path8, "transform", "translate(1753.500000, 434.500000) rotate(-360.000000) translate(-1753.500000, -434.500000) ");
    			add_location(path8, file$1, 22, 8, 17424);
    			attr(path9, "d", "M1196.10352,127.277529 C1186.0127,126.297566 1167.90224,127.189333 1168,142.163174 C1168.09666,143.95155 1168.6879,145.678223 1169.70838,147.151188 C1192.93296,185.94794 1225.07045,218.139738 1243.24963,259.846982 C1251.62265,279.064064 1258.95518,299.045519 1265.75765,318.919177 C1278.51841,356.520374 1290.70003,395.170131 1301.52704,433.114315 C1313.65958,475.625128 1322.32708,519.988073 1331.4363,563.694441 C1335.59828,583.617098 1339.74061,603.588752 1344.04001,623.47221 C1357.18359,684.141746 1371.96645,744.987675 1392.82538,803.128905 C1407.32357,843.542597 1422.52851,893.177744 1459.36785,919.675955 C1497.48326,947.114931 1548.80115,941.019559 1591.88345,934.267611 C1738.8776,911.189472 1876.44843,841.935457 2021.75424,807.695535 C2050.56411,800.914188 2083.15313,791.124353 2111.91392,798.385882 C2135.55078,804.363659 2158.1177,817.759759 2180.81222,827.255605 C2185.17051,829.078337 2189.93126,830.656078 2194.319,830.891269 C2197.41103,831.057863 2200.26747,830.313091 2202.32883,827.784785 C2205.13619,824.354913 2205.98037,817.436371 2206,810.341436 C2206,798.513277 2205.34233,786.596922 2204.23313,774.758964 C2203.8503,770.623518 2203.34969,766.507672 2202.88834,762.519221 C2201.17054,747.52578 2198.38281,731.669972 2191.58034,718.195475 C2187.17662,709.833445 2181.36226,702.291674 2174.39258,695.901307 C2155.25143,678.457958 2134.52992,659.289874 2106.66238,660.622624 C2087.03044,661.602587 2067.98746,668.668124 2049.49417,674.587103 C2013.00821,686.258467 1977.09157,698.909795 1941.51849,712.991869 C1899.37853,729.651247 1857.10115,747.212192 1814.63726,762.764212 C1747.22118,787.439691 1670.3425,815.339249 1597.04665,812.673749 C1523.16184,809.988649 1493.23294,749.95609 1465.18872,691.207282 C1426.51379,610.164307 1403.71129,522.085194 1384.18733,433.917885 C1375.98118,396.875267 1367.2057,359.803251 1357.81182,323.182018 C1350.37131,294.165301 1342.03755,264.893793 1329.86575,238.140792 C1320.95406,218.504783 1308.88831,200.454492 1294.14543,184.703386 C1269.16379,157.999383 1231.39193,130.580006 1196.10352,127.277529 Z");
    			attr(path9, "fill", path9_fill_value = ctx.colors[5]);
    			attr(path9, "transform", "translate(1687.000000, 533.500000) rotate(-360.000000) translate(-1687.000000, -533.500000) ");
    			add_location(path9, file$1, 23, 8, 19657);
    			attr(path10, "d", "M1067.67551,152.948473 C1054.79581,147.708359 1036.71715,140.685626 1023.1508,145.749437 C1022.13004,146.066086 1021.356,146.902431 1021.12026,147.943429 C1019.15839,163.516853 1041.71993,183.252984 1050.84264,194.281711 C1068.23464,215.232373 1086.28387,236.104679 1100.87039,258.926112 C1113.62257,278.858135 1125.66847,299.671673 1136.56667,320.63213 C1157.63693,361.3998 1175.50763,403.738339 1190.0179,447.266594 C1204.83985,491.596981 1216.14023,534.438589 1221.50596,581.080503 C1223.8602,601.570819 1225.58665,622.413741 1227.14634,643.08036 C1231.84503,705.148779 1234.72898,768.284811 1246.47079,828.942807 C1255.29922,874.49752 1267.8552,924.861385 1292.91813,965.087833 C1319.57998,1007.89026 1363.54555,1030.41786 1410.97383,1035.609 C1582.88294,1054.51259 1758.03895,954.010133 1930.17367,936.16436 C1987.88217,930.179856 2044.32525,943.667029 2097.05058,966.586407 C2148.31432,988.859342 2197.31209,1022.82704 2250.20419,1042.06364 C2256.41351,1044.3164 2261.82828,1045.57991 2265.44794,1044.73757 C2267.97875,1044.1401 2269.42073,1042.18118 2268.89103,1037.5973 C2268.27304,1032.22006 2264.79071,1023.28738 2260.71002,1013.97271 C2254.06908,998.810662 2246.97691,983.6682 2239.76702,968.780399 C2237.29506,963.696998 2234.86234,958.799695 2232.48847,954.08849 C2224.38594,937.80006 2216.18531,920.688883 2205.35577,906.516088 C2198.63751,897.534092 2191.00421,889.272201 2182.57843,881.863064 C2155.75963,858.777177 2126.66505,835.926361 2090.08593,832.498249 C2028.75779,826.748815 1957.3358,847.483996 1899.90198,864.036881 C1854.61214,877.093091 1809.3125,892.323703 1764.08152,906.153687 C1688.8535,929.08286 1609.09356,953.020878 1529.57885,954.206025 C1493.4902,954.744728 1459.02991,946.811097 1432.80947,920.649704 C1407.56017,895.457977 1394.0821,859.57054 1380.66289,827.522589 C1340.57202,731.780314 1315.53852,630.229837 1290.15189,529.325804 C1279.36159,486.307894 1265.83447,443.956017 1253.27849,401.398453 C1243.82226,369.281939 1234.0129,336.842204 1220.96644,306.478925 C1211.84927,285.104337 1200.16224,264.916338 1186.16282,246.359632 C1155.74398,206.182157 1113.84818,171.734528 1067.67551,152.948473 Z");
    			attr(path10, "fill", path10_fill_value = ctx.colors[4]);
    			attr(path10, "transform", "translate(1645.000000, 594.500000) rotate(-360.000000) translate(-1645.000000, -594.500000) ");
    			add_location(path10, file$1, 24, 8, 21876);
    			attr(path11, "d", "M913.663303,138.487064 C896.186996,129.236032 876.288327,119.642006 856.00718,117.24105 C854.115255,117 852.202721,116.935403 850.299429,117.074453 C831.185331,117.858439 869.658706,152.353812 873.150045,155.626953 C895.21609,176.422175 918.66494,196.080619 939.338373,218.061619 C957.452144,237.32807 975.10498,257.574502 991.384817,278.330525 C1022.35574,317.843408 1049.70783,360.903826 1070.82258,406.375001 C1091.93733,451.846175 1098.96905,495.033991 1095.99748,544.846487 C1094.72256,566.308097 1091.92753,588.249899 1088.65194,609.67231 C1078.62906,675.027323 1062.4669,740.784129 1055.00368,806.29594 C1049.60975,853.531082 1049.58033,901.138618 1058.48521,948.452159 C1068.44925,1001.4594 1094.26162,1042.53045 1139.81575,1067.88259 C1229.57061,1117.74409 1346.47161,1094.6753 1445.6119,1072.57671 C1536.81822,1052.26167 1635.87024,1014.53236 1730.38157,1021.12764 C1845.66439,1029.17329 1961.76121,1085.97306 2063.46116,1135.92276 C2123.54945,1165.43002 2182.86298,1197.33824 2242.17651,1228.78587 C2288.83884,1253.54022 2336.03075,1281.24432 2384.80162,1299.60918 C2393.45151,1302.87252 2403.17037,1306.85125 2412.60483,1307 C2417.01804,1307.06685 2419.8425,1305.12648 2418.77352,1299.87378 C2417.00823,1291.20094 2411.43778,1282.63589 2407.00496,1274.96263 C2396.73689,1257.26415 2384.61528,1240.09486 2372.17003,1223.62136 C2367.71759,1217.74147 2363.30438,1212.08697 2358.9304,1206.65787 C2343.89607,1187.96961 2327.95948,1169.58514 2310.33607,1153.54284 C2296.84288,1141.31098 2282.66156,1129.85921 2267.86139,1119.24346 C2199.14282,1069.81316 2124.67727,1027.18393 2045.98485,997.657066 C2003.29441,981.624557 1958.09334,968.463396 1911.9606,964.93546 C1870.49605,961.770117 1827.92329,968.620193 1787.76309,976.901043 C1742.35607,986.269673 1696.96867,999.019241 1651.82645,1010.73003 C1575.92906,1030.43747 1497.96237,1049.76272 1418.89728,1049.31193 C1381.28693,1049.09633 1343.06854,1041.71707 1311.76418,1019.91246 C1278.06687,996.392889 1259.51178,962.818698 1245.83083,926.049766 C1206.8671,821.250468 1199.01159,708.209521 1188.03741,595.854561 C1182.71214,541.396949 1173.10115,490.575072 1154.95796,439.126006 C1142.20869,403.052861 1127.58625,366.999315 1109.78631,333.425125 C1097.4178,310.225586 1083.13144,288.09905 1067.07625,267.276326 C1026.05303,213.945694 972.319754,169.523101 913.663303,138.487064 Z");
    			attr(path11, "fill", path11_fill_value = ctx.colors[8]);
    			attr(path11, "transform", "translate(1632.000000, 712.000000) rotate(-360.000000) translate(-1632.000000, -712.000000) ");
    			add_location(path11, file$1, 25, 8, 24166);
    			attr(path12, "d", "M984.232997,536.790632 C976.620143,627.932834 936.88811,717.859806 907.58451,805.483722 C878.859722,891.382797 843.120513,1004.07572 893.369272,1082.50701 C936.603609,1149.98164 1035.74729,1167.02425 1114.64236,1162.00653 C1195.9802,1156.82221 1275.14996,1134.37967 1354.61402,1117.81727 C1391.61877,1110.10448 1428.9865,1103.23451 1466.75646,1100.74525 C1509.49047,1097.94239 1548.5652,1104.66535 1589.57259,1116.60204 C1740.83881,1160.7031 1885.84602,1231.40201 2025.98727,1301.69911 C2133.97011,1355.88462 2240.62854,1413.51981 2347.76768,1469.85157 C2388.74563,1491.41209 2429.76283,1512.97261 2471.58447,1532.89649 C2496.62055,1544.80378 2523.27535,1558.73972 2550.74441,1563.48303 C2557.69997,1564.68846 2563.34094,1563.94364 2563.84127,1559.56294 C2566.3331,1537.74761 2538.87385,1508.06269 2524.52127,1491.48069 C2500.28964,1463.48142 2470.17177,1440.08825 2439.93619,1418.38073 C2257.13941,1287.11636 2047.17769,1180.97979 1835.12636,1102.5779 C1768.61199,1077.9891 1693.54298,1048.15718 1621.39745,1049.40181 C1561.28927,1050.44064 1501.85799,1064.86659 1443.56472,1078.26351 C1317.01084,1107.35061 1090.01831,1160.92851 1038.17046,1001.62566 C1010.58367,916.853612 1023.21944,818.684641 1036.5125,728.199055 C1049.00111,643.084 1074.21379,548.668519 1057.65387,463.935673 C1044.46872,396.461043 999.645101,330.005638 955.233518,278.074183 C903.846756,218.008533 837.33239,170.369582 765.77549,136.891973 C745.781939,127.542547 722.894326,117.771711 700.399128,117.036694 C662.138652,115.782263 693.384707,147.035218 706.285355,158.031084 C731.527459,179.532803 760.242436,196.928223 785.74942,217.812528 C848.830154,269.440175 907.309819,328.143593 948.111183,398.381889 C974.108686,443.168971 988.569184,484.868978 984.232997,536.790632 Z");
    			attr(path12, "fill", path12_fill_value = ctx.colors[4]);
    			attr(path12, "transform", "translate(1623.000000, 840.500000) rotate(-360.000000) translate(-1623.000000, -840.500000) ");
    			add_location(path12, file$1, 26, 8, 26654);
    			attr(g0, "transform", "translate(-310.000000, -500.000000)");
    			attr(g0, "id", "Shape");
    			add_location(g0, file$1, 13, 6, 520);
    			attr(g1, "id", "Clarence");
    			attr(g1, "fill-rule", "nonzero");
    			add_location(g1, file$1, 12, 4, 476);
    			attr(g2, "id", "Patterns");
    			attr(g2, "stroke", "none");
    			attr(g2, "stroke-width", "1");
    			attr(g2, "fill", "none");
    			attr(g2, "fill-rule", "evenodd");
    			add_location(g2, file$1, 11, 2, 391);
    			attr(svg, "viewBox", "0 0 1600 1200");
    			attr(svg, "version", "1.1");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr(svg, "style", ctx.styles);
    			add_location(svg, file$1, 10, 0, 250);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g2);
    			append(g2, g1);
    			append(g1, g0);
    			append(g0, path0);
    			append(g0, path1);
    			append(g0, path2);
    			append(g0, path3);
    			append(g0, path4);
    			append(g0, path5);
    			append(g0, path6);
    			append(g0, path7);
    			append(g0, path8);
    			append(g0, path9);
    			append(g0, path10);
    			append(g0, path11);
    			append(g0, path12);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colors) && path0_fill_value !== (path0_fill_value = ctx.colors[1])) {
    				attr(path0, "fill", path0_fill_value);
    			}

    			if ((changed.colors) && path1_fill_value !== (path1_fill_value = ctx.colors[2])) {
    				attr(path1, "fill", path1_fill_value);
    			}

    			if ((changed.colors) && path2_fill_value !== (path2_fill_value = ctx.colors[3])) {
    				attr(path2, "fill", path2_fill_value);
    			}

    			if ((changed.colors) && path3_fill_value !== (path3_fill_value = ctx.colors[4])) {
    				attr(path3, "fill", path3_fill_value);
    			}

    			if ((changed.colors) && path4_fill_value !== (path4_fill_value = ctx.colors[5])) {
    				attr(path4, "fill", path4_fill_value);
    			}

    			if ((changed.colors) && path5_fill_value !== (path5_fill_value = ctx.colors[0])) {
    				attr(path5, "fill", path5_fill_value);
    			}

    			if ((changed.colors) && path6_fill_value !== (path6_fill_value = ctx.colors[6])) {
    				attr(path6, "fill", path6_fill_value);
    			}

    			if ((changed.colors) && path7_fill_value !== (path7_fill_value = ctx.colors[2])) {
    				attr(path7, "fill", path7_fill_value);
    			}

    			if ((changed.colors) && path8_fill_value !== (path8_fill_value = ctx.colors[7])) {
    				attr(path8, "fill", path8_fill_value);
    			}

    			if ((changed.colors) && path9_fill_value !== (path9_fill_value = ctx.colors[5])) {
    				attr(path9, "fill", path9_fill_value);
    			}

    			if ((changed.colors) && path10_fill_value !== (path10_fill_value = ctx.colors[4])) {
    				attr(path10, "fill", path10_fill_value);
    			}

    			if ((changed.colors) && path11_fill_value !== (path11_fill_value = ctx.colors[8])) {
    				attr(path11, "fill", path11_fill_value);
    			}

    			if ((changed.colors) && path12_fill_value !== (path12_fill_value = ctx.colors[4])) {
    				attr(path12, "fill", path12_fill_value);
    			}

    			if (changed.styles) {
    				attr(svg, "style", ctx.styles);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(svg);
    			}
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {

      let { colors, styles } = $$props;

    	const writable_props = ['colors', 'styles'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Clarence> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('colors' in $$props) $$invalidate('colors', colors = $$props.colors);
    		if ('styles' in $$props) $$invalidate('styles', styles = $$props.styles);
    	};

    	return { colors, styles };
    }

    class Clarence extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["colors", "styles"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.colors === undefined && !('colors' in props)) {
    			console.warn("<Clarence> was created without expected prop 'colors'");
    		}
    		if (ctx.styles === undefined && !('styles' in props)) {
    			console.warn("<Clarence> was created without expected prop 'styles'");
    		}
    	}

    	get colors() {
    		throw new Error("<Clarence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colors(value) {
    		throw new Error("<Clarence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Clarence>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Clarence>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/patterns/Doubs.svelte generated by Svelte v3.6.7 */

    const file$2 = "src/patterns/Doubs.svelte";

    function create_fragment$2(ctx) {
    	var svg, g2, g1, g0, path0, path0_fill_value, path1, path1_fill_value, path2, path2_fill_value, path3, path3_fill_value, path4, path4_fill_value, path5, path5_fill_value, path6, path6_fill_value, path7, path7_fill_value, path8, path8_fill_value, path9, path9_fill_value, path10, path10_fill_value, path11, path11_fill_value, path12, path12_fill_value;

    	return {
    		c: function create() {
    			svg = svg_element("svg");
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			attr(path0, "d", "M3536.17828,2368.75435 C3083.69103,2394.80536 3279.87894,2965.06174 3670,3161 C3324.89223,3161 2528,2835.91795 2528,2438.40894 C2528,2040.89992 2566.208,1649 2911.30991,1649 C3256.41768,1649 3536.17828,1971.24533 3536.17828,2368.75435 Z");
    			attr(path0, "fill", path0_fill_value = ctx.colors[0]);
    			add_location(path0, file$2, 14, 8, 590);
    			attr(path1, "d", "M4293,1444.25024 C4293,1904.99405 4035.97462,2074 3759.17986,2074 C3482.3851,2074 3258,1700.49357 3258,1239.74976 C3258,779.005951 3515.01952,610 3791.82014,610 C4068.6149,610 4293,983.506431 4293,1444.25024 Z");
    			attr(path1, "fill", path1_fill_value = ctx.colors[1]);
    			add_location(path1, file$2, 15, 8, 872);
    			attr(path2, "d", "M3284.9363,506.038941 C3917.61468,569.323633 4155.34704,1388.18345 4110.77647,1836.04784 C4066.20591,2283.91223 3811.81059,1776.56644 3179.13221,1713.28175 C2546.45384,1649.99706 2651.09417,1498.42594 2695.66473,1050.56155 C2245.97658,1145.67421 2652.25793,442.746673 3284.9363,506.038941 Z");
    			attr(path2, "fill", path2_fill_value = ctx.colors[2]);
    			add_location(path2, file$2, 16, 8, 1127);
    			attr(path3, "d", "M3589.18896,999.922335 C3934.4545,1034.36896 4033.84682,1705.68024 4009.52113,1949.42846 C3985.19545,2193.17668 3846.37046,1917.0594 3501.10493,1882.61277 C3155.83939,1848.172 2970.44579,1734.24822 2994.76562,1490.5 C3019.09131,1246.75178 3243.92342,965.48156 3589.18896,999.922335 Z");
    			attr(path3, "fill", path3_fill_value = ctx.colors[3]);
    			attr(path3, "opacity", "0.1");
    			add_location(path3, file$2, 17, 8, 1463);
    			attr(path4, "d", "M3555.02938,1179.65668 C3781.63155,1202.26972 3606.97928,1744.91297 3585.53572,1959.83346 C3564.09801,2174.75395 3478.82096,1934.99129 3252.21294,1912.37824 C3025.61078,1889.75934 2707.59167,1799.57131 2729.02938,1584.65668 C2750.46709,1369.73619 3328.42137,1157.04363 3555.02938,1179.65668 Z");
    			attr(path4, "fill", path4_fill_value = ctx.colors[0]);
    			add_location(path4, file$2, 18, 8, 1806);
    			attr(path5, "d", "M4043.56369,1918.059 C4278.96672,2342.46469 4033.34684,2972.36986 3754.57193,3127.98606 C3475.79116,3283.59641 3081.28379,2820.9652 2883.60001,2467.09686 C2685.92208,2113.22852 3055.96987,1369.29605 3496.83928,1478.91294 C3726.90568,1536.11962 3928.60363,1710.79886 4043.56369,1918.059 Z");
    			attr(path5, "fill", path5_fill_value = ctx.colors[4]);
    			add_location(path5, file$2, 19, 8, 2144);
    			attr(path6, "d", "M4021.93901,2529.75238 C4034.71738,2822.14218 3931.13763,3029.55204 3761.67492,3124.19611 C3592.2122,3218.84018 3345.13642,2956.02849 3232.2335,2722.25019 C2991.38293,2223.53409 3315.27533,1558.97561 3668.03325,1827.89621 C3884.47492,1992.89517 4010.03908,2257.38784 4021.93901,2529.75238 Z");
    			attr(path6, "fill", path6_fill_value = ctx.colors[3]);
    			attr(path6, "opacity", "0.1");
    			add_location(path6, file$2, 20, 8, 2477);
    			attr(path7, "d", "M4250.17294,2387.10602 C4262.9445,2679.55885 4125.6064,2966.60447 3990.04766,2981.67791 C3803.03982,3002.4632 3750.63665,2774.0593 3745.15226,2585.81413 C3739.52153,2392.54839 3891.33445,1894.02354 3990.04766,2326.58379 C4062.9778,2646.15475 4238.27936,2114.68275 4250.17294,2387.10602 Z");
    			attr(path7, "fill", path7_fill_value = ctx.colors[5]);
    			add_location(path7, file$2, 21, 8, 2827);
    			attr(path8, "d", "M3643.17769,2432.95667 C3466.42383,2773.6564 2721.04973,3200.95131 2021.99837,3029 C1322.94702,2857.04869 2339.286,2766.46197 2339.286,2369.23808 C2339.286,1972.01419 2563.69581,1650 2908.25708,1650 C3056.43491,1650 3192.53211,1709.49913 3299.55041,1808.97606 C3520.87282,1950.41799 3752.27765,2222.66408 3643.17769,2432.95667 Z");
    			attr(path8, "fill", path8_fill_value = ctx.colors[6]);
    			add_location(path8, file$2, 22, 8, 3160);
    			attr(path9, "d", "M2543.63582,2518.84557 C2145.16551,2619.69964 1562.94565,2582.86181 1671.18097,2279.4114 C1850.16663,1777.61875 2283.27205,1442.05632 2819,1509.64298 C3029.7879,1536.23119 3231.49617,1701.31755 3331.94405,1854.85313 C3562.95489,2207.95548 3151.63574,2364.95533 2543.63582,2518.84557 Z");
    			attr(path9, "fill", path9_fill_value = ctx.colors[7]);
    			add_location(path9, file$2, 23, 8, 3534);
    			attr(path10, "d", "M2417.45789,1200.18191 C2814.38238,1274.5566 3356.92746,1597.35509 3122.58898,2071.46755 C2992.64058,2334.37851 2411.06718,2555.97026 2209.56718,2465.97026 C1875.56156,2316.78661 1777.20593,1080.21632 2417.45789,1200.18191 Z");
    			attr(path10, "fill", path10_fill_value = ctx.colors[8]);
    			add_location(path10, file$2, 24, 8, 3864);
    			attr(path11, "d", "M2758,1754.99031 C2758,2165.35772 2264.69158,2769 1869.81059,2769 C1474.92374,2769 1328,2165.35772 1328,1754.99031 C1328,1344.62876 1474.92374,1011 1869.81059,1011 C2264.69158,1011 2758,1344.62876 2758,1754.99031 Z");
    			attr(path11, "fill", path11_fill_value = ctx.colors[0]);
    			attr(path11, "transform", "translate(2043.000000, 1890.000000) rotate(35.000000) translate(-2043.000000, -1890.000000) ");
    			add_location(path11, file$2, 25, 8, 4134);
    			attr(path12, "d", "M2504,1694.1445 C2504,2104.04672 2100.91061,2707 1778.24478,2707 C1455.57895,2707 1115,2238.90222 1115,1829 C1115,1419.10363 1455.57895,951 1778.24478,951 C2100.91061,951 2504,1284.24813 2504,1694.1445 Z");
    			attr(path12, "fill", path12_fill_value = ctx.colors[2]);
    			attr(path12, "transform", "translate(1809.500000, 1829.000000) rotate(47.000000) translate(-1809.500000, -1829.000000) ");
    			add_location(path12, file$2, 26, 8, 4499);
    			attr(g0, "transform", "translate(-2340.000000, -1578.000000)");
    			attr(g0, "id", "Shape");
    			add_location(g0, file$2, 13, 6, 517);
    			attr(g1, "id", "Doubs");
    			attr(g1, "fill-rule", "nonzero");
    			add_location(g1, file$2, 12, 4, 476);
    			attr(g2, "id", "Patterns");
    			attr(g2, "stroke", "none");
    			attr(g2, "stroke-width", "1");
    			attr(g2, "fill", "none");
    			attr(g2, "fill-rule", "evenodd");
    			add_location(g2, file$2, 11, 2, 391);
    			attr(svg, "viewBox", "0 0 1600 1200");
    			attr(svg, "version", "1.1");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr(svg, "style", ctx.styles);
    			add_location(svg, file$2, 10, 0, 250);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g2);
    			append(g2, g1);
    			append(g1, g0);
    			append(g0, path0);
    			append(g0, path1);
    			append(g0, path2);
    			append(g0, path3);
    			append(g0, path4);
    			append(g0, path5);
    			append(g0, path6);
    			append(g0, path7);
    			append(g0, path8);
    			append(g0, path9);
    			append(g0, path10);
    			append(g0, path11);
    			append(g0, path12);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colors) && path0_fill_value !== (path0_fill_value = ctx.colors[0])) {
    				attr(path0, "fill", path0_fill_value);
    			}

    			if ((changed.colors) && path1_fill_value !== (path1_fill_value = ctx.colors[1])) {
    				attr(path1, "fill", path1_fill_value);
    			}

    			if ((changed.colors) && path2_fill_value !== (path2_fill_value = ctx.colors[2])) {
    				attr(path2, "fill", path2_fill_value);
    			}

    			if ((changed.colors) && path3_fill_value !== (path3_fill_value = ctx.colors[3])) {
    				attr(path3, "fill", path3_fill_value);
    			}

    			if ((changed.colors) && path4_fill_value !== (path4_fill_value = ctx.colors[0])) {
    				attr(path4, "fill", path4_fill_value);
    			}

    			if ((changed.colors) && path5_fill_value !== (path5_fill_value = ctx.colors[4])) {
    				attr(path5, "fill", path5_fill_value);
    			}

    			if ((changed.colors) && path6_fill_value !== (path6_fill_value = ctx.colors[3])) {
    				attr(path6, "fill", path6_fill_value);
    			}

    			if ((changed.colors) && path7_fill_value !== (path7_fill_value = ctx.colors[5])) {
    				attr(path7, "fill", path7_fill_value);
    			}

    			if ((changed.colors) && path8_fill_value !== (path8_fill_value = ctx.colors[6])) {
    				attr(path8, "fill", path8_fill_value);
    			}

    			if ((changed.colors) && path9_fill_value !== (path9_fill_value = ctx.colors[7])) {
    				attr(path9, "fill", path9_fill_value);
    			}

    			if ((changed.colors) && path10_fill_value !== (path10_fill_value = ctx.colors[8])) {
    				attr(path10, "fill", path10_fill_value);
    			}

    			if ((changed.colors) && path11_fill_value !== (path11_fill_value = ctx.colors[0])) {
    				attr(path11, "fill", path11_fill_value);
    			}

    			if ((changed.colors) && path12_fill_value !== (path12_fill_value = ctx.colors[2])) {
    				attr(path12, "fill", path12_fill_value);
    			}

    			if (changed.styles) {
    				attr(svg, "style", ctx.styles);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(svg);
    			}
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {

      let { colors, styles } = $$props;

    	const writable_props = ['colors', 'styles'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Doubs> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('colors' in $$props) $$invalidate('colors', colors = $$props.colors);
    		if ('styles' in $$props) $$invalidate('styles', styles = $$props.styles);
    	};

    	return { colors, styles };
    }

    class Doubs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["colors", "styles"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.colors === undefined && !('colors' in props)) {
    			console.warn("<Doubs> was created without expected prop 'colors'");
    		}
    		if (ctx.styles === undefined && !('styles' in props)) {
    			console.warn("<Doubs> was created without expected prop 'styles'");
    		}
    	}

    	get colors() {
    		throw new Error("<Doubs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colors(value) {
    		throw new Error("<Doubs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Doubs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Doubs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/patterns/Hinterrhein.svelte generated by Svelte v3.6.7 */

    const file$3 = "src/patterns/Hinterrhein.svelte";

    function create_fragment$3(ctx) {
    	var svg, g3, g2, g1, ellipse0, ellipse0_stroke_value, path0, path0_stroke_value, path1, path1_stroke_value, path2, path2_stroke_value, path3, path3_stroke_value, path4, path4_stroke_value, path5, path5_stroke_value, path6, path6_stroke_value, path7, path7_stroke_value, path8, path8_stroke_value, path9, path9_stroke_value, path10, path10_stroke_value, path11, path11_stroke_value, path12, path12_stroke_value, path13, path13_stroke_value, path14, path14_stroke_value, path15, path15_stroke_value, path16, path16_stroke_value, path17, path17_stroke_value, path18, path18_stroke_value, circle, circle_stroke_value, path19, path19_stroke_value, path20, path20_stroke_value, path21, path21_stroke_value, path22, path22_stroke_value, path23, path23_stroke_value, path24, path24_stroke_value, path25, path25_stroke_value, ellipse1, ellipse1_stroke_value, path26, path26_stroke_value, path27, path27_stroke_value, path28, path28_stroke_value, path29, path29_stroke_value, path30, path30_stroke_value, path31, path31_stroke_value, path32, path32_stroke_value, ellipse2, ellipse2_stroke_value, path33, path33_stroke_value, path34, path34_stroke_value, path35, path35_stroke_value, path36, path36_stroke_value, ellipse3, ellipse3_stroke_value, path37, path37_stroke_value, path38, path38_stroke_value, path39, path39_stroke_value, path40, path40_stroke_value, path41, path41_stroke_value, path42, path42_stroke_value, path43, path43_stroke_value, path44, path44_stroke_value, path45, path45_stroke_value, path46, path46_stroke_value, path47, path47_stroke_value, path48, path48_stroke_value, path49, path49_stroke_value, path50, path50_stroke_value, path51, path51_stroke_value, path52, path52_stroke_value, ellipse4, ellipse4_stroke_value, path53, path53_stroke_value, path54, path54_stroke_value, path55, path55_stroke_value, ellipse5, ellipse5_stroke_value, g0, path56, path56_stroke_value, path57, path57_stroke_value, path58, path58_stroke_value, path59, path59_stroke_value, path60, path60_stroke_value, path61, path61_stroke_value, path62, path62_stroke_value, path63, path63_stroke_value, path64, path64_stroke_value, path65, path65_stroke_value, path66, path66_stroke_value, path67, path67_stroke_value, path68, path68_stroke_value, path69, path69_stroke_value, path70, path70_stroke_value;

    	return {
    		c: function create() {
    			svg = svg_element("svg");
    			g3 = svg_element("g");
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			ellipse0 = svg_element("ellipse");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			path13 = svg_element("path");
    			path14 = svg_element("path");
    			path15 = svg_element("path");
    			path16 = svg_element("path");
    			path17 = svg_element("path");
    			path18 = svg_element("path");
    			circle = svg_element("circle");
    			path19 = svg_element("path");
    			path20 = svg_element("path");
    			path21 = svg_element("path");
    			path22 = svg_element("path");
    			path23 = svg_element("path");
    			path24 = svg_element("path");
    			path25 = svg_element("path");
    			ellipse1 = svg_element("ellipse");
    			path26 = svg_element("path");
    			path27 = svg_element("path");
    			path28 = svg_element("path");
    			path29 = svg_element("path");
    			path30 = svg_element("path");
    			path31 = svg_element("path");
    			path32 = svg_element("path");
    			ellipse2 = svg_element("ellipse");
    			path33 = svg_element("path");
    			path34 = svg_element("path");
    			path35 = svg_element("path");
    			path36 = svg_element("path");
    			ellipse3 = svg_element("ellipse");
    			path37 = svg_element("path");
    			path38 = svg_element("path");
    			path39 = svg_element("path");
    			path40 = svg_element("path");
    			path41 = svg_element("path");
    			path42 = svg_element("path");
    			path43 = svg_element("path");
    			path44 = svg_element("path");
    			path45 = svg_element("path");
    			path46 = svg_element("path");
    			path47 = svg_element("path");
    			path48 = svg_element("path");
    			path49 = svg_element("path");
    			path50 = svg_element("path");
    			path51 = svg_element("path");
    			path52 = svg_element("path");
    			ellipse4 = svg_element("ellipse");
    			path53 = svg_element("path");
    			path54 = svg_element("path");
    			path55 = svg_element("path");
    			ellipse5 = svg_element("ellipse");
    			g0 = svg_element("g");
    			path56 = svg_element("path");
    			path57 = svg_element("path");
    			path58 = svg_element("path");
    			path59 = svg_element("path");
    			path60 = svg_element("path");
    			path61 = svg_element("path");
    			path62 = svg_element("path");
    			path63 = svg_element("path");
    			path64 = svg_element("path");
    			path65 = svg_element("path");
    			path66 = svg_element("path");
    			path67 = svg_element("path");
    			path68 = svg_element("path");
    			path69 = svg_element("path");
    			path70 = svg_element("path");
    			attr(ellipse0, "stroke", ellipse0_stroke_value = ctx.colors[0]);
    			attr(ellipse0, "stroke-linejoin", "round");
    			attr(ellipse0, "cx", "1847");
    			attr(ellipse0, "cy", "110.5");
    			attr(ellipse0, "rx", "38");
    			attr(ellipse0, "ry", "37.5");
    			add_location(ellipse0, file$3, 14, 8, 555);
    			attr(path0, "d", "M1609,971.95215 C1609,916.747664 1658.24555,872 1719,872 C1740.09181,872 1759.80569,877.393271 1776.54448,886.751028 M1829,1040 L1829,971.95215 C1829,950.174953 1821.33523,930.022804 1808.32313,913.607477");
    			attr(path0, "stroke", path0_stroke_value = ctx.colors[1]);
    			attr(path0, "stroke-linejoin", "round");
    			add_location(path0, file$3, 15, 8, 667);
    			attr(path1, "d", "M1872,280 L1908.54783,280 C1933.09826,280 1953,260.971806 1953,237.5 C1953,214.028194 1933.09826,195 1908.54783,195 L1835.45217,195 C1810.90174,195 1791,214.028194 1791,237.5");
    			attr(path1, "stroke", path1_stroke_value = ctx.colors[1]);
    			attr(path1, "stroke-linejoin", "round");
    			add_location(path1, file$3, 16, 8, 943);
    			attr(path2, "d", "M1258.95215,220 C1203.74766,220 1159,170.751317 1159,110 C1159,88.9050534 1164.39327,69.1966548 1173.75103,52.455516 M1327,-1.48858703e-12 L1258.95215,-1.48858703e-12 C1237.17495,-1.48858703e-12 1217.0228,7.66382918 1200.60748,20.674363");
    			attr(path2, "stroke", path2_stroke_value = ctx.colors[0]);
    			attr(path2, "stroke-linejoin", "round");
    			add_location(path2, file$3, 17, 8, 1189);
    			attr(path3, "d", "M1535.5,1120 L1532.36486,1120 C1510.07405,1120 1492,1138.13456 1492,1160.5 C1492,1182.86544 1510.07405,1201 1532.36486,1201 L1625.63514,1201 C1647.92595,1201 1666,1182.86544 1666,1160.5 C1666,1138.13456 1647.92595,1120 1625.63514,1120 L1622.5,1120");
    			attr(path3, "stroke", path3_stroke_value = ctx.colors[2]);
    			attr(path3, "stroke-linejoin", "round");
    			add_location(path3, file$3, 18, 8, 1497);
    			attr(path4, "d", "M1182,1205 C1156.04033,1205 1135,1183.95967 1135,1158 C1135,1132.04033 1156.04033,1111 1182,1111");
    			attr(path4, "stroke", path4_stroke_value = ctx.colors[3]);
    			attr(path4, "stroke-linejoin", "round");
    			add_location(path4, file$3, 19, 8, 1816);
    			attr(path5, "d", "M1582.56338,228 C1604.34028,228 1622,210.53903 1622,189 C1622,167.46097 1604.34028,150 1582.56338,150 L1538,150");
    			attr(path5, "stroke", path5_stroke_value = ctx.colors[1]);
    			attr(path5, "stroke-linejoin", "round");
    			add_location(path5, file$3, 20, 8, 1984);
    			attr(path6, "d", "M331,10 L108.050265,10 C64.3920468,10 29,45.3695515 29,89");
    			attr(path6, "stroke", path6_stroke_value = ctx.colors[2]);
    			attr(path6, "stroke-linejoin", "round");
    			add_location(path6, file$3, 21, 8, 2167);
    			attr(path7, "d", "M1743,1205 L1743,1052.9203 C1743,1023.14038 1718.82522,999 1689,999 C1659.17478,999 1635,1023.14038 1635,1052.9203 L1635,1076.45757");
    			attr(path7, "stroke", path7_stroke_value = ctx.colors[3]);
    			attr(path7, "stroke-linejoin", "round");
    			add_location(path7, file$3, 22, 8, 2296);
    			attr(path8, "d", "M206,406 C257.914633,406 300,364.586653 300,313.5 C300,262.413347 257.914633,221 206,221 C154.085367,221 112,262.413347 112,313.5");
    			attr(path8, "stroke", path8_stroke_value = ctx.colors[1]);
    			attr(path8, "stroke-linejoin", "round");
    			add_location(path8, file$3, 23, 8, 2499);
    			attr(path9, "d", "M281.380368,105.5 C281.380368,129.524541 262.04373,149 238.190184,149 C214.336638,149 195,129.524541 195,105.5 C195,81.4754595 214.336638,62 238.190184,62 L323,62");
    			attr(path9, "stroke", path9_stroke_value = ctx.colors[0]);
    			attr(path9, "stroke-linejoin", "round");
    			add_location(path9, file$3, 24, 8, 2700);
    			attr(path10, "d", "M862,98.5 L862,40.1526549 C862,23.4997743 875.433766,10 892,10 C908.566234,10 922,23.4997743 922,40.1526549 L922,156.847345 C922,173.500226 908.566234,187 892,187 C875.433766,187 862,173.500226 862,156.847345 L862,142.75");
    			attr(path10, "stroke", path10_stroke_value = ctx.colors[1]);
    			attr(path10, "stroke-linejoin", "round");
    			add_location(path10, file$3, 25, 8, 2934);
    			attr(path11, "d", "M806,19 L806,170.829094 C806,216.21096 842.936429,253 888.5,253 C934.063571,253 971,216.21096 971,170.829094 L971,134.957208");
    			attr(path11, "stroke", path11_stroke_value = ctx.colors[3]);
    			attr(path11, "stroke-linejoin", "round");
    			add_location(path11, file$3, 26, 8, 3226);
    			attr(path12, "d", "M1394,62 L1573.97897,62 C1642.47299,62 1698,117.740764 1698,186.5 C1698,255.259236 1642.47299,311 1573.97897,311 L1519.83093,311");
    			attr(path12, "stroke", path12_stroke_value = ctx.colors[3]);
    			attr(path12, "stroke-linejoin", "round");
    			add_location(path12, file$3, 27, 8, 3422);
    			attr(path13, "d", "M1877,316 L1877,398.011565 C1877,433.351043 1848.08459,462 1812.41096,462 L1762,462");
    			attr(path13, "stroke", path13_stroke_value = ctx.colors[2]);
    			attr(path13, "stroke-linejoin", "round");
    			add_location(path13, file$3, 28, 8, 3622);
    			attr(path14, "d", "M634,366 L634,420.993352 C634,460.761599 666.235652,493 706,493");
    			attr(path14, "stroke", path14_stroke_value = ctx.colors[3]);
    			attr(path14, "stroke-linejoin", "round");
    			add_location(path14, file$3, 29, 8, 3777);
    			attr(path15, "d", "M523,755 L523,668.920385 C523,619.356033 561.840526,577.837138 614,567");
    			attr(path15, "stroke", path15_stroke_value = ctx.colors[1]);
    			attr(path15, "stroke-linejoin", "round");
    			add_location(path15, file$3, 30, 8, 3912);
    			attr(path16, "d", "M1516.5,445.5 L1621.81017,445.5 C1682.44741,445.5 1733.2418,492.876905 1746.5,556.5");
    			attr(path16, "stroke", path16_stroke_value = ctx.colors[2]);
    			add_location(path16, file$3, 31, 8, 4054);
    			attr(path17, "d", "M1732,326.3 C1732,300.177109 1753.26901,279 1779.5,279 C1805.73099,279 1827,300.177109 1827,326.3 L1827,360.7 C1827,386.822891 1805.73099,408 1779.5,408 C1753.26901,408 1732,386.822891 1732,360.7 L1732,326.3 Z");
    			attr(path17, "stroke", path17_stroke_value = ctx.colors[3]);
    			attr(path17, "stroke-linejoin", "round");
    			add_location(path17, file$3, 32, 8, 4185);
    			attr(path18, "d", "M746.99922,373 L747,172.197372 C747,132.876519 715.212286,101 676,101");
    			attr(path18, "stroke", path18_stroke_value = ctx.colors[1]);
    			attr(path18, "stroke-linejoin", "round");
    			add_location(path18, file$3, 33, 8, 4466);
    			attr(circle, "stroke", circle_stroke_value = ctx.colors[3]);
    			attr(circle, "stroke-linejoin", "round");
    			attr(circle, "cx", "1419");
    			attr(circle, "cy", "221");
    			attr(circle, "r", "32");
    			add_location(circle, file$3, 34, 8, 4607);
    			attr(path19, "d", "M1419,311 C1469.80749,311 1511,270.481857 1511,220.5 C1511,170.518143 1469.80749,130 1419,130 C1368.19251,130 1327,170.518143 1327,220.5");
    			attr(path19, "stroke", path19_stroke_value = ctx.colors[1]);
    			attr(path19, "stroke-linejoin", "round");
    			add_location(path19, file$3, 35, 8, 4704);
    			attr(path20, "d", "M1263.5,72 C1242.78906,72 1226,88.7889474 1226,109.5 C1226,130.211053 1242.78906,147 1263.5,147 C1284.21094,147 1301,130.211053 1301,109.5 L1301,72");
    			attr(path20, "stroke", path20_stroke_value = ctx.colors[2]);
    			attr(path20, "stroke-linejoin", "round");
    			add_location(path20, file$3, 36, 8, 4912);
    			attr(path21, "d", "M1115.5,817.758427 C1091.47703,817.758427 1072,837.059551 1072,860.875281 C1072,884.691011 1091.47703,904 1115.5,904 C1139.52297,904 1159,884.691011 1159,860.875281 L1159,729");
    			attr(path21, "stroke", path21_stroke_value = ctx.colors[0]);
    			attr(path21, "stroke-linejoin", "round");
    			add_location(path21, file$3, 37, 8, 5131);
    			attr(path22, "d", "M945.831409,1111.5 C945.831409,1133.31495 963.333949,1151 984.91963,1151 C1006.50531,1151 1024,1133.31495 1024,1111.5 C1024,1089.68505 1006.50531,1072 984.91963,1072 L854,1072");
    			attr(path22, "stroke", path22_stroke_value = ctx.colors[1]);
    			attr(path22, "stroke-linejoin", "round");
    			add_location(path22, file$3, 38, 8, 5377);
    			attr(path23, "d", "M781.791855,1127 L881.208145,1127 C901.529774,1127 918,1143.5634 918,1164 C918,1184.4366 901.529774,1201 881.208145,1201 L781.791855,1201 C761.472575,1201 745,1184.4366 745,1164 C745,1143.5634 761.472575,1127 781.791855,1127 Z");
    			attr(path23, "stroke", path23_stroke_value = ctx.colors[0]);
    			attr(path23, "stroke-linejoin", "round");
    			add_location(path23, file$3, 39, 8, 5624);
    			attr(path24, "d", "M597,267 C597,316.705826 556.705826,357 507,357 C457.294174,357 417,316.705826 417,267");
    			attr(path24, "stroke", path24_stroke_value = ctx.colors[1]);
    			attr(path24, "stroke-linejoin", "round");
    			add_location(path24, file$3, 40, 8, 5922);
    			attr(path25, "d", "M675,312 L675,202.002021 C675,180.461549 657.53892,163 636,163 C614.46108,163 597,180.461549 597,202.002021 L597,219.027911");
    			attr(path25, "stroke", path25_stroke_value = ctx.colors[2]);
    			attr(path25, "stroke-linejoin", "round");
    			add_location(path25, file$3, 41, 8, 6080);
    			attr(ellipse1, "stroke", ellipse1_stroke_value = ctx.colors[2]);
    			attr(ellipse1, "stroke-linejoin", "round");
    			attr(ellipse1, "cx", "444");
    			attr(ellipse1, "cy", "429.5");
    			attr(ellipse1, "rx", "27");
    			attr(ellipse1, "ry", "26.5");
    			add_location(ellipse1, file$3, 42, 8, 6275);
    			attr(path26, "d", "M467,250.225 L467,139.775 C467,118.360233 484.46097,101 506,101 C527.53903,101 545,118.360233 545,139.775 L545,250.225 C545,271.639767 527.53903,289 506,289 C484.46097,289 467,271.639767 467,250.225 Z");
    			attr(path26, "stroke", path26_stroke_value = ctx.colors[0]);
    			attr(path26, "stroke-linejoin", "round");
    			add_location(path26, file$3, 43, 8, 6386);
    			attr(path27, "d", "M1360,312 L1271.92522,312 C1216.18783,312 1171,357.219031 1171,413");
    			attr(path27, "stroke", path27_stroke_value = ctx.colors[1]);
    			attr(path27, "stroke-linejoin", "round");
    			add_location(path27, file$3, 44, 8, 6658);
    			attr(path28, "d", "M205.5,353.509804 C226.210938,353.509804 243,336.830588 243,316.254902 C243,295.679216 226.210938,279 205.5,279 C184.789062,279 168,295.679216 168,316.254902 L168,559");
    			attr(path28, "stroke", path28_stroke_value = ctx.colors[2]);
    			attr(path28, "stroke-linejoin", "round");
    			add_location(path28, file$3, 45, 8, 6796);
    			attr(path29, "d", "M1447.5,506 C1425.68505,506 1408,523.46108 1408,545 C1408,566.53892 1425.68505,584 1447.5,584 C1469.31495,584 1487,566.53892 1487,545 L1487,506");
    			attr(path29, "stroke", path29_stroke_value = ctx.colors[1]);
    			attr(path29, "stroke-linejoin", "round");
    			add_location(path29, file$3, 46, 8, 7034);
    			attr(path30, "d", "M1689,690.754093 C1689,746.670617 1734.8933,792 1791.5,792 C1848.1067,792 1894,746.670617 1894,690.754093 L1894,582");
    			attr(path30, "stroke", path30_stroke_value = ctx.colors[3]);
    			attr(path30, "stroke-linejoin", "round");
    			add_location(path30, file$3, 47, 8, 7249);
    			attr(path31, "d", "M1635.62574,738 L1630.52959,738 C1601.52071,738 1578,714.494888 1578,685.5 C1578,656.505112 1601.52071,633 1630.52959,633 L1790.47041,633 C1819.47929,633 1843,656.505112 1843,685.5 C1843,714.494888 1819.47929,738 1790.47041,738 L1788.90237,738");
    			attr(path31, "stroke", path31_stroke_value = ctx.colors[2]);
    			attr(path31, "stroke-linejoin", "round");
    			add_location(path31, file$3, 48, 8, 7436);
    			attr(path32, "d", "M1538,506 L1602.53071,506 C1645.87071,506 1681,540.92216 1681,584");
    			attr(path32, "stroke", path32_stroke_value = ctx.colors[3]);
    			attr(path32, "stroke-linejoin", "round");
    			add_location(path32, file$3, 49, 8, 7751);
    			attr(ellipse2, "stroke", ellipse2_stroke_value = ctx.colors[2]);
    			attr(ellipse2, "stroke-linejoin", "round");
    			attr(ellipse2, "cx", "869");
    			attr(ellipse2, "cy", "862.5");
    			attr(ellipse2, "rx", "38");
    			attr(ellipse2, "ry", "37.5");
    			add_location(ellipse2, file$3, 50, 8, 7888);
    			attr(path33, "d", "M776.403578,840.520014 C762.460481,892.643707 792.620681,946.025666 843.760284,959.7565 C894.899888,973.487334 947.656493,942.360965 961.597235,890.237272 C975.537978,838.113579 945.380133,784.73162 894.240529,771");
    			attr(path33, "stroke", path33_stroke_value = ctx.colors[0]);
    			attr(path33, "stroke-linejoin", "round");
    			add_location(path33, file$3, 51, 8, 7999);
    			attr(path34, "d", "M845.65848,770.60169 L660.398666,770.60169 C624.696229,770.582931 595.7394,741.080367 595.722595,704.701923 C595.705848,668.32348 624.633252,638.846139 660.335552,638.864352 C696.037852,638.882633 724.996214,668.384786 725.011456,704.763641 L664.692251,704.763641 L664.692251,704.763641");
    			attr(path34, "stroke", path34_stroke_value = ctx.colors[2]);
    			add_location(path34, file$3, 52, 8, 8284);
    			attr(path35, "d", "M841.5,557 C841.5,565.958167 841.5,678.732452 841.5,734");
    			attr(path35, "stroke", path35_stroke_value = ctx.colors[3]);
    			attr(path35, "stroke-linejoin", "round");
    			add_location(path35, file$3, 53, 8, 8618);
    			attr(path36, "d", "M501.019608,1112 C484.992157,1112 472,1099.24137 472,1083.5 C472,1067.75863 484.992157,1055 501.019608,1055 L532,1055");
    			attr(path36, "stroke", path36_stroke_value = ctx.colors[0]);
    			attr(path36, "stroke-linejoin", "round");
    			add_location(path36, file$3, 54, 8, 8745);
    			attr(ellipse3, "stroke", ellipse3_stroke_value = ctx.colors[1]);
    			attr(ellipse3, "stroke-linejoin", "round");
    			attr(ellipse3, "cx", "327.5");
    			attr(ellipse3, "cy", "1114");
    			attr(ellipse3, "rx", "41.5");
    			attr(ellipse3, "ry", "41");
    			add_location(ellipse3, file$3, 55, 8, 8934);
    			attr(path37, "d", "M415,1113 C415,1062.19251 374.481857,1021 324.5,1021 C274.518143,1021 234,1062.19251 234,1113 C234,1163.80749 274.518143,1205 324.5,1205");
    			attr(path37, "stroke", path37_stroke_value = ctx.colors[2]);
    			attr(path37, "stroke-linejoin", "round");
    			add_location(path37, file$3, 56, 8, 9046);
    			attr(path38, "d", "M569,1055 L606.905196,1055 C632.362692,1055 653,1035.30214 653,1011 C653,986.697857 632.362692,967 606.905196,967 L531.094804,967 C505.637308,967 485,986.697857 485,1011");
    			attr(path38, "stroke", path38_stroke_value = ctx.colors[2]);
    			attr(path38, "stroke-linejoin", "round");
    			add_location(path38, file$3, 57, 8, 9254);
    			attr(path39, "d", "M416,992 C416,945.611589 453.444786,908 499.636143,908 L647,908");
    			attr(path39, "stroke", path39_stroke_value = ctx.colors[2]);
    			attr(path39, "stroke-linejoin", "round");
    			add_location(path39, file$3, 58, 8, 9495);
    			attr(path40, "d", "M368.5,908 C368.5,912.248462 368.5,965.766154 368.5,992");
    			attr(path40, "stroke", path40_stroke_value = ctx.colors[1]);
    			attr(path40, "stroke-linejoin", "round");
    			add_location(path40, file$3, 59, 8, 9630);
    			attr(path41, "d", "M786.5,657 C786.5,660.694923 786.5,707.20575 786.5,730");
    			attr(path41, "stroke", path41_stroke_value = ctx.colors[1]);
    			attr(path41, "stroke-linejoin", "round");
    			add_location(path41, file$3, 60, 8, 9757);
    			attr(path42, "d", "M902.084977,450.5 C902.084977,473.419745 883.712534,492 861.042489,492 C838.372443,492 820,473.419745 820,450.5 C820,427.580255 838.372443,409 861.042489,409 L993,409");
    			attr(path42, "stroke", path42_stroke_value = ctx.colors[1]);
    			attr(path42, "stroke-linejoin", "round");
    			add_location(path42, file$3, 61, 8, 9883);
    			attr(path43, "d", "M1046,539.5 L1046,481.152655 C1046,464.499774 1059.43377,451 1076,451 C1092.56623,451 1106,464.499774 1106,481.152655 L1106,597.847345 C1106,614.500226 1092.56623,628 1076,628 C1059.43377,628 1046,614.500226 1046,597.847345 L1046,583.75");
    			attr(path43, "stroke", path43_stroke_value = ctx.colors[0]);
    			attr(path43, "stroke-linejoin", "round");
    			add_location(path43, file$3, 62, 8, 10121);
    			attr(path44, "d", "M994,451 L994,602.829094 C994,648.21096 1030.93643,685 1076.5,685 C1122.06357,685 1159,648.21096 1159,602.829094 L1159,566.957208");
    			attr(path44, "stroke", path44_stroke_value = ctx.colors[3]);
    			attr(path44, "stroke-linejoin", "round");
    			add_location(path44, file$3, 63, 8, 10429);
    			attr(path45, "d", "M1007,316 L963.695312,316 C932.382812,316 907,341.519603 907,373");
    			attr(path45, "stroke", path45_stroke_value = ctx.colors[2]);
    			attr(path45, "stroke-linejoin", "round");
    			add_location(path45, file$3, 64, 8, 10630);
    			attr(path46, "d", "M1045.5,273 C1045.5,279.070225 1045.5,371.552576 1045.5,409");
    			attr(path46, "stroke", path46_stroke_value = ctx.colors[1]);
    			attr(path46, "stroke-linejoin", "round");
    			add_location(path46, file$3, 65, 8, 10766);
    			attr(path47, "d", "M1294,495.14852 L1294,508.33208 C1294,526.9265 1278.8282,542 1260.12442,542 C1241.41279,542 1226.24099,526.9265 1226.24099,508.33208 L1226.24099,497.41208 C1226.24099,478.95884 1211.18692,464 1192.62442,464 C1174.05407,464 1159,478.95884 1159,497.41208 L1159,510.85148");
    			attr(path47, "stroke", path47_stroke_value = ctx.colors[3]);
    			attr(path47, "stroke-linejoin", "round");
    			add_location(path47, file$3, 66, 8, 10897);
    			attr(path48, "d", "M222.5,769.081301 C201.789062,769.081301 185,785.855203 185,806.54065 C185,827.226098 201.789062,844 222.5,844 C243.210938,844 260,827.226098 260,806.54065 L260,747");
    			attr(path48, "stroke", path48_stroke_value = ctx.colors[2]);
    			attr(path48, "stroke-linejoin", "round");
    			add_location(path48, file$3, 67, 8, 11237);
    			attr(path49, "d", "M265,692 L265,632.934418 C265,598.924545 291.889975,570.435873 328,563");
    			attr(path49, "stroke", path49_stroke_value = ctx.colors[0]);
    			attr(path49, "stroke-linejoin", "round");
    			add_location(path49, file$3, 68, 8, 11473);
    			attr(path50, "d", "M222.5,605 C222.5,597.128807 222.5,511.561646 222.5,463");
    			attr(path50, "stroke", path50_stroke_value = ctx.colors[3]);
    			attr(path50, "stroke-linejoin", "round");
    			add_location(path50, file$3, 69, 8, 11615);
    			attr(path51, "d", "M319,672.879245 C319,646.436558 340.490623,625 367,625 C393.509377,625 415,646.436558 415,672.879245 L415,785.120755 C415,811.564226 393.509377,833 367,833 C340.490623,833 319,811.564226 319,785.120755 L319,672.879245 Z");
    			attr(path51, "stroke", path51_stroke_value = ctx.colors[3]);
    			attr(path51, "stroke-linejoin", "round");
    			add_location(path51, file$3, 70, 8, 11742);
    			attr(path52, "d", "M1226,890.43662 C1226,868.659718 1243.45939,851 1265,851 C1286.54061,851 1304,868.659718 1304,890.43662 L1304,935");
    			attr(path52, "stroke", path52_stroke_value = ctx.colors[1]);
    			attr(path52, "stroke-linejoin", "round");
    			add_location(path52, file$3, 71, 8, 12033);
    			attr(ellipse4, "stroke", ellipse4_stroke_value = ctx.colors[1]);
    			attr(ellipse4, "stroke-linejoin", "round");
    			attr(ellipse4, "cx", "1386.5");
    			attr(ellipse4, "cy", "828");
    			attr(ellipse4, "rx", "41.5");
    			attr(ellipse4, "ry", "41");
    			add_location(ellipse4, file$3, 72, 8, 12218);
    			attr(path53, "d", "M1305.73333,1009.5 C1305.73333,1030.21094 1289.00093,1047 1268.36667,1047 C1247.7324,1047 1231,1030.21094 1231,1009.5 C1231,988.789062 1247.7324,972 1268.36667,972 L1408,972");
    			attr(path53, "stroke", path53_stroke_value = ctx.colors[0]);
    			attr(path53, "stroke-linejoin", "round");
    			add_location(path53, file$3, 73, 8, 12330);
    			attr(path54, "d", "M1259,733 L1395.16314,733 C1446.98771,733 1489,775.0885 1489,827 C1489,878.9115 1446.98771,921 1395.16314,921 L1354.20273,921");
    			attr(path54, "stroke", path54_stroke_value = ctx.colors[2]);
    			attr(path54, "stroke-linejoin", "round");
    			add_location(path54, file$3, 74, 8, 12575);
    			attr(path55, "d", "M1457,972 L1500.14577,972 C1543.69821,972 1579,1007.45367 1579,1051.195 L1579,1132");
    			attr(path55, "stroke", path55_stroke_value = ctx.colors[0]);
    			attr(path55, "stroke-linejoin", "round");
    			add_location(path55, file$3, 75, 8, 12772);
    			attr(ellipse5, "stroke", ellipse5_stroke_value = ctx.colors[2]);
    			attr(ellipse5, "stroke-linejoin", "round");
    			attr(ellipse5, "cx", "1499");
    			attr(ellipse5, "cy", "1051.5");
    			attr(ellipse5, "rx", "27");
    			attr(ellipse5, "ry", "26.5");
    			add_location(ellipse5, file$3, 76, 8, 12926);
    			attr(path56, "d", "M0.471425188,59 C0.490475063,69 0.509524937,79 0.528574812,89");
    			attr(path56, "stroke", path56_stroke_value = ctx.colors[3]);
    			add_location(path56, file$3, 78, 10, 13125);
    			attr(path57, "d", "M0.471425188,0 C0.490475063,10 0.509524937,20 0.528574812,30");
    			attr(path57, "stroke", path57_stroke_value = ctx.colors[0]);
    			add_location(path57, file$3, 79, 10, 13236);
    			attr(g0, "transform", "translate(1352.000000, 1082.000000)");
    			attr(g0, "stroke-linejoin", "round");
    			add_location(g0, file$3, 77, 8, 13039);
    			attr(path58, "d", "M1165.47143,1031 C1165.49048,1041 1165.50952,1051 1165.52857,1061");
    			attr(path58, "stroke", path58_stroke_value = ctx.colors[3]);
    			attr(path58, "stroke-linejoin", "round");
    			add_location(path58, file$3, 81, 8, 13357);
    			attr(path59, "d", "M1165.47143,972 C1165.49048,982 1165.50952,992 1165.52857,1002");
    			attr(path59, "stroke", path59_stroke_value = ctx.colors[1]);
    			attr(path59, "stroke-linejoin", "round");
    			add_location(path59, file$3, 82, 8, 13494);
    			attr(path60, "d", "M1105.47143,972 C1105.49048,982 1105.50952,992 1105.52857,1002");
    			attr(path60, "stroke", path60_stroke_value = ctx.colors[0]);
    			attr(path60, "stroke-linejoin", "round");
    			add_location(path60, file$3, 83, 8, 13628);
    			attr(path61, "d", "M689.471425,893 C689.490475,903 689.509525,913 689.528575,923");
    			attr(path61, "stroke", path61_stroke_value = ctx.colors[2]);
    			attr(path61, "stroke-linejoin", "round");
    			add_location(path61, file$3, 84, 8, 13762);
    			attr(path62, "d", "M246.471425,914 C246.490475,924 246.509525,934 246.528575,944");
    			attr(path62, "stroke", path62_stroke_value = ctx.colors[1]);
    			attr(path62, "stroke-linejoin", "round");
    			add_location(path62, file$3, 85, 8, 13895);
    			attr(path63, "d", "M381.471425,510 C381.490475,520 381.509525,530 381.528575,540");
    			attr(path63, "stroke", path63_stroke_value = ctx.colors[1]);
    			attr(path63, "stroke-linejoin", "round");
    			add_location(path63, file$3, 86, 8, 14028);
    			attr(path64, "d", "M332.471425,436 C332.490475,446 332.509525,456 332.528575,466");
    			attr(path64, "stroke", path64_stroke_value = ctx.colors[0]);
    			attr(path64, "stroke-linejoin", "round");
    			add_location(path64, file$3, 87, 8, 14161);
    			attr(path65, "d", "M746.471425,477 C746.490475,487 746.509525,497 746.528575,507");
    			attr(path65, "stroke", path65_stroke_value = ctx.colors[3]);
    			attr(path65, "stroke-linejoin", "round");
    			add_location(path65, file$3, 88, 8, 14294);
    			attr(path66, "d", "M1044.47143,160 C1044.49048,170 1044.50952,180 1044.52857,190");
    			attr(path66, "stroke", path66_stroke_value = ctx.colors[3]);
    			attr(path66, "stroke-linejoin", "round");
    			add_location(path66, file$3, 89, 8, 14427);
    			attr(path67, "d", "M1044.47143,103 C1044.49048,113 1044.50952,123 1044.52857,133");
    			attr(path67, "stroke", path67_stroke_value = ctx.colors[2]);
    			attr(path67, "stroke-linejoin", "round");
    			add_location(path67, file$3, 90, 8, 14560);
    			attr(path68, "d", "M1373.47143,637 C1373.49048,647 1373.50952,657 1373.52857,667");
    			attr(path68, "stroke", path68_stroke_value = ctx.colors[2]);
    			attr(path68, "stroke-linejoin", "round");
    			add_location(path68, file$3, 91, 8, 14693);
    			attr(path69, "d", "M1444.47143,637 C1444.49048,647 1444.50952,657 1444.52857,667");
    			attr(path69, "stroke", path69_stroke_value = ctx.colors[2]);
    			attr(path69, "stroke-linejoin", "round");
    			add_location(path69, file$3, 92, 8, 14826);
    			attr(path70, "d", "M1515.47143,637 C1515.49048,647 1515.50952,657 1515.52857,667");
    			attr(path70, "stroke", path70_stroke_value = ctx.colors[2]);
    			attr(path70, "stroke-linejoin", "round");
    			add_location(path70, file$3, 93, 8, 14959);
    			attr(g1, "transform", "translate(-218.000000, -5.000000)");
    			attr(g1, "id", "Shape");
    			add_location(g1, file$3, 13, 6, 486);
    			attr(g2, "id", "Hinterrhein");
    			attr(g2, "fill-rule", "nonzero");
    			attr(g2, "stroke-width", "30");
    			add_location(g2, file$3, 12, 4, 421);
    			attr(g3, "id", "Patterns");
    			attr(g3, "stroke", "none");
    			attr(g3, "stroke-width", "1");
    			attr(g3, "fill", "none");
    			attr(g3, "fill-rule", "evenodd");
    			add_location(g3, file$3, 11, 2, 336);
    			attr(svg, "viewBox", "0 0 1600 1200");
    			attr(svg, "version", "1.1");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr(svg, "style", ctx.styles);
    			add_location(svg, file$3, 10, 0, 195);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g3);
    			append(g3, g2);
    			append(g2, g1);
    			append(g1, ellipse0);
    			append(g1, path0);
    			append(g1, path1);
    			append(g1, path2);
    			append(g1, path3);
    			append(g1, path4);
    			append(g1, path5);
    			append(g1, path6);
    			append(g1, path7);
    			append(g1, path8);
    			append(g1, path9);
    			append(g1, path10);
    			append(g1, path11);
    			append(g1, path12);
    			append(g1, path13);
    			append(g1, path14);
    			append(g1, path15);
    			append(g1, path16);
    			append(g1, path17);
    			append(g1, path18);
    			append(g1, circle);
    			append(g1, path19);
    			append(g1, path20);
    			append(g1, path21);
    			append(g1, path22);
    			append(g1, path23);
    			append(g1, path24);
    			append(g1, path25);
    			append(g1, ellipse1);
    			append(g1, path26);
    			append(g1, path27);
    			append(g1, path28);
    			append(g1, path29);
    			append(g1, path30);
    			append(g1, path31);
    			append(g1, path32);
    			append(g1, ellipse2);
    			append(g1, path33);
    			append(g1, path34);
    			append(g1, path35);
    			append(g1, path36);
    			append(g1, ellipse3);
    			append(g1, path37);
    			append(g1, path38);
    			append(g1, path39);
    			append(g1, path40);
    			append(g1, path41);
    			append(g1, path42);
    			append(g1, path43);
    			append(g1, path44);
    			append(g1, path45);
    			append(g1, path46);
    			append(g1, path47);
    			append(g1, path48);
    			append(g1, path49);
    			append(g1, path50);
    			append(g1, path51);
    			append(g1, path52);
    			append(g1, ellipse4);
    			append(g1, path53);
    			append(g1, path54);
    			append(g1, path55);
    			append(g1, ellipse5);
    			append(g1, g0);
    			append(g0, path56);
    			append(g0, path57);
    			append(g1, path58);
    			append(g1, path59);
    			append(g1, path60);
    			append(g1, path61);
    			append(g1, path62);
    			append(g1, path63);
    			append(g1, path64);
    			append(g1, path65);
    			append(g1, path66);
    			append(g1, path67);
    			append(g1, path68);
    			append(g1, path69);
    			append(g1, path70);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colors) && ellipse0_stroke_value !== (ellipse0_stroke_value = ctx.colors[0])) {
    				attr(ellipse0, "stroke", ellipse0_stroke_value);
    			}

    			if ((changed.colors) && path0_stroke_value !== (path0_stroke_value = ctx.colors[1])) {
    				attr(path0, "stroke", path0_stroke_value);
    			}

    			if ((changed.colors) && path1_stroke_value !== (path1_stroke_value = ctx.colors[1])) {
    				attr(path1, "stroke", path1_stroke_value);
    			}

    			if ((changed.colors) && path2_stroke_value !== (path2_stroke_value = ctx.colors[0])) {
    				attr(path2, "stroke", path2_stroke_value);
    			}

    			if ((changed.colors) && path3_stroke_value !== (path3_stroke_value = ctx.colors[2])) {
    				attr(path3, "stroke", path3_stroke_value);
    			}

    			if ((changed.colors) && path4_stroke_value !== (path4_stroke_value = ctx.colors[3])) {
    				attr(path4, "stroke", path4_stroke_value);
    			}

    			if ((changed.colors) && path5_stroke_value !== (path5_stroke_value = ctx.colors[1])) {
    				attr(path5, "stroke", path5_stroke_value);
    			}

    			if ((changed.colors) && path6_stroke_value !== (path6_stroke_value = ctx.colors[2])) {
    				attr(path6, "stroke", path6_stroke_value);
    			}

    			if ((changed.colors) && path7_stroke_value !== (path7_stroke_value = ctx.colors[3])) {
    				attr(path7, "stroke", path7_stroke_value);
    			}

    			if ((changed.colors) && path8_stroke_value !== (path8_stroke_value = ctx.colors[1])) {
    				attr(path8, "stroke", path8_stroke_value);
    			}

    			if ((changed.colors) && path9_stroke_value !== (path9_stroke_value = ctx.colors[0])) {
    				attr(path9, "stroke", path9_stroke_value);
    			}

    			if ((changed.colors) && path10_stroke_value !== (path10_stroke_value = ctx.colors[1])) {
    				attr(path10, "stroke", path10_stroke_value);
    			}

    			if ((changed.colors) && path11_stroke_value !== (path11_stroke_value = ctx.colors[3])) {
    				attr(path11, "stroke", path11_stroke_value);
    			}

    			if ((changed.colors) && path12_stroke_value !== (path12_stroke_value = ctx.colors[3])) {
    				attr(path12, "stroke", path12_stroke_value);
    			}

    			if ((changed.colors) && path13_stroke_value !== (path13_stroke_value = ctx.colors[2])) {
    				attr(path13, "stroke", path13_stroke_value);
    			}

    			if ((changed.colors) && path14_stroke_value !== (path14_stroke_value = ctx.colors[3])) {
    				attr(path14, "stroke", path14_stroke_value);
    			}

    			if ((changed.colors) && path15_stroke_value !== (path15_stroke_value = ctx.colors[1])) {
    				attr(path15, "stroke", path15_stroke_value);
    			}

    			if ((changed.colors) && path16_stroke_value !== (path16_stroke_value = ctx.colors[2])) {
    				attr(path16, "stroke", path16_stroke_value);
    			}

    			if ((changed.colors) && path17_stroke_value !== (path17_stroke_value = ctx.colors[3])) {
    				attr(path17, "stroke", path17_stroke_value);
    			}

    			if ((changed.colors) && path18_stroke_value !== (path18_stroke_value = ctx.colors[1])) {
    				attr(path18, "stroke", path18_stroke_value);
    			}

    			if ((changed.colors) && circle_stroke_value !== (circle_stroke_value = ctx.colors[3])) {
    				attr(circle, "stroke", circle_stroke_value);
    			}

    			if ((changed.colors) && path19_stroke_value !== (path19_stroke_value = ctx.colors[1])) {
    				attr(path19, "stroke", path19_stroke_value);
    			}

    			if ((changed.colors) && path20_stroke_value !== (path20_stroke_value = ctx.colors[2])) {
    				attr(path20, "stroke", path20_stroke_value);
    			}

    			if ((changed.colors) && path21_stroke_value !== (path21_stroke_value = ctx.colors[0])) {
    				attr(path21, "stroke", path21_stroke_value);
    			}

    			if ((changed.colors) && path22_stroke_value !== (path22_stroke_value = ctx.colors[1])) {
    				attr(path22, "stroke", path22_stroke_value);
    			}

    			if ((changed.colors) && path23_stroke_value !== (path23_stroke_value = ctx.colors[0])) {
    				attr(path23, "stroke", path23_stroke_value);
    			}

    			if ((changed.colors) && path24_stroke_value !== (path24_stroke_value = ctx.colors[1])) {
    				attr(path24, "stroke", path24_stroke_value);
    			}

    			if ((changed.colors) && path25_stroke_value !== (path25_stroke_value = ctx.colors[2])) {
    				attr(path25, "stroke", path25_stroke_value);
    			}

    			if ((changed.colors) && ellipse1_stroke_value !== (ellipse1_stroke_value = ctx.colors[2])) {
    				attr(ellipse1, "stroke", ellipse1_stroke_value);
    			}

    			if ((changed.colors) && path26_stroke_value !== (path26_stroke_value = ctx.colors[0])) {
    				attr(path26, "stroke", path26_stroke_value);
    			}

    			if ((changed.colors) && path27_stroke_value !== (path27_stroke_value = ctx.colors[1])) {
    				attr(path27, "stroke", path27_stroke_value);
    			}

    			if ((changed.colors) && path28_stroke_value !== (path28_stroke_value = ctx.colors[2])) {
    				attr(path28, "stroke", path28_stroke_value);
    			}

    			if ((changed.colors) && path29_stroke_value !== (path29_stroke_value = ctx.colors[1])) {
    				attr(path29, "stroke", path29_stroke_value);
    			}

    			if ((changed.colors) && path30_stroke_value !== (path30_stroke_value = ctx.colors[3])) {
    				attr(path30, "stroke", path30_stroke_value);
    			}

    			if ((changed.colors) && path31_stroke_value !== (path31_stroke_value = ctx.colors[2])) {
    				attr(path31, "stroke", path31_stroke_value);
    			}

    			if ((changed.colors) && path32_stroke_value !== (path32_stroke_value = ctx.colors[3])) {
    				attr(path32, "stroke", path32_stroke_value);
    			}

    			if ((changed.colors) && ellipse2_stroke_value !== (ellipse2_stroke_value = ctx.colors[2])) {
    				attr(ellipse2, "stroke", ellipse2_stroke_value);
    			}

    			if ((changed.colors) && path33_stroke_value !== (path33_stroke_value = ctx.colors[0])) {
    				attr(path33, "stroke", path33_stroke_value);
    			}

    			if ((changed.colors) && path34_stroke_value !== (path34_stroke_value = ctx.colors[2])) {
    				attr(path34, "stroke", path34_stroke_value);
    			}

    			if ((changed.colors) && path35_stroke_value !== (path35_stroke_value = ctx.colors[3])) {
    				attr(path35, "stroke", path35_stroke_value);
    			}

    			if ((changed.colors) && path36_stroke_value !== (path36_stroke_value = ctx.colors[0])) {
    				attr(path36, "stroke", path36_stroke_value);
    			}

    			if ((changed.colors) && ellipse3_stroke_value !== (ellipse3_stroke_value = ctx.colors[1])) {
    				attr(ellipse3, "stroke", ellipse3_stroke_value);
    			}

    			if ((changed.colors) && path37_stroke_value !== (path37_stroke_value = ctx.colors[2])) {
    				attr(path37, "stroke", path37_stroke_value);
    			}

    			if ((changed.colors) && path38_stroke_value !== (path38_stroke_value = ctx.colors[2])) {
    				attr(path38, "stroke", path38_stroke_value);
    			}

    			if ((changed.colors) && path39_stroke_value !== (path39_stroke_value = ctx.colors[2])) {
    				attr(path39, "stroke", path39_stroke_value);
    			}

    			if ((changed.colors) && path40_stroke_value !== (path40_stroke_value = ctx.colors[1])) {
    				attr(path40, "stroke", path40_stroke_value);
    			}

    			if ((changed.colors) && path41_stroke_value !== (path41_stroke_value = ctx.colors[1])) {
    				attr(path41, "stroke", path41_stroke_value);
    			}

    			if ((changed.colors) && path42_stroke_value !== (path42_stroke_value = ctx.colors[1])) {
    				attr(path42, "stroke", path42_stroke_value);
    			}

    			if ((changed.colors) && path43_stroke_value !== (path43_stroke_value = ctx.colors[0])) {
    				attr(path43, "stroke", path43_stroke_value);
    			}

    			if ((changed.colors) && path44_stroke_value !== (path44_stroke_value = ctx.colors[3])) {
    				attr(path44, "stroke", path44_stroke_value);
    			}

    			if ((changed.colors) && path45_stroke_value !== (path45_stroke_value = ctx.colors[2])) {
    				attr(path45, "stroke", path45_stroke_value);
    			}

    			if ((changed.colors) && path46_stroke_value !== (path46_stroke_value = ctx.colors[1])) {
    				attr(path46, "stroke", path46_stroke_value);
    			}

    			if ((changed.colors) && path47_stroke_value !== (path47_stroke_value = ctx.colors[3])) {
    				attr(path47, "stroke", path47_stroke_value);
    			}

    			if ((changed.colors) && path48_stroke_value !== (path48_stroke_value = ctx.colors[2])) {
    				attr(path48, "stroke", path48_stroke_value);
    			}

    			if ((changed.colors) && path49_stroke_value !== (path49_stroke_value = ctx.colors[0])) {
    				attr(path49, "stroke", path49_stroke_value);
    			}

    			if ((changed.colors) && path50_stroke_value !== (path50_stroke_value = ctx.colors[3])) {
    				attr(path50, "stroke", path50_stroke_value);
    			}

    			if ((changed.colors) && path51_stroke_value !== (path51_stroke_value = ctx.colors[3])) {
    				attr(path51, "stroke", path51_stroke_value);
    			}

    			if ((changed.colors) && path52_stroke_value !== (path52_stroke_value = ctx.colors[1])) {
    				attr(path52, "stroke", path52_stroke_value);
    			}

    			if ((changed.colors) && ellipse4_stroke_value !== (ellipse4_stroke_value = ctx.colors[1])) {
    				attr(ellipse4, "stroke", ellipse4_stroke_value);
    			}

    			if ((changed.colors) && path53_stroke_value !== (path53_stroke_value = ctx.colors[0])) {
    				attr(path53, "stroke", path53_stroke_value);
    			}

    			if ((changed.colors) && path54_stroke_value !== (path54_stroke_value = ctx.colors[2])) {
    				attr(path54, "stroke", path54_stroke_value);
    			}

    			if ((changed.colors) && path55_stroke_value !== (path55_stroke_value = ctx.colors[0])) {
    				attr(path55, "stroke", path55_stroke_value);
    			}

    			if ((changed.colors) && ellipse5_stroke_value !== (ellipse5_stroke_value = ctx.colors[2])) {
    				attr(ellipse5, "stroke", ellipse5_stroke_value);
    			}

    			if ((changed.colors) && path56_stroke_value !== (path56_stroke_value = ctx.colors[3])) {
    				attr(path56, "stroke", path56_stroke_value);
    			}

    			if ((changed.colors) && path57_stroke_value !== (path57_stroke_value = ctx.colors[0])) {
    				attr(path57, "stroke", path57_stroke_value);
    			}

    			if ((changed.colors) && path58_stroke_value !== (path58_stroke_value = ctx.colors[3])) {
    				attr(path58, "stroke", path58_stroke_value);
    			}

    			if ((changed.colors) && path59_stroke_value !== (path59_stroke_value = ctx.colors[1])) {
    				attr(path59, "stroke", path59_stroke_value);
    			}

    			if ((changed.colors) && path60_stroke_value !== (path60_stroke_value = ctx.colors[0])) {
    				attr(path60, "stroke", path60_stroke_value);
    			}

    			if ((changed.colors) && path61_stroke_value !== (path61_stroke_value = ctx.colors[2])) {
    				attr(path61, "stroke", path61_stroke_value);
    			}

    			if ((changed.colors) && path62_stroke_value !== (path62_stroke_value = ctx.colors[1])) {
    				attr(path62, "stroke", path62_stroke_value);
    			}

    			if ((changed.colors) && path63_stroke_value !== (path63_stroke_value = ctx.colors[1])) {
    				attr(path63, "stroke", path63_stroke_value);
    			}

    			if ((changed.colors) && path64_stroke_value !== (path64_stroke_value = ctx.colors[0])) {
    				attr(path64, "stroke", path64_stroke_value);
    			}

    			if ((changed.colors) && path65_stroke_value !== (path65_stroke_value = ctx.colors[3])) {
    				attr(path65, "stroke", path65_stroke_value);
    			}

    			if ((changed.colors) && path66_stroke_value !== (path66_stroke_value = ctx.colors[3])) {
    				attr(path66, "stroke", path66_stroke_value);
    			}

    			if ((changed.colors) && path67_stroke_value !== (path67_stroke_value = ctx.colors[2])) {
    				attr(path67, "stroke", path67_stroke_value);
    			}

    			if ((changed.colors) && path68_stroke_value !== (path68_stroke_value = ctx.colors[2])) {
    				attr(path68, "stroke", path68_stroke_value);
    			}

    			if ((changed.colors) && path69_stroke_value !== (path69_stroke_value = ctx.colors[2])) {
    				attr(path69, "stroke", path69_stroke_value);
    			}

    			if ((changed.colors) && path70_stroke_value !== (path70_stroke_value = ctx.colors[2])) {
    				attr(path70, "stroke", path70_stroke_value);
    			}

    			if (changed.styles) {
    				attr(svg, "style", ctx.styles);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(svg);
    			}
    		}
    	};
    }

    function instance$3($$self, $$props, $$invalidate) {

      let { colors, styles } = $$props;

    	const writable_props = ['colors', 'styles'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Hinterrhein> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('colors' in $$props) $$invalidate('colors', colors = $$props.colors);
    		if ('styles' in $$props) $$invalidate('styles', styles = $$props.styles);
    	};

    	return { colors, styles };
    }

    class Hinterrhein extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["colors", "styles"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.colors === undefined && !('colors' in props)) {
    			console.warn("<Hinterrhein> was created without expected prop 'colors'");
    		}
    		if (ctx.styles === undefined && !('styles' in props)) {
    			console.warn("<Hinterrhein> was created without expected prop 'styles'");
    		}
    	}

    	get colors() {
    		throw new Error("<Hinterrhein>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colors(value) {
    		throw new Error("<Hinterrhein>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Hinterrhein>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Hinterrhein>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/patterns/Inn.svelte generated by Svelte v3.6.7 */

    const file$4 = "src/patterns/Inn.svelte";

    function create_fragment$4(ctx) {
    	var svg, g2, g1, g0, path0, path0_fill_value, path1, path1_fill_value, path2, path2_fill_value, path3, path3_fill_value, path4, path4_fill_value, path5, path5_fill_value, path6, path6_fill_value, ellipse0, ellipse0_fill_value, path7, path7_fill_value, path8, path8_fill_value, path9, path9_fill_value, path10, path10_fill_value, path11, path11_fill_value, path12, path12_fill_value, path13, path13_fill_value, path14, path14_fill_value, ellipse1, ellipse1_fill_value, ellipse2, ellipse2_fill_value, ellipse3, ellipse3_fill_value, path15, path15_fill_value, path16, path16_fill_value, path17, path17_fill_value, path18, path18_fill_value, path19, path19_fill_value, path20, path20_fill_value, path21, path21_fill_value, path22, path22_fill_value, path23, path23_fill_value, path24, path24_fill_value, path25, path25_fill_value, path26, path26_fill_value, path27, path27_fill_value, path28, path28_fill_value, path29, path29_fill_value, path30, path30_fill_value, path31, path31_fill_value, path32, path32_fill_value, path33, path33_fill_value, path34, path34_fill_value, path35, path35_fill_value, path36, path36_fill_value, path37, path37_fill_value, path38, path38_fill_value, path39, path39_fill_value, path40, path40_fill_value, path41, path41_fill_value, path42, path42_fill_value, path43, path43_fill_value, path44, path44_fill_value, path45, path45_fill_value, path46, path46_fill_value, path47, path47_fill_value, path48, path48_fill_value, path49, path49_fill_value, path50, path50_fill_value, path51, path51_fill_value, path52, path52_fill_value, path53, path53_fill_value, path54, path54_fill_value, path55, path55_fill_value, path56, path56_fill_value, path57, path57_fill_value, path58, path58_fill_value, path59, path59_fill_value, path60, path60_fill_value, path61, path61_fill_value, path62, path62_fill_value, path63, path63_fill_value, path64, path64_fill_value, path65, path65_fill_value, path66, path66_fill_value, path67, path67_fill_value, path68, path68_fill_value, path69, path69_fill_value, path70, path70_fill_value, path71, path71_fill_value, path72, path72_fill_value, path73, path73_fill_value, path74, path74_fill_value, path75, path75_fill_value, path76, path76_fill_value, path77, path77_fill_value, path78, path78_fill_value, path79, path79_fill_value, path80, path80_fill_value, path81, path81_fill_value, path82, path82_fill_value, path83, path83_fill_value, path84, path84_fill_value, path85, path85_fill_value, path86, path86_fill_value, path87, path87_fill_value, path88, path88_fill_value, path89, path89_fill_value, path90, path90_fill_value;

    	return {
    		c: function create() {
    			svg = svg_element("svg");
    			g2 = svg_element("g");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			ellipse0 = svg_element("ellipse");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			path13 = svg_element("path");
    			path14 = svg_element("path");
    			ellipse1 = svg_element("ellipse");
    			ellipse2 = svg_element("ellipse");
    			ellipse3 = svg_element("ellipse");
    			path15 = svg_element("path");
    			path16 = svg_element("path");
    			path17 = svg_element("path");
    			path18 = svg_element("path");
    			path19 = svg_element("path");
    			path20 = svg_element("path");
    			path21 = svg_element("path");
    			path22 = svg_element("path");
    			path23 = svg_element("path");
    			path24 = svg_element("path");
    			path25 = svg_element("path");
    			path26 = svg_element("path");
    			path27 = svg_element("path");
    			path28 = svg_element("path");
    			path29 = svg_element("path");
    			path30 = svg_element("path");
    			path31 = svg_element("path");
    			path32 = svg_element("path");
    			path33 = svg_element("path");
    			path34 = svg_element("path");
    			path35 = svg_element("path");
    			path36 = svg_element("path");
    			path37 = svg_element("path");
    			path38 = svg_element("path");
    			path39 = svg_element("path");
    			path40 = svg_element("path");
    			path41 = svg_element("path");
    			path42 = svg_element("path");
    			path43 = svg_element("path");
    			path44 = svg_element("path");
    			path45 = svg_element("path");
    			path46 = svg_element("path");
    			path47 = svg_element("path");
    			path48 = svg_element("path");
    			path49 = svg_element("path");
    			path50 = svg_element("path");
    			path51 = svg_element("path");
    			path52 = svg_element("path");
    			path53 = svg_element("path");
    			path54 = svg_element("path");
    			path55 = svg_element("path");
    			path56 = svg_element("path");
    			path57 = svg_element("path");
    			path58 = svg_element("path");
    			path59 = svg_element("path");
    			path60 = svg_element("path");
    			path61 = svg_element("path");
    			path62 = svg_element("path");
    			path63 = svg_element("path");
    			path64 = svg_element("path");
    			path65 = svg_element("path");
    			path66 = svg_element("path");
    			path67 = svg_element("path");
    			path68 = svg_element("path");
    			path69 = svg_element("path");
    			path70 = svg_element("path");
    			path71 = svg_element("path");
    			path72 = svg_element("path");
    			path73 = svg_element("path");
    			path74 = svg_element("path");
    			path75 = svg_element("path");
    			path76 = svg_element("path");
    			path77 = svg_element("path");
    			path78 = svg_element("path");
    			path79 = svg_element("path");
    			path80 = svg_element("path");
    			path81 = svg_element("path");
    			path82 = svg_element("path");
    			path83 = svg_element("path");
    			path84 = svg_element("path");
    			path85 = svg_element("path");
    			path86 = svg_element("path");
    			path87 = svg_element("path");
    			path88 = svg_element("path");
    			path89 = svg_element("path");
    			path90 = svg_element("path");
    			attr(path0, "d", "M217.461082,322.986248 C217.461082,308.667466 214.64931,294.488251 209.184513,281.259843 C203.719716,268.031434 195.710625,256.011159 185.613907,245.885953 C175.517189,235.760747 163.530734,227.729057 150.339545,222.248841 C137.148355,216.769279 123.009036,213.948919 108.730541,213.948919 C94.4520465,213.948919 80.3127269,216.769279 67.1215377,222.248841 C53.9303484,227.729057 41.9438936,235.760747 31.8471755,245.885953 C21.7504574,256.011159 13.7413658,268.031434 8.27656879,281.259843 C2.81177179,294.488251 0,308.667466 0,322.986248 L108.730541,322.986248 L217.461082,322.986248 Z");
    			attr(path0, "fill", path0_fill_value = ctx.colors[1]);
    			add_location(path0, file$4, 14, 8, 483);
    			attr(path1, "d", "M0,218.074656 C14.3171898,218.074656 28.4948273,215.261919 41.721765,209.797167 C54.9487027,204.332197 66.9676412,196.322432 77.0917216,186.224592 C87.2158021,176.126968 95.2465986,164.13918 100.726205,150.946089 C106.205812,137.752781 109.025204,123.612324 109.025204,109.332024 C109.025204,95.0517236 106.205812,80.9112666 100.726205,67.717958 C95.2465986,54.5246493 87.2158021,42.537079 77.0917216,32.4394556 C66.9676412,22.3416147 54.9487027,14.3317629 41.721765,8.86692365 C28.4948273,3.40210615 14.3171898,0.589390963 0,0.589390963 L0,109.332024 L0,218.074656 Z");
    			attr(path1, "fill", path1_fill_value = ctx.colors[0]);
    			add_location(path1, file$4, 15, 8, 1116);
    			attr(path2, "d", "M239.266123,588.801572 C224.948933,588.801572 210.771296,585.981866 197.544358,580.50165 C184.31742,575.021434 172.298482,566.989745 162.174401,556.864538 C152.050321,546.739332 144.019524,534.719057 138.539918,521.490648 C133.060311,508.26224 130.240919,494.083026 130.240919,479.764244 L239.266123,479.764244 L239.266123,588.801572 Z");
    			attr(path2, "fill", path2_fill_value = ctx.colors[2]);
    			add_location(path2, file$4, 16, 8, 1729);
    			attr(path3, "d", "M0,348.330059 C14.3171898,348.330059 28.4948273,351.149764 41.721765,356.62998 C54.9487027,362.110196 66.9676412,370.141886 77.0917216,380.267092 C87.2158021,390.392299 95.2465986,402.412574 100.726205,415.640982 C106.205812,428.869391 109.025204,443.048605 109.025204,457.367387 L0,457.367387 L0,348.330059 Z");
    			attr(path3, "fill", path3_fill_value = ctx.colors[0]);
    			add_location(path3, file$4, 17, 8, 2110);
    			attr(path4, "d", "M130.240919,110.21611 C130.240919,95.89711 133.060311,81.718332 138.539918,68.4892692 C144.019524,55.2602063 152.050321,43.2401493 162.174401,33.1151611 C172.298482,22.9899548 184.31742,14.9583961 197.544358,9.47874695 C210.771296,3.99911965 224.948933,1.17878193 239.266123,1.17878193 L239.266123,110.21611 L130.240919,110.21611 Z");
    			attr(path4, "fill", path4_fill_value = ctx.colors[3]);
    			add_location(path4, file$4, 18, 8, 2465);
    			attr(path5, "d", "M0,534.282908 C0,504.17334 24.4063821,479.764244 54.5126019,479.764244 L109.025204,479.764244 L109.025204,588.801572 L54.5126019,588.801572 C24.4063821,588.801572 0,564.392475 0,534.282908 L0,534.282908 Z");
    			attr(path5, "fill", path5_fill_value = ctx.colors[3]);
    			add_location(path5, file$4, 19, 8, 2842);
    			attr(path6, "d", "M130.240919,403.438114 C130.240919,433.547682 154.647301,457.956778 184.753521,457.956778 L239.266123,457.956778 L239.266123,348.91945 L184.753521,348.91945 C154.647301,348.91945 130.240919,373.328546 130.240919,403.438114 L130.240919,403.438114 Z");
    			attr(path6, "fill", path6_fill_value = ctx.colors[4]);
    			add_location(path6, file$4, 20, 8, 3092);
    			attr(ellipse0, "fill", ellipse0_fill_value = ctx.colors[3]);
    			attr(ellipse0, "cx", "195.950704");
    			attr(ellipse0, "cy", "174.75442");
    			attr(ellipse0, "rx", "43.3154188");
    			attr(ellipse0, "ry", "43.3202358");
    			add_location(ellipse0, file$4, 21, 8, 3385);
    			attr(path7, "d", "M1587.6427,218.074656 C1587.6427,203.755656 1584.82331,189.576878 1579.3437,176.347815 C1573.86409,163.118752 1565.8333,151.098695 1555.70922,140.973707 C1545.58514,130.848501 1533.5662,122.817029 1520.33926,117.33725 C1507.11232,111.857688 1492.93468,109.037328 1478.61749,109.037328 L1478.61749,218.074656 L1587.6427,218.074656 Z");
    			attr(path7, "fill", path7_fill_value = ctx.colors[1]);
    			add_location(path7, file$4, 22, 8, 3495);
    			attr(path8, "d", "M1239.35137,110.21611 C1246.47137,110.21611 1253.52166,108.806039 1260.09969,106.066149 C1266.67763,103.326259 1272.65462,99.3104145 1277.6893,94.2480295 C1282.72398,89.1854263 1286.71746,83.1752888 1289.44224,76.5608664 C1292.16702,69.9462259 1293.56931,62.8568369 1293.56931,55.697446 C1293.56931,48.538055 1292.16702,41.448666 1289.44224,34.8340255 C1286.71746,28.2196031 1282.72398,22.2094438 1277.6893,17.1469279 C1272.65462,12.084412 1266.67763,8.068589 1260.09969,5.32876444 C1253.52166,2.58894861 1246.47137,1.17878193 1239.35137,1.17878193 L1239.35137,55.697446 L1239.35137,110.21611 Z");
    			attr(path8, "fill", path8_fill_value = ctx.colors[1]);
    			add_location(path8, file$4, 23, 8, 3872);
    			attr(path9, "d", "M1457.40178,0.589390963 C1443.08437,0.589390963 1428.90717,3.40210615 1415.67958,8.86692365 C1402.4522,14.3317629 1390.43327,22.3416147 1380.3094,32.4394556 C1370.18532,42.537079 1362.15474,54.5246493 1356.67557,67.717958 C1351.19662,80.9112666 1348.37658,95.0517236 1348.37658,109.332024 C1348.37658,123.612324 1351.19662,137.752781 1356.67557,150.946089 C1362.15474,164.13918 1370.18532,176.126968 1380.3094,186.224592 C1390.43327,196.322432 1402.4522,204.332197 1415.67958,209.797167 C1428.90717,215.261919 1443.08437,218.074656 1457.40178,218.074656 L1457.40178,109.332024 L1457.40178,0.589390963 Z");
    			attr(path9, "fill", path9_fill_value = ctx.colors[0]);
    			add_location(path9, file$4, 24, 8, 4512);
    			attr(path10, "d", "M1348.37658,479.174853 C1348.37658,464.856071 1351.19662,450.676857 1356.67557,437.448448 C1362.15474,424.220039 1370.18532,412.199764 1380.3094,402.074558 C1390.43327,391.949352 1402.4522,383.917662 1415.67958,378.437446 C1428.90717,372.95723 1443.08437,370.137525 1457.40178,370.137525 L1457.40178,479.174853 L1348.37658,479.174853 Z");
    			attr(path10, "fill", path10_fill_value = ctx.colors[2]);
    			add_location(path10, file$4, 25, 8, 5160);
    			attr(path11, "d", "M1478.61749,587.62279 C1492.93468,587.62279 1507.11232,584.810705 1520.33926,579.345301 C1533.5662,573.879896 1545.58514,565.869914 1555.70922,555.772073 C1565.8333,545.674232 1573.86409,533.686444 1579.3437,520.493788 C1584.82331,507.301132 1587.6427,493.16024 1587.6427,478.880157 C1587.6427,464.600075 1584.82331,450.459183 1579.3437,437.266527 C1573.86409,424.07387 1565.8333,412.086083 1555.70922,401.988242 C1545.58514,391.890401 1533.5662,383.880418 1520.33926,378.415014 C1507.11232,372.949609 1492.93468,370.137525 1478.61749,370.137525 L1478.61749,478.880157 L1478.61749,587.62279 Z");
    			attr(path11, "fill", path11_fill_value = ctx.colors[1]);
    			add_location(path11, file$4, 26, 8, 5541);
    			attr(path12, "d", "M1239.35137,240.471513 C1253.66877,240.471513 1267.84597,243.283597 1281.07356,248.749002 C1294.30116,254.214407 1306.31988,262.224389 1316.44374,272.32223 C1326.56782,282.420071 1334.59862,294.407859 1340.07758,307.600515 C1345.55653,320.793171 1348.37658,334.934063 1348.37658,349.214145 C1348.37658,363.494228 1345.55653,377.63512 1340.07758,390.827776 C1334.59862,404.020432 1326.56782,416.00822 1316.44396,426.106061 C1306.31988,436.203902 1294.30116,444.213884 1281.07356,449.679289 C1267.84597,455.144694 1253.66879,457.956778 1239.35137,457.956778 L1239.35137,349.214145 L1239.35137,240.471513 Z");
    			attr(path12, "fill", path12_fill_value = ctx.colors[5]);
    			add_location(path12, file$4, 27, 8, 6179);
    			attr(path13, "d", "M1369.59229,239.882122 C1369.59229,254.200904 1372.40471,268.380118 1377.86886,281.608527 C1383.33322,294.836935 1391.3421,306.85721 1401.43881,316.982417 C1411.53531,327.107623 1423.52177,335.139312 1436.71339,340.619528 C1449.90523,346.099745 1464.04434,348.91945 1478.32283,348.91945 C1492.60133,348.91945 1506.74065,346.099745 1519.93184,340.619528 C1533.12302,335.139312 1545.10948,327.107623 1555.2062,316.982417 C1565.30292,306.85721 1573.31201,294.836935 1578.7768,281.608527 C1584.2416,268.380118 1587.05337,254.200904 1587.05337,239.882122 L1478.32283,239.882122 L1369.59229,239.882122 Z");
    			attr(path13, "fill", path13_fill_value = ctx.colors[1]);
    			add_location(path13, file$4, 28, 8, 6828);
    			attr(path14, "d", "M1348.37658,534.282908 C1348.37658,564.392475 1323.97041,588.801572 1293.86398,588.801572 L1239.35137,588.801572 L1239.35137,479.764244 L1293.86398,479.764244 C1323.97041,479.764244 1348.37658,504.17334 1348.37658,534.282908 L1348.37658,534.282908 Z");
    			attr(path14, "fill", path14_fill_value = ctx.colors[0]);
    			add_location(path14, file$4, 29, 8, 7471);
    			attr(ellipse1, "fill", ellipse1_fill_value = ctx.colors[3]);
    			attr(ellipse1, "cx", "1521.93291");
    			attr(ellipse1, "cy", "44.4990177");
    			attr(ellipse1, "rx", "43.3154188");
    			attr(ellipse1, "ry", "43.3202358");
    			add_location(ellipse1, file$4, 30, 8, 7766);
    			attr(ellipse2, "fill", ellipse2_fill_value = ctx.colors[0]);
    			attr(ellipse2, "cx", "1282.66679");
    			attr(ellipse2, "cy", "174.75442");
    			attr(ellipse2, "rx", "43.3154188");
    			attr(ellipse2, "ry", "43.3202358");
    			add_location(ellipse2, file$4, 31, 8, 7877);
    			attr(ellipse3, "fill", ellipse3_fill_value = ctx.colors[3]);
    			attr(ellipse3, "cx", "1412.90771");
    			attr(ellipse3, "cy", "545.481336");
    			attr(ellipse3, "rx", "43.3154188");
    			attr(ellipse3, "ry", "43.3202358");
    			add_location(ellipse3, file$4, 32, 8, 7987);
    			attr(path15, "d", "M608.773165,370.137525 C608.773165,384.456525 605.953774,398.635303 600.474167,411.864365 C594.99456,425.093428 586.963764,437.113485 576.839683,447.238473 C566.715603,457.36368 554.696664,465.395151 541.469726,470.874931 C528.242789,476.354493 514.065151,479.174853 499.747961,479.174853 L499.747961,370.137525 L608.773165,370.137525 Z");
    			attr(path15, "fill", path15_fill_value = ctx.colors[3]);
    			add_location(path15, file$4, 33, 8, 8098);
    			attr(path16, "d", "M957.064492,500.982318 C949.944592,500.982318 942.894092,499.572248 936.316371,496.832358 C929.738651,494.092468 923.761665,490.076623 918.725903,485.014238 C913.69231,479.951635 909.697532,473.941497 906.973623,467.327075 C904.249713,460.712434 902.846553,453.623045 902.846553,446.463654 C902.846553,439.304263 904.249713,432.214874 906.973623,425.600234 C909.697532,418.985811 913.69231,412.975674 918.725903,407.913071 C923.761665,402.850686 929.738651,398.834841 936.316371,396.094951 C942.894092,393.355061 949.944592,391.94499 957.064492,391.94499 L957.064492,500.982318 Z");
    			attr(path16, "fill", path16_fill_value = ctx.colors[2]);
    			add_location(path16, file$4, 34, 8, 8480);
    			attr(path17, "d", "M717.798369,109.037328 C710.678469,109.037328 703.627969,107.626385 697.050248,104.887367 C690.472528,102.14835 684.495542,98.1314145 679.45978,93.0699018 C674.426187,88.0062083 670.431409,81.9960707 667.707499,75.3818664 C664.98359,68.7676621 663.58043,61.678055 663.58043,54.518664 C663.58043,47.3592731 664.98359,40.269666 667.707499,33.6554617 C670.431409,27.0412574 674.426187,21.0311198 679.45978,15.9674263 C684.495542,10.9059136 690.472528,6.88897839 697.050248,4.14996071 C703.627969,1.41094303 710.678469,0 717.798369,0 L717.798369,109.037328 Z");
    			attr(path17, "fill", path17_fill_value = ctx.colors[0]);
    			add_location(path17, file$4, 35, 8, 9105);
    			attr(path18, "d", "M260.481838,478.585462 C267.60184,478.585462 274.652128,479.995532 281.230156,482.735422 C287.808097,485.475312 293.785086,489.491157 298.819767,494.553542 C303.854448,499.616145 307.847927,505.626283 310.572706,512.240705 C313.297484,518.855346 314.699778,525.944735 314.699778,533.104126 C314.699778,540.263517 313.297484,547.352906 310.572706,553.967546 C307.847927,560.581969 303.854448,566.592128 298.819767,571.654644 C293.785086,576.71716 287.808097,580.732983 281.230156,583.472807 C274.652128,586.212623 267.60184,587.62279 260.481838,587.62279 L260.481838,478.585462 Z");
    			attr(path18, "fill", path18_fill_value = ctx.colors[1]);
    			add_location(path18, file$4, 36, 8, 9705);
    			attr(path19, "d", "M478.532246,587.62279 C464.214838,587.62279 450.037637,584.810075 436.810045,579.345257 C423.582671,573.880418 411.563733,565.870566 401.43987,555.772725 C391.31579,545.675102 383.285211,533.687531 377.806041,520.494223 C372.327088,507.300914 369.507042,493.160457 369.507042,478.880157 C369.507042,464.599857 372.327088,450.4594 377.806041,437.266092 C383.285211,424.073 391.31579,412.085213 401.43987,401.987589 C411.563733,391.889748 423.582671,383.879983 436.810045,378.415014 C450.037637,372.950261 464.214838,370.137525 478.532246,370.137525 L478.532246,587.62279 Z");
    			attr(path19, "fill", path19_fill_value = ctx.colors[1]);
    			add_location(path19, file$4, 37, 8, 10329);
    			attr(path20, "d", "M369.507042,109.037328 L478.532246,109.037328 L478.532246,218.074656 C464.214838,218.074656 450.037637,215.254951 436.810045,209.774735 C423.582671,204.294519 411.563733,196.262829 401.43987,186.137623 C391.31579,176.012417 383.285211,163.992141 377.806041,150.763733 C372.327088,137.535324 369.507042,123.35611 369.507042,109.037328 Z");
    			attr(path20, "fill", path20_fill_value = ctx.colors[0]);
    			add_location(path20, file$4, 38, 8, 10946);
    			attr(path21, "d", "M499.747961,0.589390963 C514.065151,0.589390963 528.242789,3.40147544 541.469726,8.86688016 C554.696664,14.3322849 566.715603,22.3422672 576.839683,32.4401081 C586.963764,42.5379489 594.99456,54.5257367 600.474167,67.7183929 C605.953774,80.9110491 608.773165,95.0519411 608.773165,109.332024 C608.773165,123.612106 605.953774,137.752998 600.474167,150.945654 C594.99456,164.13831 586.963764,176.126098 576.839683,186.223939 C566.715603,196.32178 554.696664,204.331762 541.469726,209.797167 C528.242789,215.262572 514.065151,218.074656 499.747961,218.074656 L499.747961,0.589390963 Z");
    			attr(path21, "fill", path21_fill_value = ctx.colors[3]);
    			add_location(path21, file$4, 39, 8, 11327);
    			attr(path22, "d", "M739.60341,587.62279 C739.60341,573.303812 742.415182,559.125012 747.879979,545.895949 C753.344776,532.666886 761.353867,520.646829 771.450585,510.521841 C781.547303,500.396635 793.533758,492.365163 806.724948,486.885383 C819.916137,481.405821 834.055456,478.585462 848.333951,478.585462 C862.612446,478.585462 876.751765,481.405821 889.942955,486.885383 C903.134144,492.365163 915.120599,500.396635 925.217317,510.521841 C935.314035,520.646829 943.323126,532.666886 948.787923,545.895949 C954.25272,559.125012 957.064492,573.303812 957.064492,587.62279 L739.60341,587.62279 Z");
    			attr(path22, "fill", path22_fill_value = ctx.colors[4]);
    			add_location(path22, file$4, 40, 8, 11955);
    			attr(path23, "d", "M1195.74129,265.225933 C1195.74129,279.544715 1192.92952,293.723929 1187.46472,306.952338 C1181.99992,320.180747 1173.99083,332.201022 1163.89411,342.326228 C1153.7974,352.451434 1141.81094,360.483124 1128.61975,365.96334 C1115.42856,371.442902 1101.28924,374.263261 1087.01075,374.263261 C1072.73225,374.263261 1058.59293,371.442902 1045.40175,365.96334 C1032.21056,360.483124 1020.2241,352.451434 1010.12738,342.326228 C1000.03067,332.201022 992.021573,320.180747 986.556776,306.952338 C981.091979,293.723929 978.280208,279.544715 978.280208,265.225933 L1195.74129,265.225933 Z");
    			attr(path23, "fill", path23_fill_value = ctx.colors[3]);
    			add_location(path23, file$4, 41, 8, 12577);
    			attr(path24, "d", "M978.280208,370.137525 C992.597397,370.137525 1006.77503,372.950261 1020.00197,378.415014 C1033.22891,383.879983 1045.24785,391.889748 1055.37193,401.987589 C1065.49601,412.085213 1073.52681,424.073 1079.00641,437.266092 C1084.48602,450.4594 1087.30541,464.599857 1087.30541,478.880157 C1087.30541,493.160457 1084.48602,507.300914 1079.00641,520.494223 C1073.52681,533.687531 1065.49601,545.675102 1055.37193,555.772725 C1045.24785,565.870566 1033.22891,573.880418 1020.00197,579.345257 C1006.77503,584.810075 992.597397,587.62279 978.280208,587.62279 L978.280208,370.137525 Z");
    			attr(path24, "fill", path24_fill_value = ctx.colors[0]);
    			add_location(path24, file$4, 42, 8, 13202);
    			attr(path25, "d", "M869.844329,239.292731 C869.844329,224.973949 872.656101,210.794735 878.120898,197.566326 C883.585695,184.337917 891.594787,172.317642 901.691505,162.192436 C911.788223,152.06723 923.774678,144.03554 936.965867,138.555324 C950.157056,133.075108 964.296376,130.255403 978.57487,130.255403 C992.853365,130.255403 1006.99268,133.075108 1020.18387,138.555324 C1033.37506,144.03554 1045.36152,152.06723 1055.45824,162.192436 C1065.55495,172.317642 1073.56405,184.337917 1079.02884,197.566326 C1084.49364,210.794735 1087.30541,224.973949 1087.30541,239.292731 L869.844329,239.292731 Z");
    			attr(path25, "fill", path25_fill_value = ctx.colors[4]);
    			add_location(path25, file$4, 43, 8, 13824);
    			attr(path26, "d", "M957.064492,0 C957.064492,14.3187819 954.25272,28.4979961 948.787923,41.7264047 C943.323126,54.9548134 935.314035,66.9750884 925.217317,77.1002947 C915.120599,87.225501 903.134144,95.2571906 889.942955,100.737407 C876.751765,106.217623 862.612446,109.037328 848.333951,109.037328 C834.055456,109.037328 819.916137,106.217623 806.724948,100.737407 C793.533758,95.2571906 781.547303,87.225501 771.450585,77.1002947 C761.353867,66.9750884 753.344776,54.9548134 747.879979,41.7264047 C742.415182,28.4979961 739.60341,14.3187819 739.60341,0 L957.064492,0 Z");
    			attr(path26, "fill", path26_fill_value = ctx.colors[3]);
    			add_location(path26, file$4, 44, 8, 14448);
    			attr(path27, "d", "M717.798369,347.740668 C703.481179,347.740668 689.303542,344.928583 676.076604,339.463179 C662.849666,333.997774 650.830728,325.987792 640.706648,315.889951 C630.582567,305.79211 622.551771,293.804322 617.072164,280.611666 C611.592557,267.41901 608.773165,253.278118 608.773165,238.998035 C608.773165,224.717953 611.592557,210.577061 617.072164,197.384405 C622.551771,184.191749 630.582567,172.203961 640.706648,162.10612 C650.830728,152.008279 662.849666,143.998297 676.076604,138.532892 C689.303542,133.067487 703.481179,130.255403 717.798369,130.255403 L717.798369,347.740668 Z");
    			attr(path27, "fill", path27_fill_value = ctx.colors[1]);
    			add_location(path27, file$4, 45, 8, 15045);
    			attr(path28, "d", "M260.481838,347.740668 L260.481838,130.255403 C274.799256,130.255403 288.976437,133.067487 302.204031,138.532892 C315.431624,143.998297 327.450346,152.008279 337.574428,162.10612 C347.698292,172.203961 355.729089,184.191749 361.208043,197.384405 C366.686996,210.577061 369.507042,224.717953 369.507042,238.998035 C369.507042,253.278118 366.686996,267.41901 361.208043,280.611666 C355.729089,293.804322 347.698292,305.79211 337.57421,315.889951 C327.450346,325.987792 315.431624,333.997774 302.204031,339.463179 C288.976437,344.928583 274.799234,347.740668 260.481838,347.740668 Z");
    			attr(path28, "fill", path28_fill_value = ctx.colors[3]);
    			add_location(path28, file$4, 46, 8, 15671);
    			attr(path29, "d", "M390.722758,348.330059 C390.722758,334.011277 393.535182,319.832063 398.999326,306.603654 C404.463688,293.375246 412.472563,281.354971 422.569281,271.229764 C432.665781,261.104558 444.652236,253.072868 457.84386,247.592652 C471.035702,242.112436 485.174804,239.292731 499.453299,239.292731 C513.731793,239.292731 527.871113,242.112436 541.062302,247.592652 C554.253491,253.072868 566.239946,261.104558 576.336664,271.229764 C586.433382,281.354971 594.442474,293.375246 599.907271,306.603654 C605.372068,319.832063 608.18384,334.011277 608.18384,348.330059 L390.722758,348.330059 Z");
    			attr(path29, "fill", path29_fill_value = ctx.colors[0]);
    			add_location(path29, file$4, 47, 8, 16296);
    			attr(path30, "d", "M848.039288,370.137525 C848.039288,384.456525 845.227517,398.635303 839.76272,411.864365 C834.297923,425.093428 826.288831,437.113485 816.192113,447.238473 C806.095395,457.36368 794.10894,465.395151 780.917751,470.874931 C767.726561,476.354493 753.587242,479.174853 739.308747,479.174853 C725.030253,479.174853 710.890933,476.354493 697.699744,470.874931 C684.508554,465.395151 672.5221,457.36368 662.425382,447.238473 C652.328664,437.113485 644.319572,425.093428 638.854775,411.864365 C633.389978,398.635303 630.578206,384.456525 630.578206,370.137525 L848.039288,370.137525 Z");
    			attr(path30, "fill", path30_fill_value = ctx.colors[0]);
    			add_location(path30, file$4, 48, 8, 16922);
    			attr(path31, "d", "M848.039288,239.292731 L739.014085,239.292731 L739.014085,130.255403 C753.331274,130.255403 767.508912,133.075108 780.73585,138.555324 C793.962787,144.03554 805.981726,152.06723 816.105806,162.192436 C826.229887,172.317642 834.260683,184.337917 839.74029,197.566326 C845.219897,210.794735 848.039288,224.973949 848.039288,239.292731 Z");
    			attr(path31, "fill", path31_fill_value = ctx.colors[2]);
    			add_location(path31, file$4, 49, 8, 17545);
    			attr(path32, "d", "M1217.54633,0 L1217.54633,109.037328 L1108.52113,109.037328 C1108.52113,94.7185462 1111.34052,80.539332 1116.82013,67.3109234 C1122.29973,54.0825147 1130.33053,42.0622397 1140.45461,31.9370334 C1150.57869,21.8118271 1162.59763,13.7801375 1175.82457,8.29992141 C1189.0515,2.8197053 1203.22914,0 1217.54633,0 Z");
    			attr(path32, "fill", path32_fill_value = ctx.colors[2]);
    			add_location(path32, file$4, 50, 8, 17925);
    			attr(path33, "d", "M848.039288,261.100196 L957.064492,261.100196 L957.064492,370.137525 C942.747302,370.137525 928.569665,367.317819 915.342727,361.837603 C902.115789,356.357387 890.096851,348.325697 879.972771,338.200491 C869.84869,328.075285 861.817894,316.05501 856.338287,302.826601 C850.85868,289.598193 848.039288,275.418978 848.039288,261.100196 Z");
    			attr(path33, "fill", path33_fill_value = ctx.colors[0]);
    			add_location(path33, file$4, 51, 8, 18279);
    			attr(path34, "d", "M1108.52113,478.585462 L1217.54633,478.585462 L1217.54633,587.62279 C1203.22914,587.62279 1189.0515,584.802452 1175.82457,579.322825 C1162.59763,573.843176 1150.57869,565.811617 1140.45461,555.686411 C1130.33053,545.561422 1122.29973,533.541365 1116.82013,520.312303 C1111.34052,507.08324 1108.52113,492.904462 1108.52113,478.585462 Z");
    			attr(path34, "fill", path34_fill_value = ctx.colors[5]);
    			add_location(path34, file$4, 52, 8, 18660);
    			attr(path35, "d", "M663.285767,478.585462 C693.391987,478.585462 717.798369,502.994339 717.798369,533.104126 L717.798369,587.62279 L608.773165,587.62279 L608.773165,533.104126 C608.773165,502.994339 633.179547,478.585462 663.285767,478.585462 Z");
    			attr(path35, "fill", path35_fill_value = ctx.colors[5]);
    			add_location(path35, file$4, 53, 8, 19040);
    			attr(path36, "d", "M369.507042,54.518664 C369.507042,84.6282318 345.10088,109.037328 314.99444,109.037328 L260.481838,109.037328 L260.481838,0 L314.99444,0 C345.10088,0 369.507042,24.4090963 369.507042,54.518664 Z");
    			attr(path36, "fill", path36_fill_value = ctx.colors[4]);
    			add_location(path36, file$4, 54, 8, 19311);
    			attr(path37, "d", "M978.280208,54.518664 C978.280208,24.4090963 1002.68659,0 1032.79281,0 L1087.30541,0 L1087.30541,109.037328 L1032.79281,109.037328 C1002.68659,109.037328 978.280208,84.6282318 978.280208,54.518664 Z");
    			attr(path37, "fill", path37_fill_value = ctx.colors[4]);
    			add_location(path37, file$4, 55, 8, 19551);
    			attr(path38, "d", "M1108.52113,184.774067 C1108.52113,154.664499 1132.92751,130.255403 1163.03373,130.255403 L1217.54633,130.255403 L1217.54633,239.292731 L1163.03373,239.292731 C1132.92751,239.292731 1108.52113,214.883635 1108.52113,184.774067 Z");
    			attr(path38, "fill", path38_fill_value = ctx.colors[1]);
    			add_location(path38, file$4, 56, 8, 19795);
    			attr(path39, "d", "M543.06338,500.982318 C566.985826,500.982318 586.378799,520.377448 586.378799,544.302554 C586.378799,568.22766 566.985826,587.62279 543.06338,587.62279 C519.140935,587.62279 499.747961,568.22766 499.747961,544.302554 C499.747961,520.377448 519.140935,500.982318 543.06338,500.982318 Z");
    			attr(path39, "fill", path39_fill_value = ctx.colors[0]);
    			add_location(path39, file$4, 57, 8, 20068);
    			attr(path40, "d", "M303.797257,370.726916 C327.719702,370.726916 347.112676,390.122046 347.112676,414.047151 C347.112676,437.972257 327.719702,457.367387 303.797257,457.367387 C279.874812,457.367387 260.481838,437.972257 260.481838,414.047151 C260.481838,390.122046 279.874812,370.726916 303.797257,370.726916 Z");
    			attr(path40, "fill", path40_fill_value = ctx.colors[5]);
    			add_location(path40, file$4, 58, 8, 20398);
    			attr(path41, "d", "M434.038176,0 C457.960622,0 477.353595,19.3951302 477.353595,43.3202358 C477.353595,67.2453413 457.960622,86.6404715 434.038176,86.6404715 C410.115731,86.6404715 390.722758,67.2453413 390.722758,43.3202358 C390.722758,19.3951302 410.115731,0 434.038176,0 Z");
    			attr(path41, "fill", path41_fill_value = ctx.colors[2]);
    			add_location(path41, file$4, 59, 8, 20736);
    			attr(path42, "d", "M782.918829,261.689587 C806.841274,261.689587 826.234248,281.084718 826.234248,305.009823 C826.234248,328.934929 806.841274,348.330059 782.918829,348.330059 C758.996384,348.330059 739.60341,328.934929 739.60341,305.009823 C739.60341,281.084718 758.996384,261.689587 782.918829,261.689587 Z");
    			attr(path42, "fill", path42_fill_value = ctx.colors[1]);
    			add_location(path42, file$4, 60, 8, 21038);
    			attr(path43, "d", "M1174.23091,370.726916 C1198.15336,370.726916 1217.54633,390.122046 1217.54633,414.047151 C1217.54633,437.972257 1198.15336,457.367387 1174.23091,457.367387 C1150.30847,457.367387 1130.91549,437.972257 1130.91549,414.047151 C1130.91549,390.122046 1150.30847,370.726916 1174.23091,370.726916 Z");
    			attr(path43, "fill", path43_fill_value = ctx.colors[3]);
    			add_location(path43, file$4, 61, 8, 21373);
    			attr(path44, "d", "M348.291327,982.514735 C348.291327,996.833735 345.471935,1011.01251 339.992328,1024.24158 C334.512722,1037.47064 326.481925,1049.4907 316.357845,1059.61568 C306.233764,1069.74089 294.214826,1077.77236 280.987888,1083.25214 C267.76095,1088.7317 253.583313,1091.55206 239.266123,1091.55206 L239.266123,982.514735 L348.291327,982.514735 Z");
    			attr(path44, "fill", path44_fill_value = ctx.colors[1]);
    			add_location(path44, file$4, 62, 8, 21711);
    			attr(path45, "d", "M696.582654,1113.35953 C689.462754,1113.35953 682.412253,1111.94946 675.834533,1109.20957 C669.256812,1106.46968 663.279827,1102.45383 658.244065,1097.39145 C653.210471,1092.32884 649.215693,1086.31871 646.491784,1079.70428 C643.767875,1073.08964 642.364715,1066.00026 642.364715,1058.84086 C642.364715,1051.68147 643.767875,1044.59208 646.491784,1037.97744 C649.215693,1031.36302 653.210471,1025.35288 658.244065,1020.29028 C663.279827,1015.2279 669.256812,1011.21205 675.834533,1008.47216 C682.412253,1005.73227 689.462754,1004.3222 696.582654,1004.3222 L696.582654,1113.35953 Z");
    			attr(path45, "fill", path45_fill_value = ctx.colors[3]);
    			add_location(path45, file$4, 63, 8, 22092);
    			attr(path46, "d", "M457.316531,721.414538 C450.196631,721.414538 443.14613,720.003595 436.56841,717.264578 C429.990689,714.52556 424.013704,710.508625 418.977942,705.447112 C413.944348,700.383418 409.94957,694.373281 407.225661,687.759077 C404.501752,681.144872 403.098592,674.055265 403.098592,666.895874 C403.098592,659.736483 404.501752,652.646876 407.225661,646.032672 C409.94957,639.418468 413.944348,633.40833 418.977942,628.344637 C424.013704,623.283124 429.990689,619.266189 436.56841,616.527171 C443.14613,613.788153 450.196631,612.37721 457.316531,612.37721 L457.316531,721.414538 Z");
    			attr(path46, "fill", path46_fill_value = ctx.colors[2]);
    			add_location(path46, file$4, 64, 8, 22718);
    			attr(path47, "d", "M0,1090.96267 C7.12000115,1090.96267 14.1702894,1092.37274 20.7483174,1095.11263 C27.3262587,1097.85252 33.303248,1101.86837 38.3379289,1106.93075 C43.3726098,1111.99336 47.3660887,1118.00349 50.0908672,1124.61792 C52.8156456,1131.23256 54.2179392,1138.32194 54.2179392,1145.48134 C54.2179392,1152.64073 52.8156456,1159.73012 50.0908672,1166.34476 C47.3660887,1172.95918 43.3726098,1178.96934 38.3379289,1184.03185 C33.303248,1189.09437 27.3262587,1193.11019 20.7483174,1195.85002 C14.1702894,1198.58983 7.12000115,1200 0,1200 L0,1090.96267 Z");
    			attr(path47, "fill", path47_fill_value = ctx.colors[2]);
    			add_location(path47, file$4, 65, 8, 23337);
    			attr(path48, "d", "M218.050408,1200 C203.733,1200 189.555798,1197.18728 176.328207,1191.72247 C163.100833,1186.25763 151.081894,1178.24778 140.958032,1168.14994 C130.833951,1158.05231 122.803373,1146.06474 117.324202,1132.87143 C111.84525,1119.67812 109.025204,1105.53767 109.025204,1091.25737 C109.025204,1076.97707 111.84525,1062.83661 117.324202,1049.6433 C122.803373,1036.45021 130.833951,1024.46242 140.958032,1014.3648 C151.081894,1004.26696 163.100833,996.257194 176.328207,990.792224 C189.555798,985.327472 203.733,982.514735 218.050408,982.514735 L218.050408,1200 Z");
    			attr(path48, "fill", path48_fill_value = ctx.colors[3]);
    			add_location(path48, file$4, 66, 8, 23925);
    			attr(path49, "d", "M109.025204,720.825147 L218.050408,720.825147 L218.050408,829.862475 C203.733,829.862475 189.555798,827.04277 176.328207,821.562554 C163.100833,816.082338 151.081894,808.050648 140.958032,797.925442 C130.833951,787.800236 122.803373,775.779961 117.324202,762.551552 C111.84525,749.323143 109.025204,735.143929 109.025204,720.825147 Z");
    			attr(path49, "fill", path49_fill_value = ctx.colors[0]);
    			add_location(path49, file$4, 67, 8, 24526);
    			attr(path50, "d", "M239.266123,612.37721 C253.583313,612.37721 267.76095,615.189295 280.987888,620.654699 C294.214826,626.120104 306.233764,634.130086 316.357845,644.227927 C326.481925,654.325768 334.512722,666.313556 339.992328,679.506212 C345.471935,692.698868 348.291327,706.83976 348.291327,721.119843 C348.291327,735.399925 345.471935,749.540817 339.992328,762.733473 C334.512722,775.92613 326.481925,787.913917 316.357845,798.011758 C306.233764,808.109599 294.214826,816.119582 280.987888,821.584986 C267.76095,827.050391 253.583313,829.862475 239.266123,829.862475 L239.266123,612.37721 Z");
    			attr(path50, "fill", path50_fill_value = ctx.colors[0]);
    			add_location(path50, file$4, 68, 8, 24905);
    			attr(path51, "d", "M479.121572,1200 C479.121572,1185.68102 481.933343,1171.50222 487.39814,1158.27316 C492.862937,1145.0441 500.872029,1133.02404 510.968747,1122.89905 C521.065465,1112.77384 533.05192,1104.74237 546.243109,1099.26259 C559.434298,1093.78303 573.573618,1090.96267 587.852113,1090.96267 C602.130607,1090.96267 616.269927,1093.78303 629.461116,1099.26259 C642.652305,1104.74237 654.63876,1112.77384 664.735478,1122.89905 C674.832196,1133.02404 682.841288,1145.0441 688.306085,1158.27316 C693.770882,1171.50222 696.582654,1185.68102 696.582654,1200 L479.121572,1200 Z");
    			attr(path51, "fill", path51_fill_value = ctx.colors[1]);
    			add_location(path51, file$4, 69, 8, 25527);
    			attr(path52, "d", "M935.259451,878.192534 C935.259451,892.511316 932.44768,906.69053 926.982883,919.918939 C921.518086,933.147348 913.508994,945.167623 903.412276,955.292829 C893.315558,965.418035 881.329103,973.449725 868.137914,978.929941 C854.946725,984.409503 840.807405,987.229862 826.52891,987.229862 C812.250416,987.229862 798.111096,984.409503 784.919907,978.929941 C771.728718,973.449725 759.742263,965.418035 749.645545,955.292829 C739.548827,945.167623 731.539735,933.147348 726.074938,919.918939 C720.610141,906.69053 717.798369,892.511316 717.798369,878.192534 L935.259451,878.192534 Z");
    			attr(path52, "fill", path52_fill_value = ctx.colors[3]);
    			add_location(path52, file$4, 70, 8, 26133);
    			attr(path53, "d", "M717.798369,982.514735 C732.115559,982.514735 746.293196,985.327472 759.520134,990.792224 C772.747072,996.257194 784.76601,1004.26696 794.890091,1014.3648 C805.014171,1024.46242 813.044968,1036.45021 818.524574,1049.6433 C824.004181,1062.83661 826.823573,1076.97707 826.823573,1091.25737 C826.823573,1105.53767 824.004181,1119.67812 818.524574,1132.87143 C813.044968,1146.06474 805.014171,1158.05231 794.890091,1168.14994 C784.76601,1178.24778 772.747072,1186.25763 759.520134,1191.72247 C746.293196,1197.18728 732.115559,1200 717.798369,1200 L717.798369,982.514735 Z");
    			attr(path53, "fill", path53_fill_value = ctx.colors[4]);
    			add_location(path53, file$4, 71, 8, 26758);
    			attr(path54, "d", "M609.362491,851.669941 C609.362491,837.351159 612.174263,823.171945 617.63906,809.943536 C623.103857,796.715128 631.112948,784.694853 641.209666,774.569646 C651.306384,764.44444 663.292839,756.41275 676.484028,750.932534 C689.675218,745.452318 703.814537,742.632613 718.093032,742.632613 C732.371527,742.632613 746.510846,745.452318 759.702035,750.932534 C772.893225,756.41275 784.879679,764.44444 794.976398,774.569646 C805.073116,784.694853 813.082207,796.715128 818.547004,809.943536 C824.011801,823.171945 826.823573,837.351159 826.823573,851.669941 L609.362491,851.669941 Z");
    			attr(path54, "fill", path54_fill_value = ctx.colors[0]);
    			add_location(path54, file$4, 72, 8, 27371);
    			attr(path55, "d", "M696.582654,612.37721 C696.582654,626.695992 693.770882,640.875206 688.306085,654.103615 C682.841288,667.332024 674.832196,679.352299 664.735478,689.477505 C654.63876,699.602711 642.652305,707.634401 629.461116,713.114617 C616.269927,718.594833 602.130607,721.414538 587.852113,721.414538 C573.573618,721.414538 559.434298,718.594833 546.243109,713.114617 C533.05192,707.634401 521.065465,699.602711 510.968747,689.477505 C500.872029,679.352299 492.862937,667.332024 487.39814,654.103615 C481.933343,640.875206 479.121572,626.695992 479.121572,612.37721 L696.582654,612.37721 Z");
    			attr(path55, "fill", path55_fill_value = ctx.colors[0]);
    			add_location(path55, file$4, 73, 8, 27995);
    			attr(path56, "d", "M457.316531,960.707269 C442.999341,960.707269 428.821703,957.895185 415.594766,952.42978 C402.367828,946.964375 390.34889,938.954393 380.224809,928.856552 C370.100729,918.758711 362.069932,906.770923 356.590325,893.578267 C351.110719,880.385611 348.291327,866.244719 348.291327,851.964637 C348.291327,837.684554 351.110719,823.543662 356.590325,810.351006 C362.069932,797.15835 370.100729,785.170562 380.224809,775.072721 C390.34889,764.97488 402.367828,756.964898 415.594766,751.499493 C428.821703,746.034088 442.999341,743.222004 457.316531,743.222004 L457.316531,960.707269 Z");
    			attr(path56, "fill", path56_fill_value = ctx.colors[1]);
    			add_location(path56, file$4, 74, 8, 28618);
    			attr(path57, "d", "M0,960.707269 L0,743.222004 C14.3174173,743.222004 28.4945987,746.034088 41.7221923,751.499493 C54.9497859,756.964898 66.9685079,764.97488 77.0925897,775.072721 C87.2164534,785.170562 95.2472509,797.15835 100.726204,810.351006 C106.205158,823.543662 109.025204,837.684554 109.025204,851.964637 C109.025204,866.244719 106.205158,880.385611 100.726204,893.578267 C95.2472509,906.770923 87.2164534,918.758711 77.0923716,928.856552 C66.9685079,938.954393 54.9497859,946.964375 41.7221923,952.42978 C28.4945987,957.895185 14.3173955,960.707269 0,960.707269 Z");
    			attr(path57, "fill", path57_fill_value = ctx.colors[0]);
    			add_location(path57, file$4, 75, 8, 29242);
    			attr(path58, "d", "M130.240919,960.707269 C130.240919,946.388487 133.053343,932.209273 138.517488,918.980864 C143.98185,905.752456 151.990724,893.732181 162.087442,883.606974 C172.183943,873.481768 184.170398,865.450079 197.362022,859.969862 C210.553864,854.489646 224.692966,851.669941 238.97146,851.669941 C253.249955,851.669941 267.389275,854.489646 280.580464,859.969862 C293.771653,865.450079 305.758108,873.481768 315.854826,883.606974 C325.951544,893.732181 333.960636,905.752456 339.425433,918.980864 C344.89023,932.209273 347.702001,946.388487 347.702001,960.707269 L130.240919,960.707269 Z");
    			attr(path58, "fill", path58_fill_value = ctx.colors[4]);
    			add_location(path58, file$4, 76, 8, 29841);
    			attr(path59, "d", "M587.55745,982.514735 C587.55745,996.833735 584.745678,1011.01251 579.280881,1024.24158 C573.816084,1037.47064 565.806993,1049.4907 555.710274,1059.61568 C545.613556,1069.74089 533.627102,1077.77236 520.435912,1083.25214 C507.244723,1088.7317 493.105403,1091.55206 478.826909,1091.55206 C464.548414,1091.55206 450.409095,1088.7317 437.217905,1083.25214 C424.026716,1077.77236 412.040261,1069.74089 401.943543,1059.61568 C391.846825,1049.4907 383.837733,1037.47064 378.372936,1024.24158 C372.908139,1011.01251 370.096368,996.833735 370.096368,982.514735 L587.55745,982.514735 Z");
    			attr(path59, "fill", path59_fill_value = ctx.colors[0]);
    			add_location(path59, file$4, 77, 8, 30467);
    			attr(path60, "d", "M587.55745,851.669941 L478.532246,851.669941 L478.532246,742.632613 C492.849436,742.632613 507.027073,745.452318 520.254011,750.932534 C533.480949,756.41275 545.499887,764.44444 555.623968,774.569646 C565.748048,784.694853 573.778845,796.715128 579.258451,809.943536 C584.738058,823.171945 587.55745,837.351159 587.55745,851.669941 Z");
    			attr(path60, "fill", path60_fill_value = ctx.colors[1]);
    			add_location(path60, file$4, 78, 8, 31089);
    			attr(path61, "d", "M957.064492,612.37721 L957.064492,721.414538 L848.039288,721.414538 C848.039288,707.095756 850.85868,692.916542 856.338287,679.688134 C861.817894,666.459725 869.84869,654.43945 879.972771,644.314244 C890.096851,634.189037 902.115789,626.157348 915.342727,620.677132 C928.569665,615.196916 942.747302,612.37721 957.064492,612.37721 Z");
    			attr(path61, "fill", path61_fill_value = ctx.colors[2]);
    			add_location(path61, file$4, 79, 8, 31468);
    			attr(path62, "d", "M587.55745,873.477407 L696.582654,873.477407 L696.582654,982.514735 C682.265464,982.514735 668.087827,979.695029 654.860889,974.214813 C641.633951,968.734597 629.615013,960.702908 619.490932,950.577701 C609.366852,940.452495 601.336055,928.43222 595.856448,915.203811 C590.376842,901.975403 587.55745,887.796189 587.55745,873.477407 Z");
    			attr(path62, "fill", path62_fill_value = ctx.colors[3]);
    			add_location(path62, file$4, 80, 8, 31846);
    			attr(path63, "d", "M848.039288,1090.96267 L957.064492,1090.96267 L957.064492,1200 C942.747302,1200 928.569665,1197.17966 915.342727,1191.70003 C902.115789,1186.22039 890.096851,1178.18883 879.972771,1168.06362 C869.84869,1157.93863 861.817894,1145.91858 856.338287,1132.68951 C850.85868,1119.46045 848.039288,1105.28167 848.039288,1090.96267 Z");
    			attr(path63, "fill", path63_fill_value = ctx.colors[0]);
    			add_location(path63, file$4, 81, 8, 32226);
    			attr(path64, "d", "M402.803929,1090.96267 C432.910149,1090.96267 457.316531,1115.37155 457.316531,1145.48134 L457.316531,1200 L348.291327,1200 L348.291327,1145.48134 C348.291327,1115.37155 372.697709,1090.96267 402.803929,1090.96267 Z");
    			attr(path64, "fill", path64_fill_value = ctx.colors[4]);
    			add_location(path64, file$4, 82, 8, 32596);
    			attr(path65, "d", "M109.025204,666.895874 C109.025204,697.005442 84.6190419,721.414538 54.5126019,721.414538 L0,721.414538 L0,612.37721 L54.5126019,612.37721 C84.6190419,612.37721 109.025204,636.786306 109.025204,666.895874 Z");
    			attr(path65, "fill", path65_fill_value = ctx.colors[4]);
    			add_location(path65, file$4, 83, 8, 32857);
    			attr(path66, "d", "M717.798369,666.895874 C717.798369,636.786306 742.204751,612.37721 772.310971,612.37721 L826.823573,612.37721 L826.823573,721.414538 L772.310971,721.414538 C742.204751,721.414538 717.798369,697.005442 717.798369,666.895874 Z");
    			attr(path66, "fill", path66_fill_value = ctx.colors[3]);
    			add_location(path66, file$4, 84, 8, 33109);
    			attr(path67, "d", "M848.039288,797.151277 C848.039288,767.041709 872.44567,742.632613 902.55189,742.632613 L957.064492,742.632613 L957.064492,851.669941 L902.55189,851.669941 C872.44567,851.669941 848.039288,827.260845 848.039288,797.151277 Z");
    			attr(path67, "fill", path67_fill_value = ctx.colors[5]);
    			add_location(path67, file$4, 85, 8, 33379);
    			attr(path68, "d", "M282.581542,1113.35953 C306.503987,1113.35953 325.896961,1132.75466 325.896961,1156.67976 C325.896961,1180.60487 306.503987,1200 282.581542,1200 C258.659097,1200 239.266123,1180.60487 239.266123,1156.67976 C239.266123,1132.75466 258.659097,1113.35953 282.581542,1113.35953 Z");
    			attr(path68, "fill", path68_fill_value = ctx.colors[5]);
    			add_location(path68, file$4, 86, 8, 33648);
    			attr(path69, "d", "M43.3154188,983.104126 C67.2378641,983.104126 86.6308377,1002.49926 86.6308377,1026.42436 C86.6308377,1050.34947 67.2378641,1069.7446 43.3154188,1069.7446 C19.3929736,1069.7446 0,1050.34947 0,1026.42436 C0,1002.49926 19.3929736,983.104126 43.3154188,983.104126 Z");
    			attr(path69, "fill", path69_fill_value = ctx.colors[4]);
    			add_location(path69, file$4, 87, 8, 33968);
    			attr(path70, "d", "M173.556338,612.37721 C197.478783,612.37721 216.871757,631.77234 216.871757,655.697446 C216.871757,679.622552 197.478783,699.017682 173.556338,699.017682 C149.633893,699.017682 130.240919,679.622552 130.240919,655.697446 C130.240919,631.77234 149.633893,612.37721 173.556338,612.37721 Z");
    			attr(path70, "fill", path70_fill_value = ctx.colors[2]);
    			add_location(path70, file$4, 88, 8, 34276);
    			attr(path71, "d", "M522.43699,874.066798 C546.359436,874.066798 565.752409,893.461928 565.752409,917.387033 C565.752409,941.312139 546.359436,960.707269 522.43699,960.707269 C498.514545,960.707269 479.121572,941.312139 479.121572,917.387033 C479.121572,893.461928 498.514545,874.066798 522.43699,874.066798 Z");
    			attr(path71, "fill", path71_fill_value = ctx.colors[2]);
    			add_location(path71, file$4, 89, 8, 34608);
    			attr(path72, "d", "M913.749073,983.104126 C937.671519,983.104126 957.064492,1002.49926 957.064492,1026.42436 C957.064492,1050.34947 937.671519,1069.7446 913.749073,1069.7446 C889.826628,1069.7446 870.433655,1050.34947 870.433655,1026.42436 C870.433655,1002.49926 889.826628,983.104126 913.749073,983.104126 Z");
    			attr(path72, "fill", path72_fill_value = ctx.colors[2]);
    			add_location(path72, file$4, 90, 8, 34943);
    			attr(path73, "d", "M1241.11935,699.017682 C1248.23925,699.017682 1255.28975,700.427752 1261.86747,703.167642 C1268.44519,705.907532 1274.42217,709.923377 1279.45794,714.985762 C1284.49153,720.048365 1288.48631,726.058503 1291.21022,732.672925 C1293.93413,739.287566 1295.33729,746.376955 1295.33729,753.536346 C1295.33729,760.695737 1293.93413,767.785126 1291.21022,774.399766 C1288.48631,781.014189 1284.49153,787.024326 1279.45794,792.086929 C1274.42217,797.149314 1268.44519,801.165159 1261.86747,803.905049 C1255.28975,806.644939 1248.23925,808.05501 1241.11935,808.05501 L1241.11935,699.017682 Z");
    			attr(path73, "fill", path73_fill_value = ctx.colors[2]);
    			add_location(path73, file$4, 91, 8, 35278);
    			attr(path74, "d", "M1480.9748,1090.96267 C1488.0947,1090.96267 1495.1452,1092.37361 1501.72292,1095.11263 C1508.30064,1097.85165 1514.27762,1101.86859 1519.31339,1106.9301 C1524.34698,1111.99379 1528.34176,1118.00393 1531.06567,1124.61813 C1533.78958,1131.23234 1535.19274,1138.32194 1535.19274,1145.48134 C1535.19274,1152.64073 1533.78958,1159.73033 1531.06567,1166.34454 C1528.34176,1172.95874 1524.34698,1178.96888 1519.31339,1184.03257 C1514.27762,1189.09409 1508.30064,1193.11102 1501.72292,1195.85004 C1495.1452,1198.58906 1488.0947,1200 1480.9748,1200 L1480.9748,1090.96267 Z");
    			attr(path74, "fill", path74_fill_value = ctx.colors[2]);
    			add_location(path74, file$4, 92, 8, 35905);
    			attr(path75, "d", "M1458.58043,612.37721 C1458.58043,626.696188 1455.76866,640.874988 1450.30386,654.104051 C1444.83906,667.333114 1436.82997,679.353171 1426.73325,689.478159 C1416.63654,699.603365 1404.65008,707.634837 1391.45889,713.114617 C1378.2677,718.594179 1364.12838,721.414538 1349.84989,721.414538 C1335.57139,721.414538 1321.43207,718.594179 1308.24089,713.114617 C1295.0497,707.634837 1283.06324,699.603365 1272.96652,689.478159 C1262.86981,679.353171 1254.86071,667.333114 1249.39592,654.104051 C1243.93112,640.874988 1241.11935,626.696188 1241.11935,612.37721 L1458.58043,612.37721 Z");
    			attr(path75, "fill", path75_fill_value = ctx.colors[1]);
    			add_location(path75, file$4, 93, 8, 36514);
    			attr(path76, "d", "M1002.44255,934.774067 C1002.44255,920.455285 1005.25432,906.276071 1010.71912,893.047662 C1016.18392,879.819253 1024.19301,867.798978 1034.28973,857.673772 C1044.38644,847.548566 1056.3729,839.516876 1069.56409,834.03666 C1082.75528,828.557098 1096.8946,825.736739 1111.17309,825.736739 C1125.45159,825.736739 1139.59091,828.557098 1152.78209,834.03666 C1165.97328,839.516876 1177.95974,847.548566 1188.05646,857.673772 C1198.15317,867.798978 1206.16227,879.819253 1211.62706,893.047662 C1217.09186,906.276071 1219.90363,920.455285 1219.90363,934.774067 L1002.44255,934.774067 Z");
    			attr(path76, "fill", path76_fill_value = ctx.colors[1]);
    			add_location(path76, file$4, 94, 8, 37138);
    			attr(path77, "d", "M1219.90363,829.862475 C1205.58644,829.862475 1191.40881,827.049739 1178.18187,821.584986 C1164.95493,816.120017 1152.93599,808.110252 1142.81191,798.012411 C1132.68783,787.914787 1124.65703,775.927 1119.17743,762.733908 C1113.69782,749.5406 1110.87843,735.400143 1110.87843,721.119843 C1110.87843,706.839543 1113.69782,692.699086 1119.17743,679.505777 C1124.65703,666.312469 1132.68783,654.324898 1142.81191,644.227275 C1152.93599,634.129434 1164.95493,626.119582 1178.18187,620.654743 C1191.40881,615.189925 1205.58644,612.37721 1219.90363,612.37721 L1219.90363,829.862475 Z");
    			attr(path77, "fill", path77_fill_value = ctx.colors[4]);
    			add_location(path77, file$4, 95, 8, 37763);
    			attr(path78, "d", "M1328.33951,960.707269 C1328.33951,975.026051 1325.52774,989.205265 1320.06294,1002.43367 C1314.59814,1015.66208 1306.58905,1027.68236 1296.49234,1037.80756 C1286.39562,1047.93277 1274.40916,1055.96446 1261.21797,1061.44468 C1248.02678,1066.92489 1233.88746,1069.7446 1219.60897,1069.7446 C1205.33047,1069.7446 1191.19116,1066.92489 1177.99997,1061.44468 C1164.80878,1055.96446 1152.82232,1047.93277 1142.7256,1037.80756 C1132.62889,1027.68236 1124.61979,1015.66208 1119.155,1002.43367 C1113.6902,989.205265 1110.87843,975.026051 1110.87843,960.707269 L1328.33951,960.707269 Z");
    			attr(path78, "fill", path78_fill_value = ctx.colors[0]);
    			add_location(path78, file$4, 96, 8, 38385);
    			attr(path79, "d", "M1241.11935,1200 C1241.11935,1185.68122 1243.93112,1171.502 1249.39592,1158.2736 C1254.86071,1145.04519 1262.86981,1133.02491 1272.96652,1122.89971 C1283.06324,1112.7745 1295.0497,1104.74281 1308.24089,1099.26259 C1321.43207,1093.78238 1335.57139,1090.96267 1349.84989,1090.96267 C1364.12838,1090.96267 1378.2677,1093.78238 1391.45889,1099.26259 C1404.65008,1104.74281 1416.63654,1112.7745 1426.73325,1122.89971 C1436.82997,1133.02491 1444.83906,1145.04519 1450.30386,1158.2736 C1455.76866,1171.502 1458.58043,1185.68122 1458.58043,1200 L1241.11935,1200 Z");
    			attr(path79, "fill", path79_fill_value = ctx.colors[3]);
    			add_location(path79, file$4, 97, 8, 39007);
    			attr(path80, "d", "M1480.9748,852.259332 C1495.29199,852.259332 1509.46962,855.071417 1522.69656,860.536821 C1535.9235,866.002226 1547.94244,874.012208 1558.06652,884.110049 C1568.1906,894.20789 1576.22139,906.195678 1581.701,919.388334 C1587.18061,932.58099 1590,946.721882 1590,961.001965 C1590,975.282047 1587.18061,989.422939 1581.701,1002.6156 C1576.22139,1015.80825 1568.1906,1027.79604 1558.06652,1037.89388 C1547.94244,1047.99172 1535.9235,1056.0017 1522.69656,1061.46711 C1509.46962,1066.93251 1495.29199,1069.7446 1480.9748,1069.7446 L1480.9748,852.259332 Z");
    			attr(path80, "fill", path80_fill_value = ctx.colors[4]);
    			add_location(path80, file$4, 98, 8, 39608);
    			attr(path81, "d", "M1350.14455,829.862475 C1350.14455,815.543475 1352.95632,801.364697 1358.42112,788.135635 C1363.88592,774.906572 1371.89501,762.886515 1381.99173,752.761527 C1392.08845,742.63632 1404.0749,734.604849 1417.26609,729.125069 C1430.45728,723.645507 1444.5966,720.825147 1458.87509,720.825147 C1473.15359,720.825147 1487.29291,723.645507 1500.4841,729.125069 C1513.67529,734.604849 1525.66174,742.63632 1535.75846,752.761527 C1545.85518,762.886515 1553.86427,774.906572 1559.32907,788.135635 C1564.79386,801.364697 1567.60563,815.543475 1567.60563,829.862475 L1350.14455,829.862475 Z");
    			attr(path81, "fill", path81_fill_value = ctx.colors[0]);
    			add_location(path81, file$4, 99, 8, 40202);
    			attr(path82, "d", "M1350.73388,960.707269 L1459.75908,960.707269 L1459.75908,1069.7446 C1445.44189,1069.7446 1431.26425,1066.92489 1418.03732,1061.44468 C1404.81038,1055.96446 1392.79144,1047.93277 1382.66736,1037.80756 C1372.54328,1027.68236 1364.51248,1015.66208 1359.03288,1002.43367 C1353.55327,989.205265 1350.73388,975.026051 1350.73388,960.707269 Z");
    			attr(path82, "fill", path82_fill_value = ctx.colors[4]);
    			add_location(path82, file$4, 100, 8, 40826);
    			attr(path83, "d", "M980.637509,1200 L980.637509,1090.96267 L1089.66271,1090.96267 C1089.66271,1105.28145 1086.84332,1119.46067 1081.36371,1132.68908 C1075.88411,1145.91749 1067.85331,1157.93776 1057.72923,1168.06297 C1047.60515,1178.18817 1035.58621,1186.21986 1022.35927,1191.70008 C1009.13234,1197.18029 994.954699,1200 980.637509,1200 Z");
    			attr(path83, "fill", path83_fill_value = ctx.colors[0]);
    			add_location(path83, file$4, 101, 8, 41208);
    			attr(path84, "d", "M1350.14455,938.899804 L1241.11935,938.899804 L1241.11935,829.862475 C1255.43654,829.862475 1269.61417,832.682181 1282.84111,838.162397 C1296.06805,843.642613 1308.08699,851.674303 1318.21107,861.799509 C1328.33515,871.924715 1336.36595,883.94499 1341.84555,897.173399 C1347.32516,910.401807 1350.14455,924.581022 1350.14455,938.899804 Z");
    			attr(path84, "fill", path84_fill_value = ctx.colors[0]);
    			add_location(path84, file$4, 102, 8, 41574);
    			attr(path85, "d", "M1089.66271,721.414538 L980.637509,721.414538 L980.637509,612.37721 C994.954699,612.37721 1009.13234,615.197548 1022.35927,620.677175 C1035.58621,626.156824 1047.60515,634.188383 1057.72923,644.313589 C1067.85331,654.438578 1075.88411,666.458635 1081.36371,679.687697 C1086.84332,692.91676 1089.66271,707.095538 1089.66271,721.414538 Z");
    			attr(path85, "fill", path85_fill_value = ctx.colors[5]);
    			add_location(path85, file$4, 103, 8, 41957);
    			attr(path86, "d", "M1535.4874,721.414538 C1505.38118,721.414538 1480.9748,697.005661 1480.9748,666.895874 L1480.9748,612.37721 L1590,612.37721 L1590,666.895874 C1590,697.005661 1565.59362,721.414538 1535.4874,721.414538 Z");
    			attr(path86, "fill", path86_fill_value = ctx.colors[4]);
    			add_location(path86, file$4, 104, 8, 42338);
    			attr(path87, "d", "M1219.90363,1145.48134 C1219.90363,1175.5909 1195.49725,1200 1165.39103,1200 L1110.87843,1200 L1110.87843,1090.96267 L1165.39103,1090.96267 C1195.49725,1090.96267 1219.90363,1115.37177 1219.90363,1145.48134 Z");
    			attr(path87, "fill", path87_fill_value = ctx.colors[5]);
    			add_location(path87, file$4, 105, 8, 42586);
    			attr(path88, "d", "M1089.66271,1015.22593 C1089.66271,1045.3355 1065.25633,1069.7446 1035.15011,1069.7446 L980.637509,1069.7446 L980.637509,960.707269 L1035.15011,960.707269 C1065.25633,960.707269 1089.66271,985.116365 1089.66271,1015.22593 Z");
    			attr(path88, "fill", path88_fill_value = ctx.colors[4]);
    			add_location(path88, file$4, 106, 8, 42840);
    			attr(path89, "d", "M1415.85434,938.310413 C1391.93189,938.310413 1372.53892,918.915282 1372.53892,894.990177 C1372.53892,871.065071 1391.93189,851.669941 1415.85434,851.669941 C1439.77678,851.669941 1459.16976,871.065071 1459.16976,894.990177 C1459.16976,918.915282 1439.77678,938.310413 1415.85434,938.310413 Z");
    			attr(path89, "fill", path89_fill_value = ctx.colors[3]);
    			add_location(path89, file$4, 107, 8, 43109);
    			attr(path90, "d", "M1023.95293,829.273084 C1000.03048,829.273084 980.637509,809.877954 980.637509,785.952849 C980.637509,762.027743 1000.03048,742.632613 1023.95293,742.632613 C1047.87537,742.632613 1067.26835,762.027743 1067.26835,785.952849 C1067.26835,809.877954 1047.87537,829.273084 1023.95293,829.273084 Z");
    			attr(path90, "fill", path90_fill_value = ctx.colors[3]);
    			add_location(path90, file$4, 108, 8, 43447);
    			attr(g0, "id", "Shape");
    			add_location(g0, file$4, 13, 6, 460);
    			attr(g1, "id", "Inn");
    			attr(g1, "fill-rule", "nonzero");
    			add_location(g1, file$4, 12, 4, 421);
    			attr(g2, "id", "Patterns");
    			attr(g2, "stroke", "none");
    			attr(g2, "stroke-width", "1");
    			attr(g2, "fill", "none");
    			attr(g2, "fill-rule", "evenodd");
    			add_location(g2, file$4, 11, 2, 336);
    			attr(svg, "viewBox", "0 0 1590 1200");
    			attr(svg, "version", "1.1");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr(svg, "style", ctx.styles);
    			add_location(svg, file$4, 10, 0, 195);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g2);
    			append(g2, g1);
    			append(g1, g0);
    			append(g0, path0);
    			append(g0, path1);
    			append(g0, path2);
    			append(g0, path3);
    			append(g0, path4);
    			append(g0, path5);
    			append(g0, path6);
    			append(g0, ellipse0);
    			append(g0, path7);
    			append(g0, path8);
    			append(g0, path9);
    			append(g0, path10);
    			append(g0, path11);
    			append(g0, path12);
    			append(g0, path13);
    			append(g0, path14);
    			append(g0, ellipse1);
    			append(g0, ellipse2);
    			append(g0, ellipse3);
    			append(g0, path15);
    			append(g0, path16);
    			append(g0, path17);
    			append(g0, path18);
    			append(g0, path19);
    			append(g0, path20);
    			append(g0, path21);
    			append(g0, path22);
    			append(g0, path23);
    			append(g0, path24);
    			append(g0, path25);
    			append(g0, path26);
    			append(g0, path27);
    			append(g0, path28);
    			append(g0, path29);
    			append(g0, path30);
    			append(g0, path31);
    			append(g0, path32);
    			append(g0, path33);
    			append(g0, path34);
    			append(g0, path35);
    			append(g0, path36);
    			append(g0, path37);
    			append(g0, path38);
    			append(g0, path39);
    			append(g0, path40);
    			append(g0, path41);
    			append(g0, path42);
    			append(g0, path43);
    			append(g0, path44);
    			append(g0, path45);
    			append(g0, path46);
    			append(g0, path47);
    			append(g0, path48);
    			append(g0, path49);
    			append(g0, path50);
    			append(g0, path51);
    			append(g0, path52);
    			append(g0, path53);
    			append(g0, path54);
    			append(g0, path55);
    			append(g0, path56);
    			append(g0, path57);
    			append(g0, path58);
    			append(g0, path59);
    			append(g0, path60);
    			append(g0, path61);
    			append(g0, path62);
    			append(g0, path63);
    			append(g0, path64);
    			append(g0, path65);
    			append(g0, path66);
    			append(g0, path67);
    			append(g0, path68);
    			append(g0, path69);
    			append(g0, path70);
    			append(g0, path71);
    			append(g0, path72);
    			append(g0, path73);
    			append(g0, path74);
    			append(g0, path75);
    			append(g0, path76);
    			append(g0, path77);
    			append(g0, path78);
    			append(g0, path79);
    			append(g0, path80);
    			append(g0, path81);
    			append(g0, path82);
    			append(g0, path83);
    			append(g0, path84);
    			append(g0, path85);
    			append(g0, path86);
    			append(g0, path87);
    			append(g0, path88);
    			append(g0, path89);
    			append(g0, path90);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colors) && path0_fill_value !== (path0_fill_value = ctx.colors[1])) {
    				attr(path0, "fill", path0_fill_value);
    			}

    			if ((changed.colors) && path1_fill_value !== (path1_fill_value = ctx.colors[0])) {
    				attr(path1, "fill", path1_fill_value);
    			}

    			if ((changed.colors) && path2_fill_value !== (path2_fill_value = ctx.colors[2])) {
    				attr(path2, "fill", path2_fill_value);
    			}

    			if ((changed.colors) && path3_fill_value !== (path3_fill_value = ctx.colors[0])) {
    				attr(path3, "fill", path3_fill_value);
    			}

    			if ((changed.colors) && path4_fill_value !== (path4_fill_value = ctx.colors[3])) {
    				attr(path4, "fill", path4_fill_value);
    			}

    			if ((changed.colors) && path5_fill_value !== (path5_fill_value = ctx.colors[3])) {
    				attr(path5, "fill", path5_fill_value);
    			}

    			if ((changed.colors) && path6_fill_value !== (path6_fill_value = ctx.colors[4])) {
    				attr(path6, "fill", path6_fill_value);
    			}

    			if ((changed.colors) && ellipse0_fill_value !== (ellipse0_fill_value = ctx.colors[3])) {
    				attr(ellipse0, "fill", ellipse0_fill_value);
    			}

    			if ((changed.colors) && path7_fill_value !== (path7_fill_value = ctx.colors[1])) {
    				attr(path7, "fill", path7_fill_value);
    			}

    			if ((changed.colors) && path8_fill_value !== (path8_fill_value = ctx.colors[1])) {
    				attr(path8, "fill", path8_fill_value);
    			}

    			if ((changed.colors) && path9_fill_value !== (path9_fill_value = ctx.colors[0])) {
    				attr(path9, "fill", path9_fill_value);
    			}

    			if ((changed.colors) && path10_fill_value !== (path10_fill_value = ctx.colors[2])) {
    				attr(path10, "fill", path10_fill_value);
    			}

    			if ((changed.colors) && path11_fill_value !== (path11_fill_value = ctx.colors[1])) {
    				attr(path11, "fill", path11_fill_value);
    			}

    			if ((changed.colors) && path12_fill_value !== (path12_fill_value = ctx.colors[5])) {
    				attr(path12, "fill", path12_fill_value);
    			}

    			if ((changed.colors) && path13_fill_value !== (path13_fill_value = ctx.colors[1])) {
    				attr(path13, "fill", path13_fill_value);
    			}

    			if ((changed.colors) && path14_fill_value !== (path14_fill_value = ctx.colors[0])) {
    				attr(path14, "fill", path14_fill_value);
    			}

    			if ((changed.colors) && ellipse1_fill_value !== (ellipse1_fill_value = ctx.colors[3])) {
    				attr(ellipse1, "fill", ellipse1_fill_value);
    			}

    			if ((changed.colors) && ellipse2_fill_value !== (ellipse2_fill_value = ctx.colors[0])) {
    				attr(ellipse2, "fill", ellipse2_fill_value);
    			}

    			if ((changed.colors) && ellipse3_fill_value !== (ellipse3_fill_value = ctx.colors[3])) {
    				attr(ellipse3, "fill", ellipse3_fill_value);
    			}

    			if ((changed.colors) && path15_fill_value !== (path15_fill_value = ctx.colors[3])) {
    				attr(path15, "fill", path15_fill_value);
    			}

    			if ((changed.colors) && path16_fill_value !== (path16_fill_value = ctx.colors[2])) {
    				attr(path16, "fill", path16_fill_value);
    			}

    			if ((changed.colors) && path17_fill_value !== (path17_fill_value = ctx.colors[0])) {
    				attr(path17, "fill", path17_fill_value);
    			}

    			if ((changed.colors) && path18_fill_value !== (path18_fill_value = ctx.colors[1])) {
    				attr(path18, "fill", path18_fill_value);
    			}

    			if ((changed.colors) && path19_fill_value !== (path19_fill_value = ctx.colors[1])) {
    				attr(path19, "fill", path19_fill_value);
    			}

    			if ((changed.colors) && path20_fill_value !== (path20_fill_value = ctx.colors[0])) {
    				attr(path20, "fill", path20_fill_value);
    			}

    			if ((changed.colors) && path21_fill_value !== (path21_fill_value = ctx.colors[3])) {
    				attr(path21, "fill", path21_fill_value);
    			}

    			if ((changed.colors) && path22_fill_value !== (path22_fill_value = ctx.colors[4])) {
    				attr(path22, "fill", path22_fill_value);
    			}

    			if ((changed.colors) && path23_fill_value !== (path23_fill_value = ctx.colors[3])) {
    				attr(path23, "fill", path23_fill_value);
    			}

    			if ((changed.colors) && path24_fill_value !== (path24_fill_value = ctx.colors[0])) {
    				attr(path24, "fill", path24_fill_value);
    			}

    			if ((changed.colors) && path25_fill_value !== (path25_fill_value = ctx.colors[4])) {
    				attr(path25, "fill", path25_fill_value);
    			}

    			if ((changed.colors) && path26_fill_value !== (path26_fill_value = ctx.colors[3])) {
    				attr(path26, "fill", path26_fill_value);
    			}

    			if ((changed.colors) && path27_fill_value !== (path27_fill_value = ctx.colors[1])) {
    				attr(path27, "fill", path27_fill_value);
    			}

    			if ((changed.colors) && path28_fill_value !== (path28_fill_value = ctx.colors[3])) {
    				attr(path28, "fill", path28_fill_value);
    			}

    			if ((changed.colors) && path29_fill_value !== (path29_fill_value = ctx.colors[0])) {
    				attr(path29, "fill", path29_fill_value);
    			}

    			if ((changed.colors) && path30_fill_value !== (path30_fill_value = ctx.colors[0])) {
    				attr(path30, "fill", path30_fill_value);
    			}

    			if ((changed.colors) && path31_fill_value !== (path31_fill_value = ctx.colors[2])) {
    				attr(path31, "fill", path31_fill_value);
    			}

    			if ((changed.colors) && path32_fill_value !== (path32_fill_value = ctx.colors[2])) {
    				attr(path32, "fill", path32_fill_value);
    			}

    			if ((changed.colors) && path33_fill_value !== (path33_fill_value = ctx.colors[0])) {
    				attr(path33, "fill", path33_fill_value);
    			}

    			if ((changed.colors) && path34_fill_value !== (path34_fill_value = ctx.colors[5])) {
    				attr(path34, "fill", path34_fill_value);
    			}

    			if ((changed.colors) && path35_fill_value !== (path35_fill_value = ctx.colors[5])) {
    				attr(path35, "fill", path35_fill_value);
    			}

    			if ((changed.colors) && path36_fill_value !== (path36_fill_value = ctx.colors[4])) {
    				attr(path36, "fill", path36_fill_value);
    			}

    			if ((changed.colors) && path37_fill_value !== (path37_fill_value = ctx.colors[4])) {
    				attr(path37, "fill", path37_fill_value);
    			}

    			if ((changed.colors) && path38_fill_value !== (path38_fill_value = ctx.colors[1])) {
    				attr(path38, "fill", path38_fill_value);
    			}

    			if ((changed.colors) && path39_fill_value !== (path39_fill_value = ctx.colors[0])) {
    				attr(path39, "fill", path39_fill_value);
    			}

    			if ((changed.colors) && path40_fill_value !== (path40_fill_value = ctx.colors[5])) {
    				attr(path40, "fill", path40_fill_value);
    			}

    			if ((changed.colors) && path41_fill_value !== (path41_fill_value = ctx.colors[2])) {
    				attr(path41, "fill", path41_fill_value);
    			}

    			if ((changed.colors) && path42_fill_value !== (path42_fill_value = ctx.colors[1])) {
    				attr(path42, "fill", path42_fill_value);
    			}

    			if ((changed.colors) && path43_fill_value !== (path43_fill_value = ctx.colors[3])) {
    				attr(path43, "fill", path43_fill_value);
    			}

    			if ((changed.colors) && path44_fill_value !== (path44_fill_value = ctx.colors[1])) {
    				attr(path44, "fill", path44_fill_value);
    			}

    			if ((changed.colors) && path45_fill_value !== (path45_fill_value = ctx.colors[3])) {
    				attr(path45, "fill", path45_fill_value);
    			}

    			if ((changed.colors) && path46_fill_value !== (path46_fill_value = ctx.colors[2])) {
    				attr(path46, "fill", path46_fill_value);
    			}

    			if ((changed.colors) && path47_fill_value !== (path47_fill_value = ctx.colors[2])) {
    				attr(path47, "fill", path47_fill_value);
    			}

    			if ((changed.colors) && path48_fill_value !== (path48_fill_value = ctx.colors[3])) {
    				attr(path48, "fill", path48_fill_value);
    			}

    			if ((changed.colors) && path49_fill_value !== (path49_fill_value = ctx.colors[0])) {
    				attr(path49, "fill", path49_fill_value);
    			}

    			if ((changed.colors) && path50_fill_value !== (path50_fill_value = ctx.colors[0])) {
    				attr(path50, "fill", path50_fill_value);
    			}

    			if ((changed.colors) && path51_fill_value !== (path51_fill_value = ctx.colors[1])) {
    				attr(path51, "fill", path51_fill_value);
    			}

    			if ((changed.colors) && path52_fill_value !== (path52_fill_value = ctx.colors[3])) {
    				attr(path52, "fill", path52_fill_value);
    			}

    			if ((changed.colors) && path53_fill_value !== (path53_fill_value = ctx.colors[4])) {
    				attr(path53, "fill", path53_fill_value);
    			}

    			if ((changed.colors) && path54_fill_value !== (path54_fill_value = ctx.colors[0])) {
    				attr(path54, "fill", path54_fill_value);
    			}

    			if ((changed.colors) && path55_fill_value !== (path55_fill_value = ctx.colors[0])) {
    				attr(path55, "fill", path55_fill_value);
    			}

    			if ((changed.colors) && path56_fill_value !== (path56_fill_value = ctx.colors[1])) {
    				attr(path56, "fill", path56_fill_value);
    			}

    			if ((changed.colors) && path57_fill_value !== (path57_fill_value = ctx.colors[0])) {
    				attr(path57, "fill", path57_fill_value);
    			}

    			if ((changed.colors) && path58_fill_value !== (path58_fill_value = ctx.colors[4])) {
    				attr(path58, "fill", path58_fill_value);
    			}

    			if ((changed.colors) && path59_fill_value !== (path59_fill_value = ctx.colors[0])) {
    				attr(path59, "fill", path59_fill_value);
    			}

    			if ((changed.colors) && path60_fill_value !== (path60_fill_value = ctx.colors[1])) {
    				attr(path60, "fill", path60_fill_value);
    			}

    			if ((changed.colors) && path61_fill_value !== (path61_fill_value = ctx.colors[2])) {
    				attr(path61, "fill", path61_fill_value);
    			}

    			if ((changed.colors) && path62_fill_value !== (path62_fill_value = ctx.colors[3])) {
    				attr(path62, "fill", path62_fill_value);
    			}

    			if ((changed.colors) && path63_fill_value !== (path63_fill_value = ctx.colors[0])) {
    				attr(path63, "fill", path63_fill_value);
    			}

    			if ((changed.colors) && path64_fill_value !== (path64_fill_value = ctx.colors[4])) {
    				attr(path64, "fill", path64_fill_value);
    			}

    			if ((changed.colors) && path65_fill_value !== (path65_fill_value = ctx.colors[4])) {
    				attr(path65, "fill", path65_fill_value);
    			}

    			if ((changed.colors) && path66_fill_value !== (path66_fill_value = ctx.colors[3])) {
    				attr(path66, "fill", path66_fill_value);
    			}

    			if ((changed.colors) && path67_fill_value !== (path67_fill_value = ctx.colors[5])) {
    				attr(path67, "fill", path67_fill_value);
    			}

    			if ((changed.colors) && path68_fill_value !== (path68_fill_value = ctx.colors[5])) {
    				attr(path68, "fill", path68_fill_value);
    			}

    			if ((changed.colors) && path69_fill_value !== (path69_fill_value = ctx.colors[4])) {
    				attr(path69, "fill", path69_fill_value);
    			}

    			if ((changed.colors) && path70_fill_value !== (path70_fill_value = ctx.colors[2])) {
    				attr(path70, "fill", path70_fill_value);
    			}

    			if ((changed.colors) && path71_fill_value !== (path71_fill_value = ctx.colors[2])) {
    				attr(path71, "fill", path71_fill_value);
    			}

    			if ((changed.colors) && path72_fill_value !== (path72_fill_value = ctx.colors[2])) {
    				attr(path72, "fill", path72_fill_value);
    			}

    			if ((changed.colors) && path73_fill_value !== (path73_fill_value = ctx.colors[2])) {
    				attr(path73, "fill", path73_fill_value);
    			}

    			if ((changed.colors) && path74_fill_value !== (path74_fill_value = ctx.colors[2])) {
    				attr(path74, "fill", path74_fill_value);
    			}

    			if ((changed.colors) && path75_fill_value !== (path75_fill_value = ctx.colors[1])) {
    				attr(path75, "fill", path75_fill_value);
    			}

    			if ((changed.colors) && path76_fill_value !== (path76_fill_value = ctx.colors[1])) {
    				attr(path76, "fill", path76_fill_value);
    			}

    			if ((changed.colors) && path77_fill_value !== (path77_fill_value = ctx.colors[4])) {
    				attr(path77, "fill", path77_fill_value);
    			}

    			if ((changed.colors) && path78_fill_value !== (path78_fill_value = ctx.colors[0])) {
    				attr(path78, "fill", path78_fill_value);
    			}

    			if ((changed.colors) && path79_fill_value !== (path79_fill_value = ctx.colors[3])) {
    				attr(path79, "fill", path79_fill_value);
    			}

    			if ((changed.colors) && path80_fill_value !== (path80_fill_value = ctx.colors[4])) {
    				attr(path80, "fill", path80_fill_value);
    			}

    			if ((changed.colors) && path81_fill_value !== (path81_fill_value = ctx.colors[0])) {
    				attr(path81, "fill", path81_fill_value);
    			}

    			if ((changed.colors) && path82_fill_value !== (path82_fill_value = ctx.colors[4])) {
    				attr(path82, "fill", path82_fill_value);
    			}

    			if ((changed.colors) && path83_fill_value !== (path83_fill_value = ctx.colors[0])) {
    				attr(path83, "fill", path83_fill_value);
    			}

    			if ((changed.colors) && path84_fill_value !== (path84_fill_value = ctx.colors[0])) {
    				attr(path84, "fill", path84_fill_value);
    			}

    			if ((changed.colors) && path85_fill_value !== (path85_fill_value = ctx.colors[5])) {
    				attr(path85, "fill", path85_fill_value);
    			}

    			if ((changed.colors) && path86_fill_value !== (path86_fill_value = ctx.colors[4])) {
    				attr(path86, "fill", path86_fill_value);
    			}

    			if ((changed.colors) && path87_fill_value !== (path87_fill_value = ctx.colors[5])) {
    				attr(path87, "fill", path87_fill_value);
    			}

    			if ((changed.colors) && path88_fill_value !== (path88_fill_value = ctx.colors[4])) {
    				attr(path88, "fill", path88_fill_value);
    			}

    			if ((changed.colors) && path89_fill_value !== (path89_fill_value = ctx.colors[3])) {
    				attr(path89, "fill", path89_fill_value);
    			}

    			if ((changed.colors) && path90_fill_value !== (path90_fill_value = ctx.colors[3])) {
    				attr(path90, "fill", path90_fill_value);
    			}

    			if (changed.styles) {
    				attr(svg, "style", ctx.styles);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(svg);
    			}
    		}
    	};
    }

    function instance$4($$self, $$props, $$invalidate) {

      let { colors, styles } = $$props;

    	const writable_props = ['colors', 'styles'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Inn> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('colors' in $$props) $$invalidate('colors', colors = $$props.colors);
    		if ('styles' in $$props) $$invalidate('styles', styles = $$props.styles);
    	};

    	return { colors, styles };
    }

    class Inn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, ["colors", "styles"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.colors === undefined && !('colors' in props)) {
    			console.warn("<Inn> was created without expected prop 'colors'");
    		}
    		if (ctx.styles === undefined && !('styles' in props)) {
    			console.warn("<Inn> was created without expected prop 'styles'");
    		}
    	}

    	get colors() {
    		throw new Error("<Inn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colors(value) {
    		throw new Error("<Inn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Inn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Inn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/patterns/Kander.svelte generated by Svelte v3.6.7 */

    const file$5 = "src/patterns/Kander.svelte";

    function create_fragment$5(ctx) {
    	var svg, g49, g48, g47, g0, rect0, g0_fill_value, g1, rect1, rect1_fill_value, polygon0, polygon0_fill_value, g2, path0, path0_fill_value, polygon1, polygon1_fill_value, polygon2, polygon2_fill_value, path1, path1_fill_value, g3, path2, path2_fill_value, polygon3, polygon3_fill_value, polygon4, polygon4_fill_value, path3, path3_fill_value, g4, rect2, rect2_fill_value, rect3, rect3_fill_value, rect4, rect4_fill_value, g5, polygon5, polygon5_fill_value, rect5, rect5_fill_value, g6, rect6, rect6_fill_value, polygon6, polygon6_fill_value, g7, rect7, rect7_fill_value, polygon7, polygon7_fill_value, g8, rect8, rect8_fill_value, polygon8, polygon8_fill_value, g9, rect9, rect9_fill_value, rect10, rect10_fill_value, g10, rect11, g10_fill_value, g11, rect12, rect12_fill_value, polygon9, polygon9_fill_value, g12, rect13, rect13_fill_value, rect14, rect14_fill_value, g13, rect15, g13_fill_value, g14, rect16, rect16_fill_value, path4, path4_fill_value, rect17, rect17_fill_value, g15, rect18, rect18_fill_value, path5, path5_fill_value, g16, rect19, rect19_fill_value, rect20, rect20_fill_value, polygon10, polygon10_fill_value, g17, rect21, rect21_fill_value, rect22, rect22_fill_value, polygon11, polygon11_fill_value, g18, rect23, rect23_fill_value, rect24, rect24_fill_value, polygon12, polygon12_fill_value, g19, polygon13, polygon13_fill_value, polygon14, polygon14_fill_value, path6, path6_fill_value, g20, polygon15, polygon15_fill_value, polygon16, polygon16_fill_value, g21, polygon17, polygon17_fill_value, rect25, rect25_fill_value, g22, polygon18, g22_fill_value, g23, polygon19, g23_fill_value, g24, polygon20, polygon20_fill_value, rect26, rect26_fill_value, polygon21, polygon21_fill_value, g25, polygon22, polygon22_fill_value, rect27, rect27_fill_value, polygon23, polygon23_fill_value, g26, polygon24, polygon24_fill_value, rect28, rect28_fill_value, polygon25, polygon25_fill_value, g27, polygon26, polygon26_fill_value, rect29, rect29_fill_value, g28, polygon27, polygon27_fill_value, rect30, rect30_fill_value, g29, polygon28, g29_fill_value, g30, polygon29, g30_fill_value, g32, rect31, rect31_fill_value, g31, polygon30, polygon30_fill_value, polygon31, polygon31_fill_value, polygon32, polygon32_fill_value, g33, rect32, rect32_fill_value, polygon33, polygon33_fill_value, polygon34, polygon34_fill_value, polygon35, polygon35_fill_value, g35, rect33, rect33_fill_value, polygon36, polygon36_fill_value, g34, polygon37, polygon38, g34_fill_value, g36, rect34, rect34_fill_value, polygon39, polygon39_fill_value, g37, polygon40, g37_fill_value, g38, path7, path7_fill_value, path8, path8_fill_value, g39, path9, path9_fill_value, path10, path10_fill_value, g40, path11, g40_fill_value, g41, path12, path12_fill_value, rect35, rect35_fill_value, g42, path13, path13_fill_value, rect36, rect36_fill_value, g43, polygon41, polygon42, polygon43, polygon44, g43_fill_value, g44, polygon45, polygon46, polygon47, polygon48, g44_fill_value, g45, polygon49, polygon50, polygon51, polygon52, g45_fill_value, g46, polygon53, polygon53_fill_value, polygon54, polygon54_fill_value, polygon55, polygon55_fill_value, polygon56, polygon56_fill_value;

    	return {
    		c: function create() {
    			svg = svg_element("svg");
    			g49 = svg_element("g");
    			g48 = svg_element("g");
    			g47 = svg_element("g");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			g1 = svg_element("g");
    			rect1 = svg_element("rect");
    			polygon0 = svg_element("polygon");
    			g2 = svg_element("g");
    			path0 = svg_element("path");
    			polygon1 = svg_element("polygon");
    			polygon2 = svg_element("polygon");
    			path1 = svg_element("path");
    			g3 = svg_element("g");
    			path2 = svg_element("path");
    			polygon3 = svg_element("polygon");
    			polygon4 = svg_element("polygon");
    			path3 = svg_element("path");
    			g4 = svg_element("g");
    			rect2 = svg_element("rect");
    			rect3 = svg_element("rect");
    			rect4 = svg_element("rect");
    			g5 = svg_element("g");
    			polygon5 = svg_element("polygon");
    			rect5 = svg_element("rect");
    			g6 = svg_element("g");
    			rect6 = svg_element("rect");
    			polygon6 = svg_element("polygon");
    			g7 = svg_element("g");
    			rect7 = svg_element("rect");
    			polygon7 = svg_element("polygon");
    			g8 = svg_element("g");
    			rect8 = svg_element("rect");
    			polygon8 = svg_element("polygon");
    			g9 = svg_element("g");
    			rect9 = svg_element("rect");
    			rect10 = svg_element("rect");
    			g10 = svg_element("g");
    			rect11 = svg_element("rect");
    			g11 = svg_element("g");
    			rect12 = svg_element("rect");
    			polygon9 = svg_element("polygon");
    			g12 = svg_element("g");
    			rect13 = svg_element("rect");
    			rect14 = svg_element("rect");
    			g13 = svg_element("g");
    			rect15 = svg_element("rect");
    			g14 = svg_element("g");
    			rect16 = svg_element("rect");
    			path4 = svg_element("path");
    			rect17 = svg_element("rect");
    			g15 = svg_element("g");
    			rect18 = svg_element("rect");
    			path5 = svg_element("path");
    			g16 = svg_element("g");
    			rect19 = svg_element("rect");
    			rect20 = svg_element("rect");
    			polygon10 = svg_element("polygon");
    			g17 = svg_element("g");
    			rect21 = svg_element("rect");
    			rect22 = svg_element("rect");
    			polygon11 = svg_element("polygon");
    			g18 = svg_element("g");
    			rect23 = svg_element("rect");
    			rect24 = svg_element("rect");
    			polygon12 = svg_element("polygon");
    			g19 = svg_element("g");
    			polygon13 = svg_element("polygon");
    			polygon14 = svg_element("polygon");
    			path6 = svg_element("path");
    			g20 = svg_element("g");
    			polygon15 = svg_element("polygon");
    			polygon16 = svg_element("polygon");
    			g21 = svg_element("g");
    			polygon17 = svg_element("polygon");
    			rect25 = svg_element("rect");
    			g22 = svg_element("g");
    			polygon18 = svg_element("polygon");
    			g23 = svg_element("g");
    			polygon19 = svg_element("polygon");
    			g24 = svg_element("g");
    			polygon20 = svg_element("polygon");
    			rect26 = svg_element("rect");
    			polygon21 = svg_element("polygon");
    			g25 = svg_element("g");
    			polygon22 = svg_element("polygon");
    			rect27 = svg_element("rect");
    			polygon23 = svg_element("polygon");
    			g26 = svg_element("g");
    			polygon24 = svg_element("polygon");
    			rect28 = svg_element("rect");
    			polygon25 = svg_element("polygon");
    			g27 = svg_element("g");
    			polygon26 = svg_element("polygon");
    			rect29 = svg_element("rect");
    			g28 = svg_element("g");
    			polygon27 = svg_element("polygon");
    			rect30 = svg_element("rect");
    			g29 = svg_element("g");
    			polygon28 = svg_element("polygon");
    			g30 = svg_element("g");
    			polygon29 = svg_element("polygon");
    			g32 = svg_element("g");
    			rect31 = svg_element("rect");
    			g31 = svg_element("g");
    			polygon30 = svg_element("polygon");
    			polygon31 = svg_element("polygon");
    			polygon32 = svg_element("polygon");
    			g33 = svg_element("g");
    			rect32 = svg_element("rect");
    			polygon33 = svg_element("polygon");
    			polygon34 = svg_element("polygon");
    			polygon35 = svg_element("polygon");
    			g35 = svg_element("g");
    			rect33 = svg_element("rect");
    			polygon36 = svg_element("polygon");
    			g34 = svg_element("g");
    			polygon37 = svg_element("polygon");
    			polygon38 = svg_element("polygon");
    			g36 = svg_element("g");
    			rect34 = svg_element("rect");
    			polygon39 = svg_element("polygon");
    			g37 = svg_element("g");
    			polygon40 = svg_element("polygon");
    			g38 = svg_element("g");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			g39 = svg_element("g");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			g40 = svg_element("g");
    			path11 = svg_element("path");
    			g41 = svg_element("g");
    			path12 = svg_element("path");
    			rect35 = svg_element("rect");
    			g42 = svg_element("g");
    			path13 = svg_element("path");
    			rect36 = svg_element("rect");
    			g43 = svg_element("g");
    			polygon41 = svg_element("polygon");
    			polygon42 = svg_element("polygon");
    			polygon43 = svg_element("polygon");
    			polygon44 = svg_element("polygon");
    			g44 = svg_element("g");
    			polygon45 = svg_element("polygon");
    			polygon46 = svg_element("polygon");
    			polygon47 = svg_element("polygon");
    			polygon48 = svg_element("polygon");
    			g45 = svg_element("g");
    			polygon49 = svg_element("polygon");
    			polygon50 = svg_element("polygon");
    			polygon51 = svg_element("polygon");
    			polygon52 = svg_element("polygon");
    			g46 = svg_element("g");
    			polygon53 = svg_element("polygon");
    			polygon54 = svg_element("polygon");
    			polygon55 = svg_element("polygon");
    			polygon56 = svg_element("polygon");
    			attr(rect0, "id", "Shape");
    			attr(rect0, "x", "0");
    			attr(rect0, "y", "0");
    			attr(rect0, "width", "200");
    			attr(rect0, "height", "200");
    			add_location(rect0, file$5, 15, 10, 620);
    			attr(g0, "transform", "translate(0.000000, 201.000000)");
    			attr(g0, "fill", g0_fill_value = ctx.colors[0]);
    			add_location(g0, file$5, 14, 8, 543);
    			attr(rect1, "id", "Shape");
    			attr(rect1, "fill", rect1_fill_value = ctx.colors[1]);
    			attr(rect1, "x", "0");
    			attr(rect1, "y", "0");
    			attr(rect1, "width", "200");
    			attr(rect1, "height", "200");
    			add_location(rect1, file$5, 18, 10, 764);
    			attr(polygon0, "id", "Shape");
    			attr(polygon0, "fill", polygon0_fill_value = ctx.colors[2]);
    			attr(polygon0, "points", "0 0 200 200 0 200");
    			add_location(polygon0, file$5, 19, 10, 855);
    			attr(g1, "transform", "translate(1400.000000, 801.000000)");
    			add_location(g1, file$5, 17, 8, 703);
    			attr(path0, "d", "M299,26 C340.421356,26 374,59.5786438 374,101 C374,142.421356 340.421356,176 299,176 C257.578644,176 224,142.421356 224,101 C224,59.5786438 257.578644,26 299,26 Z");
    			attr(path0, "id", "Shape");
    			attr(path0, "fill", path0_fill_value = ctx.colors[2]);
    			add_location(path0, file$5, 22, 10, 1013);
    			attr(polygon1, "id", "Shape");
    			attr(polygon1, "fill", polygon1_fill_value = ctx.colors[3]);
    			attr(polygon1, "points", "0 0 199.376947 0 400 200 0 200");
    			add_location(polygon1, file$5, 23, 10, 1234);
    			attr(polygon2, "id", "Shape");
    			attr(polygon2, "fill", polygon2_fill_value = ctx.colors[5]);
    			attr(polygon2, "transform", "translate(100.000000, 100.000000) scale(-1, 1) translate(-100.000000, -100.000000) ");
    			attr(polygon2, "points", "0 0 200 200 0 200");
    			add_location(polygon2, file$5, 24, 10, 1334);
    			attr(path1, "d", "M99,56 L100,56 C124.852814,56 145,76.1471863 145,101 C145,125.852814 124.852814,146 100,146 L99,146 C74.1471863,146 54,125.852814 54,101 C54,76.1471863 74.1471863,56 99,56 Z");
    			attr(path1, "id", "Shape");
    			attr(path1, "fill", path1_fill_value = ctx.colors[6]);
    			add_location(path1, file$5, 25, 10, 1517);
    			attr(g2, "transform", "translate(200.000000, 801.000000)");
    			add_location(g2, file$5, 21, 8, 953);
    			attr(path2, "d", "M299,26 C340.421356,26 374,59.5786438 374,101 C374,142.421356 340.421356,176 299,176 C257.578644,176 224,142.421356 224,101 C224,59.5786438 257.578644,26 299,26 Z");
    			attr(path2, "id", "Shape");
    			attr(path2, "fill", path2_fill_value = ctx.colors[1]);
    			add_location(path2, file$5, 28, 10, 1819);
    			attr(polygon3, "id", "Shape");
    			attr(polygon3, "fill", polygon3_fill_value = ctx.colors[5]);
    			attr(polygon3, "points", "0 0 199.376947 0 400 200 0 200");
    			add_location(polygon3, file$5, 29, 10, 2040);
    			attr(polygon4, "id", "Shape");
    			attr(polygon4, "fill", polygon4_fill_value = ctx.colors[3]);
    			attr(polygon4, "transform", "translate(100.000000, 100.000000) scale(-1, 1) translate(-100.000000, -100.000000) ");
    			attr(polygon4, "points", "0 0 200 200 0 200");
    			add_location(polygon4, file$5, 30, 10, 2140);
    			attr(path3, "d", "M99,56 L100,56 C124.852814,56 145,76.1471863 145,101 C145,125.852814 124.852814,146 100,146 L99,146 C74.1471863,146 54,125.852814 54,101 C54,76.1471863 74.1471863,56 99,56 Z");
    			attr(path3, "id", "Shape");
    			attr(path3, "fill", path3_fill_value = ctx.colors[6]);
    			add_location(path3, file$5, 31, 10, 2323);
    			attr(g3, "transform", "translate(1000.000000, 1.000000)");
    			add_location(g3, file$5, 27, 8, 1760);
    			attr(rect2, "id", "Shape");
    			attr(rect2, "fill", rect2_fill_value = ctx.colors[5]);
    			attr(rect2, "x", "0");
    			attr(rect2, "y", "0");
    			attr(rect2, "width", "200");
    			attr(rect2, "height", "400");
    			add_location(rect2, file$5, 34, 10, 2626);
    			attr(rect3, "id", "Shape");
    			attr(rect3, "fill", rect3_fill_value = ctx.colors[7]);
    			attr(rect3, "x", "100");
    			attr(rect3, "y", "100");
    			attr(rect3, "width", "100");
    			attr(rect3, "height", "100.250627");
    			add_location(rect3, file$5, 35, 10, 2717);
    			attr(rect4, "id", "Shape");
    			attr(rect4, "fill", rect4_fill_value = ctx.colors[6]);
    			attr(rect4, "x", "0");
    			attr(rect4, "y", "200");
    			attr(rect4, "width", "100");
    			attr(rect4, "height", "100.250627");
    			add_location(rect4, file$5, 36, 10, 2819);
    			attr(g4, "transform", "translate(600.000000, 801.000000)");
    			add_location(g4, file$5, 33, 8, 2566);
    			attr(polygon5, "id", "Shape");
    			attr(polygon5, "fill", polygon5_fill_value = ctx.colors[7]);
    			attr(polygon5, "points", "-2.4158453e-11 -1.15292436e-11 200 -1.15292436e-11 200 200 1.42108547e-12 200");
    			add_location(polygon5, file$5, 39, 10, 3083);
    			attr(rect5, "id", "Shape");
    			attr(rect5, "fill", rect5_fill_value = ctx.colors[0]);
    			attr(rect5, "x", "100");
    			attr(rect5, "y", "100");
    			attr(rect5, "width", "100");
    			attr(rect5, "height", "100");
    			add_location(rect5, file$5, 40, 10, 3230);
    			attr(g5, "transform", "translate(1500.000000, 301.000000) rotate(-270.000000) translate(-1500.000000, -301.000000) translate(1400.000000, 201.000000)");
    			add_location(g5, file$5, 38, 8, 2930);
    			attr(rect6, "id", "Shape");
    			attr(rect6, "fill", rect6_fill_value = ctx.colors[3]);
    			attr(rect6, "x", "0");
    			attr(rect6, "y", "0");
    			attr(rect6, "width", "200");
    			attr(rect6, "height", "200");
    			add_location(rect6, file$5, 43, 10, 3394);
    			attr(polygon6, "id", "Shape");
    			attr(polygon6, "fill", polygon6_fill_value = ctx.colors[2]);
    			attr(polygon6, "points", "100 33 143.06677 48.6750223 165.982119 88.3655721 158.023702 133.5 122.91535 162.959406 77.0846504 162.959406 41.9762979 133.5 34.0178805 88.3655721 56.9332302 48.6750223");
    			add_location(polygon6, file$5, 44, 10, 3485);
    			attr(g6, "transform", "translate(0.000000, 801.000000)");
    			add_location(g6, file$5, 42, 8, 3336);
    			attr(rect7, "id", "Shape");
    			attr(rect7, "fill", rect7_fill_value = ctx.colors[6]);
    			attr(rect7, "x", "0");
    			attr(rect7, "y", "0");
    			attr(rect7, "width", "200");
    			attr(rect7, "height", "200");
    			add_location(rect7, file$5, 47, 10, 3798);
    			attr(polygon7, "id", "Shape");
    			attr(polygon7, "fill", polygon7_fill_value = ctx.colors[5]);
    			attr(polygon7, "points", "100 33 143.06677 48.6750223 165.982119 88.3655721 158.023702 133.5 122.91535 162.959406 77.0846504 162.959406 41.9762979 133.5 34.0178805 88.3655721 56.9332302 48.6750223");
    			add_location(polygon7, file$5, 48, 10, 3889);
    			attr(g7, "transform", "translate(1400.000000, 1001.000000)");
    			add_location(g7, file$5, 46, 8, 3736);
    			attr(rect8, "id", "Shape");
    			attr(rect8, "fill", rect8_fill_value = ctx.colors[3]);
    			attr(rect8, "x", "0");
    			attr(rect8, "y", "0");
    			attr(rect8, "width", "200");
    			attr(rect8, "height", "200");
    			add_location(rect8, file$5, 51, 10, 4198);
    			attr(polygon8, "id", "Shape");
    			attr(polygon8, "fill", polygon8_fill_value = ctx.colors[6]);
    			attr(polygon8, "points", "100 33 143.06677 48.6750223 165.982119 88.3655721 158.023702 133.5 122.91535 162.959406 77.0846504 162.959406 41.9762979 133.5 34.0178805 88.3655721 56.9332302 48.6750223");
    			add_location(polygon8, file$5, 52, 10, 4289);
    			attr(g8, "transform", "translate(800.000000, 1.000000)");
    			add_location(g8, file$5, 50, 8, 4140);
    			attr(rect9, "id", "Shape");
    			attr(rect9, "fill", rect9_fill_value = ctx.colors[7]);
    			attr(rect9, "x", "0");
    			attr(rect9, "y", "0");
    			attr(rect9, "width", "200");
    			attr(rect9, "height", "200");
    			add_location(rect9, file$5, 55, 10, 4689);
    			attr(rect10, "id", "Shape");
    			attr(rect10, "fill", rect10_fill_value = ctx.colors[0]);
    			attr(rect10, "x", "0");
    			attr(rect10, "y", "0");
    			attr(rect10, "width", "100");
    			attr(rect10, "height", "200");
    			add_location(rect10, file$5, 56, 10, 4780);
    			attr(g9, "transform", "translate(900.000000, 901.000000) rotate(-90.000000) translate(-900.000000, -901.000000) translate(800.000000, 801.000000)");
    			add_location(g9, file$5, 54, 8, 4540);
    			attr(rect11, "id", "Shape");
    			attr(rect11, "x", "0");
    			attr(rect11, "y", "0");
    			attr(rect11, "width", "200");
    			attr(rect11, "height", "200");
    			add_location(rect11, file$5, 59, 10, 4959);
    			attr(g10, "transform", "translate(600.000000, 1.000000)");
    			attr(g10, "fill", g10_fill_value = ctx.colors[2]);
    			add_location(g10, file$5, 58, 8, 4882);
    			attr(rect12, "id", "Shape");
    			attr(rect12, "fill", rect12_fill_value = ctx.colors[2]);
    			attr(rect12, "x", "0");
    			attr(rect12, "y", "0");
    			attr(rect12, "width", "200");
    			attr(rect12, "height", "200");
    			add_location(rect12, file$5, 62, 10, 5103);
    			attr(polygon9, "id", "Shape");
    			attr(polygon9, "fill", polygon9_fill_value = ctx.colors[1]);
    			attr(polygon9, "transform", "translate(100.000000, 100.000000) scale(-1, 1) translate(-100.000000, -100.000000) ");
    			attr(polygon9, "points", "0 0 200 200 0 200");
    			add_location(polygon9, file$5, 63, 10, 5194);
    			attr(g11, "transform", "translate(1000.000000, 801.000000)");
    			add_location(g11, file$5, 61, 8, 5042);
    			attr(rect13, "id", "Shape");
    			attr(rect13, "fill", rect13_fill_value = ctx.colors[7]);
    			attr(rect13, "x", "0");
    			attr(rect13, "y", "0");
    			attr(rect13, "width", "200");
    			attr(rect13, "height", "200");
    			add_location(rect13, file$5, 66, 10, 5448);
    			attr(rect14, "id", "Shape");
    			attr(rect14, "fill", rect14_fill_value = ctx.colors[0]);
    			attr(rect14, "x", "0");
    			attr(rect14, "y", "0");
    			attr(rect14, "width", "101");
    			attr(rect14, "height", "200");
    			add_location(rect14, file$5, 67, 10, 5539);
    			attr(g12, "transform", "translate(400.000000, 401.000000)");
    			add_location(g12, file$5, 65, 8, 5388);
    			attr(rect15, "id", "Shape");
    			attr(rect15, "x", "0");
    			attr(rect15, "y", "0");
    			attr(rect15, "width", "200");
    			attr(rect15, "height", "200");
    			add_location(rect15, file$5, 70, 10, 5721);
    			attr(g13, "transform", "translate(400.000000, 1001.000000)");
    			attr(g13, "fill", g13_fill_value = ctx.colors[2]);
    			add_location(g13, file$5, 69, 8, 5641);
    			attr(rect16, "id", "Shape");
    			attr(rect16, "fill", rect16_fill_value = ctx.colors[3]);
    			attr(rect16, "x", "0");
    			attr(rect16, "y", "0");
    			attr(rect16, "width", "200");
    			attr(rect16, "height", "200");
    			add_location(rect16, file$5, 73, 10, 5865);
    			attr(path4, "d", "M50,100 C77.6142375,100 100,122.385763 100,150 C100,177.614237 77.6142375,200 50,200 C22.3857625,200 0,177.614237 0,150 C0,122.385763 22.3857625,100 50,100 Z");
    			attr(path4, "id", "Shape");
    			attr(path4, "fill", path4_fill_value = ctx.colors[0]);
    			add_location(path4, file$5, 74, 10, 5956);
    			attr(rect17, "id", "Shape");
    			attr(rect17, "fill", rect17_fill_value = ctx.colors[5]);
    			attr(rect17, "x", "100");
    			attr(rect17, "y", "0");
    			attr(rect17, "width", "100");
    			attr(rect17, "height", "100");
    			add_location(rect17, file$5, 75, 10, 6172);
    			attr(g14, "transform", "translate(1000.000000, 401.000000)");
    			add_location(g14, file$5, 72, 8, 5804);
    			attr(rect18, "id", "Shape");
    			attr(rect18, "fill", rect18_fill_value = ctx.colors[3]);
    			attr(rect18, "x", "0");
    			attr(rect18, "y", "0");
    			attr(rect18, "width", "200");
    			attr(rect18, "height", "200");
    			add_location(rect18, file$5, 78, 10, 6336);
    			attr(path5, "d", "M100,55 C124.852814,55 145,75.1471863 145,100 C145,124.852814 124.852814,145 100,145 C75.1471863,145 55,124.852814 55,100 C55,75.1471863 75.1471863,55 100,55 Z");
    			attr(path5, "id", "Shape");
    			attr(path5, "fill", path5_fill_value = ctx.colors[1]);
    			add_location(path5, file$5, 79, 10, 6427);
    			attr(g15, "transform", "translate(800.000000, 601.000000)");
    			add_location(g15, file$5, 77, 8, 6276);
    			attr(rect19, "id", "Shape");
    			attr(rect19, "fill", rect19_fill_value = ctx.colors[5]);
    			attr(rect19, "x", "0");
    			attr(rect19, "y", "0");
    			attr(rect19, "width", "200");
    			attr(rect19, "height", "200");
    			add_location(rect19, file$5, 82, 10, 6717);
    			attr(rect20, "id", "Shape");
    			attr(rect20, "fill", rect20_fill_value = ctx.colors[3]);
    			attr(rect20, "x", "30");
    			attr(rect20, "y", "30");
    			attr(rect20, "width", "140");
    			attr(rect20, "height", "140");
    			add_location(rect20, file$5, 83, 10, 6808);
    			attr(polygon10, "id", "Shape");
    			attr(polygon10, "fill", polygon10_fill_value = ctx.colors[6]);
    			attr(polygon10, "transform", "translate(50.000000, 50.000000) scale(-1, -1) translate(-50.000000, -50.000000) ");
    			attr(polygon10, "points", "0 0 100 100 0 100");
    			add_location(polygon10, file$5, 84, 10, 6901);
    			attr(g16, "transform", "translate(1000.000000, 601.000000)");
    			add_location(g16, file$5, 81, 8, 6656);
    			attr(rect21, "id", "Shape");
    			attr(rect21, "fill", rect21_fill_value = ctx.colors[5]);
    			attr(rect21, "x", "0");
    			attr(rect21, "y", "0");
    			attr(rect21, "width", "200");
    			attr(rect21, "height", "200");
    			add_location(rect21, file$5, 87, 10, 7239);
    			attr(rect22, "id", "Shape");
    			attr(rect22, "fill", rect22_fill_value = ctx.colors[3]);
    			attr(rect22, "x", "30");
    			attr(rect22, "y", "30");
    			attr(rect22, "width", "140");
    			attr(rect22, "height", "140");
    			add_location(rect22, file$5, 88, 10, 7330);
    			attr(polygon11, "id", "Shape");
    			attr(polygon11, "fill", polygon11_fill_value = ctx.colors[6]);
    			attr(polygon11, "transform", "translate(50.000000, 50.000000) scale(-1, -1) translate(-50.000000, -50.000000) ");
    			attr(polygon11, "points", "0 0 100 100 0 100");
    			add_location(polygon11, file$5, 89, 10, 7423);
    			attr(g17, "transform", "translate(100.000000, 501.000000) rotate(-90.000000) translate(-100.000000, -501.000000) translate(0.000000, 401.000000)");
    			add_location(g17, file$5, 86, 8, 7092);
    			attr(rect23, "id", "Shape");
    			attr(rect23, "fill", rect23_fill_value = ctx.colors[5]);
    			attr(rect23, "x", "0");
    			attr(rect23, "y", "0");
    			attr(rect23, "width", "200");
    			attr(rect23, "height", "200");
    			add_location(rect23, file$5, 92, 10, 7762);
    			attr(rect24, "id", "Shape");
    			attr(rect24, "fill", rect24_fill_value = ctx.colors[3]);
    			attr(rect24, "x", "30");
    			attr(rect24, "y", "30");
    			attr(rect24, "width", "140");
    			attr(rect24, "height", "140");
    			add_location(rect24, file$5, 93, 10, 7853);
    			attr(polygon12, "id", "Shape");
    			attr(polygon12, "fill", polygon12_fill_value = ctx.colors[6]);
    			attr(polygon12, "transform", "translate(50.000000, 50.000000) scale(-1, -1) translate(-50.000000, -50.000000) ");
    			attr(polygon12, "points", "0 0 100 100 0 100");
    			add_location(polygon12, file$5, 94, 10, 7946);
    			attr(g18, "transform", "translate(500.000000, 101.000000) rotate(-270.000000) translate(-500.000000, -101.000000) translate(400.000000, 1.000000)");
    			add_location(g18, file$5, 91, 8, 7614);
    			attr(polygon13, "id", "Shape");
    			attr(polygon13, "fill", polygon13_fill_value = ctx.colors[7]);
    			attr(polygon13, "points", "0 -1.73472348e-16 200 0 200 200 0 200");
    			add_location(polygon13, file$5, 97, 10, 8290);
    			attr(polygon14, "id", "Shape");
    			attr(polygon14, "fill", polygon14_fill_value = ctx.colors[0]);
    			attr(polygon14, "transform", "translate(100.000000, 100.000000) scale(-1, -1) translate(-100.000000, -100.000000) ");
    			attr(polygon14, "points", "0 0 200 200 0 200");
    			add_location(polygon14, file$5, 98, 10, 8397);
    			attr(path6, "d", "M102,25 C143.421356,25 177,58.5786438 177,100 C177,141.421356 143.421356,175 102,175 C60.5786438,175 27,141.421356 27,100 C27,58.5786438 60.5786438,25 102,25 Z");
    			attr(path6, "id", "Shape");
    			attr(path6, "fill", path6_fill_value = ctx.colors[3]);
    			add_location(path6, file$5, 99, 10, 8581);
    			attr(g19, "transform", "translate(1300.000000, 701.000000) rotate(-270.000000) translate(-1300.000000, -701.000000) translate(1200.000000, 601.000000)");
    			add_location(g19, file$5, 96, 8, 8137);
    			attr(polygon15, "id", "Shape");
    			attr(polygon15, "fill", polygon15_fill_value = ctx.colors[3]);
    			attr(polygon15, "points", "2.84217094e-12 0 200 0 200 200 2.84217094e-12 200");
    			add_location(polygon15, file$5, 102, 10, 8868);
    			attr(polygon16, "id", "Shape");
    			attr(polygon16, "fill", polygon16_fill_value = ctx.colors[1]);
    			attr(polygon16, "transform", "translate(100.000000, 100.000000) scale(-1, 1) translate(-100.000000, -100.000000) ");
    			attr(polygon16, "points", "0 0 200 200 0 200");
    			add_location(polygon16, file$5, 103, 10, 8987);
    			attr(g20, "transform", "translate(0.000000, 601.000000)");
    			add_location(g20, file$5, 101, 8, 8810);
    			attr(polygon17, "id", "Shape");
    			attr(polygon17, "fill", polygon17_fill_value = ctx.colors[6]);
    			attr(polygon17, "points", "0 0 200 200 0 200");
    			add_location(polygon17, file$5, 106, 10, 9241);
    			attr(rect25, "id", "Shape");
    			attr(rect25, "fill", rect25_fill_value = ctx.colors[5]);
    			attr(rect25, "x", "100");
    			attr(rect25, "y", "0");
    			attr(rect25, "width", "100");
    			attr(rect25, "height", "100");
    			add_location(rect25, file$5, 107, 10, 9328);
    			attr(g21, "transform", "translate(200.000000, 401.000000)");
    			add_location(g21, file$5, 105, 8, 9181);
    			attr(polygon18, "id", "Shape");
    			attr(polygon18, "points", "0 0 200 200 0 200");
    			add_location(polygon18, file$5, 110, 10, 9511);
    			attr(g22, "transform", "translate(400.000000, 201.000000)");
    			attr(g22, "fill", g22_fill_value = ctx.colors[6]);
    			add_location(g22, file$5, 109, 8, 9432);
    			attr(polygon19, "id", "Shape");
    			attr(polygon19, "points", "0 0 200 200 0 200");
    			add_location(polygon19, file$5, 113, 10, 9669);
    			attr(g23, "transform", "translate(200.000000, 601.000000)");
    			attr(g23, "fill", g23_fill_value = ctx.colors[0]);
    			add_location(g23, file$5, 112, 8, 9590);
    			attr(polygon20, "id", "Shape");
    			attr(polygon20, "fill", polygon20_fill_value = ctx.colors[2]);
    			attr(polygon20, "transform", "translate(100.000000, 100.000000) scale(-1, -1) translate(-100.000000, -100.000000) ");
    			attr(polygon20, "points", "0 0 200 200 0 200");
    			add_location(polygon20, file$5, 116, 10, 9808);
    			attr(rect26, "id", "Shape");
    			attr(rect26, "fill", rect26_fill_value = ctx.colors[5]);
    			attr(rect26, "x", "0");
    			attr(rect26, "y", "100");
    			attr(rect26, "width", "100");
    			attr(rect26, "height", "100");
    			add_location(rect26, file$5, 117, 10, 9992);
    			attr(polygon21, "id", "Shape");
    			attr(polygon21, "fill", polygon21_fill_value = ctx.colors[1]);
    			attr(polygon21, "transform", "translate(150.000000, 50.000000) scale(-1, -1) translate(-150.000000, -50.000000) ");
    			attr(polygon21, "points", "100 0 200 100 100 100");
    			add_location(polygon21, file$5, 118, 10, 10085);
    			attr(g24, "transform", "translate(800.000000, 401.000000)");
    			add_location(g24, file$5, 115, 8, 9748);
    			attr(polygon22, "id", "Shape");
    			attr(polygon22, "fill", polygon22_fill_value = ctx.colors[2]);
    			attr(polygon22, "transform", "translate(100.000000, 100.000000) scale(-1, -1) translate(-100.000000, -100.000000) ");
    			attr(polygon22, "points", "0 0 200 200 0 200");
    			add_location(polygon22, file$5, 121, 10, 10429);
    			attr(rect27, "id", "Shape");
    			attr(rect27, "fill", rect27_fill_value = ctx.colors[1]);
    			attr(rect27, "x", "0");
    			attr(rect27, "y", "100");
    			attr(rect27, "width", "100");
    			attr(rect27, "height", "100");
    			add_location(rect27, file$5, 122, 10, 10613);
    			attr(polygon23, "id", "Shape");
    			attr(polygon23, "fill", polygon23_fill_value = ctx.colors[1]);
    			attr(polygon23, "transform", "translate(150.000000, 50.000000) scale(-1, -1) translate(-150.000000, -50.000000) ");
    			attr(polygon23, "points", "100 0 200 100 100 100");
    			add_location(polygon23, file$5, 123, 10, 10706);
    			attr(g25, "transform", "translate(300.000000, 101.000000) rotate(-90.000000) translate(-300.000000, -101.000000) translate(200.000000, 1.000000)");
    			add_location(g25, file$5, 120, 8, 10282);
    			attr(polygon24, "id", "Shape");
    			attr(polygon24, "fill", polygon24_fill_value = ctx.colors[2]);
    			attr(polygon24, "transform", "translate(100.000000, 100.000000) scale(-1, -1) translate(-100.000000, -100.000000) ");
    			attr(polygon24, "points", "0 0 200 200 0 200");
    			add_location(polygon24, file$5, 126, 10, 11055);
    			attr(rect28, "id", "Shape");
    			attr(rect28, "fill", rect28_fill_value = ctx.colors[5]);
    			attr(rect28, "x", "0");
    			attr(rect28, "y", "100");
    			attr(rect28, "width", "100");
    			attr(rect28, "height", "100");
    			add_location(rect28, file$5, 127, 10, 11239);
    			attr(polygon25, "id", "Shape");
    			attr(polygon25, "fill", polygon25_fill_value = ctx.colors[1]);
    			attr(polygon25, "transform", "translate(150.000000, 50.000000) scale(-1, -1) translate(-150.000000, -50.000000) ");
    			attr(polygon25, "points", "100 0 200 100 100 100");
    			add_location(polygon25, file$5, 128, 10, 11332);
    			attr(g26, "transform", "translate(1500.000000, 701.000000) rotate(-90.000000) translate(-1500.000000, -701.000000) translate(1400.000000, 601.000000)");
    			add_location(g26, file$5, 125, 8, 10903);
    			attr(polygon26, "id", "Shape");
    			attr(polygon26, "fill", polygon26_fill_value = ctx.colors[1]);
    			attr(polygon26, "transform", "translate(100.000000, 100.000000) scale(-1, 1) translate(-100.000000, -100.000000) ");
    			attr(polygon26, "points", "0 0 200 200 0 200");
    			add_location(polygon26, file$5, 131, 10, 11589);
    			attr(rect29, "id", "Shape");
    			attr(rect29, "fill", rect29_fill_value = ctx.colors[2]);
    			attr(rect29, "x", "0");
    			attr(rect29, "y", "0");
    			attr(rect29, "width", "100");
    			attr(rect29, "height", "100");
    			add_location(rect29, file$5, 132, 10, 11772);
    			attr(g27, "transform", "translate(600.000000, 401.000000)");
    			add_location(g27, file$5, 130, 8, 11529);
    			attr(polygon27, "id", "Shape");
    			attr(polygon27, "fill", polygon27_fill_value = ctx.colors[2]);
    			attr(polygon27, "transform", "translate(100.000000, 100.000000) scale(-1, 1) translate(-100.000000, -100.000000) ");
    			attr(polygon27, "points", "0 0 200 200 0 200");
    			add_location(polygon27, file$5, 135, 10, 11936);
    			attr(rect30, "id", "Shape");
    			attr(rect30, "fill", rect30_fill_value = ctx.colors[6]);
    			attr(rect30, "x", "0");
    			attr(rect30, "y", "0");
    			attr(rect30, "width", "100");
    			attr(rect30, "height", "100");
    			add_location(rect30, file$5, 136, 10, 12119);
    			attr(g28, "transform", "translate(1200.000000, 1001.000000)");
    			add_location(g28, file$5, 134, 8, 11874);
    			attr(polygon28, "id", "Shape");
    			attr(polygon28, "transform", "translate(100.000000, 100.000000) scale(-1, -1) translate(-100.000000, -100.000000) ");
    			attr(polygon28, "points", "0 0 200 200 0 200");
    			add_location(polygon28, file$5, 139, 10, 12301);
    			attr(g29, "transform", "translate(1200.000000, 801.000000)");
    			attr(g29, "fill", g29_fill_value = ctx.colors[7]);
    			add_location(g29, file$5, 138, 8, 12221);
    			attr(polygon29, "id", "Shape");
    			attr(polygon29, "transform", "translate(100.000000, 100.000000) scale(-1, -1) translate(-100.000000, -100.000000) ");
    			attr(polygon29, "points", "0 0 200 200 0 200");
    			add_location(polygon29, file$5, 142, 10, 12552);
    			attr(g30, "transform", "translate(0.000000, 1.000000)");
    			attr(g30, "fill", g30_fill_value = ctx.colors[7]);
    			add_location(g30, file$5, 141, 8, 12477);
    			attr(rect31, "id", "Shape");
    			attr(rect31, "fill", rect31_fill_value = ctx.colors[7]);
    			attr(rect31, "x", "0");
    			attr(rect31, "y", "0");
    			attr(rect31, "width", "200");
    			attr(rect31, "height", "200");
    			add_location(rect31, file$5, 145, 10, 12878);
    			attr(polygon30, "id", "Triangle");
    			attr(polygon30, "fill", polygon30_fill_value = ctx.colors[3]);
    			attr(polygon30, "points", "99.5 0.673233746 168 136 31 136");
    			add_location(polygon30, file$5, 147, 12, 13039);
    			attr(polygon31, "id", "Triangle");
    			attr(polygon31, "fill", polygon31_fill_value = ctx.colors[0]);
    			attr(polygon31, "points", "50 46.4455223 100 136 0 136");
    			add_location(polygon31, file$5, 148, 12, 13145);
    			attr(polygon32, "id", "Triangle");
    			attr(polygon32, "fill", polygon32_fill_value = ctx.colors[0]);
    			attr(polygon32, "points", "150 46.4455223 200 136 100 136");
    			add_location(polygon32, file$5, 149, 12, 13247);
    			attr(g31, "id", "Shape");
    			attr(g31, "transform", "translate(0.000000, 64.000000)");
    			add_location(g31, file$5, 146, 10, 12969);
    			attr(g32, "transform", "translate(700.000000, 701.000000) rotate(-180.000000) translate(-700.000000, -701.000000) translate(600.000000, 601.000000)");
    			add_location(g32, file$5, 144, 8, 12728);
    			attr(rect32, "id", "Shape");
    			attr(rect32, "fill", rect32_fill_value = ctx.colors[6]);
    			attr(rect32, "x", "0");
    			attr(rect32, "y", "0");
    			attr(rect32, "width", "200");
    			attr(rect32, "height", "200");
    			add_location(rect32, file$5, 153, 10, 13527);
    			attr(polygon33, "id", "Shape");
    			attr(polygon33, "fill", polygon33_fill_value = ctx.colors[5]);
    			attr(polygon33, "points", "99.5 65 168 200 31 200");
    			add_location(polygon33, file$5, 154, 10, 13618);
    			attr(polygon34, "id", "Triangle");
    			attr(polygon34, "fill", polygon34_fill_value = ctx.colors[1]);
    			attr(polygon34, "points", "50 110 100 200 0 200");
    			add_location(polygon34, file$5, 155, 10, 13710);
    			attr(polygon35, "id", "Triangle");
    			attr(polygon35, "fill", polygon35_fill_value = ctx.colors[1]);
    			attr(polygon35, "points", "149 110 199 200 99 200");
    			add_location(polygon35, file$5, 156, 10, 13803);
    			attr(g33, "transform", "translate(100.000000, 1101.000000) rotate(-270.000000) translate(-100.000000, -1101.000000) translate(0.000000, 1001.000000)");
    			add_location(g33, file$5, 152, 8, 13376);
    			attr(rect33, "id", "Shape");
    			attr(rect33, "fill", rect33_fill_value = ctx.colors[6]);
    			attr(rect33, "x", "1");
    			attr(rect33, "y", "0");
    			attr(rect33, "width", "200");
    			attr(rect33, "height", "200.004975");
    			add_location(rect33, file$5, 159, 10, 14059);
    			attr(polygon36, "id", "Shape");
    			attr(polygon36, "fill", polygon36_fill_value = ctx.colors[5]);
    			attr(polygon36, "points", "100.9983 64.4983 169.4983 200.5017 32.4983 200.5017");
    			add_location(polygon36, file$5, 160, 10, 14157);
    			attr(polygon37, "id", "Triangle");
    			attr(polygon37, "points", "50.2736318 0.273631841 100.273632 90.2758819 0.273631841 90.2758819");
    			add_location(polygon37, file$5, 162, 12, 14368);
    			attr(polygon38, "id", "Triangle");
    			attr(polygon38, "points", "150.273632 0.273631841 200.273632 90.2758819 100.273632 90.2758819");
    			add_location(polygon38, file$5, 163, 12, 14491);
    			attr(g34, "id", "Shape");
    			attr(g34, "transform", "translate(0.726368, 109.726368)");
    			attr(g34, "fill", g34_fill_value = ctx.colors[1]);
    			add_location(g34, file$5, 161, 10, 14278);
    			attr(g35, "transform", "translate(1500.500000, 101.000000) rotate(-90.000000) translate(-1500.500000, -101.000000) translate(1399.500000, 0.500000)");
    			add_location(g35, file$5, 158, 8, 13909);
    			attr(rect34, "id", "Shape");
    			attr(rect34, "fill", rect34_fill_value = ctx.colors[1]);
    			attr(rect34, "x", "0");
    			attr(rect34, "y", "0");
    			attr(rect34, "width", "200");
    			attr(rect34, "height", "200");
    			add_location(rect34, file$5, 167, 10, 14787);
    			attr(polygon39, "id", "Shape");
    			attr(polygon39, "fill", polygon39_fill_value = ctx.colors[2]);
    			attr(polygon39, "points", "99.5 63.3165829 168 200 31 200");
    			add_location(polygon39, file$5, 168, 10, 14878);
    			attr(g36, "transform", "translate(300.000000, 301.000000) rotate(-180.000000) translate(-300.000000, -301.000000) translate(200.000000, 201.000000)");
    			add_location(g36, file$5, 166, 8, 14637);
    			attr(polygon40, "id", "Shape");
    			attr(polygon40, "points", "100 0 200 200 0 200");
    			add_location(polygon40, file$5, 171, 10, 15069);
    			attr(g37, "transform", "translate(800.000000, 1001.000000)");
    			attr(g37, "fill", g37_fill_value = ctx.colors[2]);
    			add_location(g37, file$5, 170, 8, 14989);
    			attr(path7, "d", "M100,0 C155.228475,0 200,44.771525 200,100 C200,155.228475 155.228475,200 100,200 C44.771525,200 0,155.228475 0,100 C0,44.771525 44.771525,0 100,0 Z");
    			attr(path7, "id", "Shape");
    			attr(path7, "fill", path7_fill_value = ctx.colors[1]);
    			add_location(path7, file$5, 174, 10, 15211);
    			attr(path8, "d", "M100,50 C127.614237,50 150,72.3857625 150,100 C150,127.614237 127.614237,150 100,150 C72.3857625,150 50,127.614237 50,100 C50,72.3857625 72.3857625,50 100,50 Z");
    			attr(path8, "id", "Shape");
    			attr(path8, "fill", path8_fill_value = ctx.colors[3]);
    			add_location(path8, file$5, 175, 10, 15418);
    			attr(g38, "transform", "translate(1200.000000, 401.000000)");
    			add_location(g38, file$5, 173, 8, 15150);
    			attr(path9, "d", "M100,0 C155.228475,0 200,44.771525 200,100 C200,155.228475 155.228475,200 100,200 C44.771525,200 0,155.228475 0,100 C0,44.771525 44.771525,0 100,0 Z");
    			attr(path9, "id", "Shape");
    			attr(path9, "fill", path9_fill_value = ctx.colors[0]);
    			add_location(path9, file$5, 178, 10, 15707);
    			attr(path10, "d", "M100,50 C127.614237,50 150,72.3857625 150,100 C150,127.614237 127.614237,150 100,150 C72.3857625,150 50,127.614237 50,100 C50,72.3857625 72.3857625,50 100,50 Z");
    			attr(path10, "id", "Shape");
    			attr(path10, "fill", path10_fill_value = ctx.colors[7]);
    			add_location(path10, file$5, 179, 10, 15914);
    			attr(g39, "transform", "translate(600.000000, 201.000000)");
    			add_location(g39, file$5, 177, 8, 15647);
    			attr(path11, "d", "M100,-1.8189894e-12 C155.228475,-1.8189894e-12 200,44.771525 200,100 C200,155.228475 155.228475,200 100,200 C44.771525,200 0,155.228475 0,100 C0,44.771525 44.771525,-1.8189894e-12 100,-1.8189894e-12 Z");
    			attr(path11, "id", "Shape");
    			add_location(path11, file$5, 182, 10, 16224);
    			attr(g40, "transform", "translate(1000.000000, 1001.000000)");
    			attr(g40, "fill", g40_fill_value = ctx.colors[5]);
    			add_location(g40, file$5, 181, 8, 16143);
    			attr(path12, "d", "M100,0 C155.228475,0 200,44.771525 200,100 C200,155.228475 155.228475,200 100,200 C44.771525,200 0,155.228475 0,100 C0,44.771525 44.771525,0 100,0 Z");
    			attr(path12, "id", "Shape");
    			attr(path12, "fill", path12_fill_value = ctx.colors[2]);
    			add_location(path12, file$5, 185, 10, 16536);
    			attr(rect35, "id", "Shape");
    			attr(rect35, "fill", rect35_fill_value = ctx.colors[3]);
    			attr(rect35, "x", "100");
    			attr(rect35, "y", "100");
    			attr(rect35, "width", "100");
    			attr(rect35, "height", "100");
    			add_location(rect35, file$5, 186, 10, 16743);
    			attr(g41, "transform", "translate(1000.000000, 201.000000)");
    			add_location(g41, file$5, 184, 8, 16475);
    			attr(path13, "d", "M100,0 C155.228475,0 200,44.771525 200,100 C200,155.228475 155.228475,200 100,200 C44.771525,200 0,155.228475 0,100 C0,44.771525 44.771525,0 100,0 Z");
    			attr(path13, "id", "Shape");
    			attr(path13, "fill", path13_fill_value = ctx.colors[1]);
    			add_location(path13, file$5, 189, 10, 16910);
    			attr(rect36, "id", "Shape");
    			attr(rect36, "fill", rect36_fill_value = ctx.colors[7]);
    			attr(rect36, "x", "100");
    			attr(rect36, "y", "100");
    			attr(rect36, "width", "100");
    			attr(rect36, "height", "100");
    			add_location(rect36, file$5, 190, 10, 17117);
    			attr(g42, "transform", "translate(200.000000, 1001.000000)");
    			add_location(g42, file$5, 188, 8, 16849);
    			attr(polygon41, "id", "Shape");
    			attr(polygon41, "transform", "translate(50.000000, 50.000000) scale(-1, -1) translate(-50.000000, -50.000000) ");
    			attr(polygon41, "points", "0 0 100 100 0 100");
    			add_location(polygon41, file$5, 193, 10, 17302);
    			attr(polygon42, "id", "Shape");
    			attr(polygon42, "transform", "translate(150.000000, 150.000000) scale(-1, -1) rotate(-180.000000) translate(-150.000000, -150.000000) ");
    			attr(polygon42, "points", "100 100 200 200 100 200");
    			add_location(polygon42, file$5, 194, 10, 17463);
    			attr(polygon43, "id", "Shape");
    			attr(polygon43, "transform", "translate(50.000000, 150.000000) scale(-1, -1) rotate(-90.000000) translate(-50.000000, -150.000000) ");
    			attr(polygon43, "points", "0 100 100 200 0 200");
    			add_location(polygon43, file$5, 195, 10, 17654);
    			attr(polygon44, "id", "Shape");
    			attr(polygon44, "transform", "translate(150.000000, 50.000000) scale(-1, -1) rotate(-270.000000) translate(-150.000000, -50.000000) ");
    			attr(polygon44, "points", "100 0 200 100 100 100");
    			add_location(polygon44, file$5, 196, 10, 17838);
    			attr(g43, "transform", "translate(800.000000, 201.000000)");
    			attr(g43, "fill", g43_fill_value = ctx.colors[0]);
    			add_location(g43, file$5, 192, 8, 17223);
    			attr(polygon45, "id", "Shape");
    			attr(polygon45, "transform", "translate(50.000000, 50.000000) scale(-1, -1) translate(-50.000000, -50.000000) ");
    			attr(polygon45, "points", "0 0 100 100 0 100");
    			add_location(polygon45, file$5, 199, 10, 18116);
    			attr(polygon46, "id", "Shape");
    			attr(polygon46, "transform", "translate(150.000000, 150.000000) scale(-1, -1) rotate(-180.000000) translate(-150.000000, -150.000000) ");
    			attr(polygon46, "points", "100 100 200 200 100 200");
    			add_location(polygon46, file$5, 200, 10, 18277);
    			attr(polygon47, "id", "Shape");
    			attr(polygon47, "transform", "translate(50.000000, 150.000000) scale(-1, -1) rotate(-90.000000) translate(-50.000000, -150.000000) ");
    			attr(polygon47, "points", "0 100 100 200 0 200");
    			add_location(polygon47, file$5, 201, 10, 18468);
    			attr(polygon48, "id", "Shape");
    			attr(polygon48, "transform", "translate(150.000000, 50.000000) scale(-1, -1) rotate(-270.000000) translate(-150.000000, -50.000000) ");
    			attr(polygon48, "points", "100 0 200 100 100 100");
    			add_location(polygon48, file$5, 202, 10, 18652);
    			attr(g44, "transform", "translate(1400.000000, 401.000000)");
    			attr(g44, "fill", g44_fill_value = ctx.colors[5]);
    			add_location(g44, file$5, 198, 8, 18036);
    			attr(polygon49, "id", "Shape");
    			attr(polygon49, "transform", "translate(50.000000, 50.000000) scale(-1, -1) translate(-50.000000, -50.000000) ");
    			attr(polygon49, "points", "0 0 100 100 0 100");
    			add_location(polygon49, file$5, 205, 10, 18929);
    			attr(polygon50, "id", "Shape");
    			attr(polygon50, "transform", "translate(50.000000, 50.000000) scale(-1, -1) rotate(-90.000000) translate(-50.000000, -50.000000) ");
    			attr(polygon50, "points", "0 0 100 100 0 100");
    			add_location(polygon50, file$5, 206, 10, 19090);
    			attr(polygon51, "id", "Shape");
    			attr(polygon51, "transform", "translate(150.000000, 150.000000) scale(-1, -1) rotate(-90.000000) translate(-150.000000, -150.000000) ");
    			attr(polygon51, "points", "100 100 200 200 100 200");
    			add_location(polygon51, file$5, 207, 10, 19270);
    			attr(polygon52, "id", "Shape");
    			attr(polygon52, "transform", "translate(150.000000, 150.000000) scale(-1, -1) translate(-150.000000, -150.000000) ");
    			attr(polygon52, "points", "100 100 200 200 100 200");
    			add_location(polygon52, file$5, 208, 10, 19460);
    			attr(g45, "transform", "translate(400.000000, 601.000000)");
    			attr(g45, "fill", g45_fill_value = ctx.colors[2]);
    			add_location(g45, file$5, 204, 8, 18850);
    			attr(polygon53, "id", "Shape");
    			attr(polygon53, "fill", polygon53_fill_value = ctx.colors[2]);
    			attr(polygon53, "transform", "translate(50.000000, 50.000000) scale(-1, -1) translate(-50.000000, -50.000000) ");
    			attr(polygon53, "points", "0 0 100 100 0 100");
    			add_location(polygon53, file$5, 211, 10, 19703);
    			attr(polygon54, "id", "Shape");
    			attr(polygon54, "fill", polygon54_fill_value = ctx.colors[2]);
    			attr(polygon54, "transform", "translate(50.000000, 50.000000) scale(-1, -1) rotate(-90.000000) translate(-50.000000, -50.000000) ");
    			attr(polygon54, "points", "0 0 100 100 0 100");
    			add_location(polygon54, file$5, 212, 10, 19883);
    			attr(polygon55, "id", "Shape");
    			attr(polygon55, "fill", polygon55_fill_value = ctx.colors[5]);
    			attr(polygon55, "transform", "translate(150.000000, 150.000000) scale(-1, -1) rotate(-90.000000) translate(-150.000000, -150.000000) ");
    			attr(polygon55, "points", "100 100 200 200 100 200");
    			add_location(polygon55, file$5, 213, 10, 20082);
    			attr(polygon56, "id", "Shape");
    			attr(polygon56, "fill", polygon56_fill_value = ctx.colors[5]);
    			attr(polygon56, "transform", "translate(150.000000, 150.000000) scale(-1, -1) translate(-150.000000, -150.000000) ");
    			attr(polygon56, "points", "100 100 200 200 100 200");
    			add_location(polygon56, file$5, 214, 10, 20291);
    			attr(g46, "transform", "translate(1200.000000, 201.000000)");
    			add_location(g46, file$5, 210, 8, 19642);
    			attr(g47, "transform", "translate(0.000000, -1.000000)");
    			attr(g47, "id", "Module");
    			add_location(g47, file$5, 13, 6, 476);
    			attr(g48, "id", "Kander");
    			add_location(g48, file$5, 12, 4, 454);
    			attr(g49, "id", "Patterns");
    			attr(g49, "stroke", "none");
    			attr(g49, "stroke-width", "1");
    			attr(g49, "fill", "none");
    			attr(g49, "fill-rule", "evenodd");
    			add_location(g49, file$5, 11, 2, 369);
    			attr(svg, "viewBox", "0 0 1600 1200");
    			attr(svg, "version", "1.1");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr(svg, "style", ctx.styles);
    			add_location(svg, file$5, 10, 0, 228);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g49);
    			append(g49, g48);
    			append(g48, g47);
    			append(g47, g0);
    			append(g0, rect0);
    			append(g47, g1);
    			append(g1, rect1);
    			append(g1, polygon0);
    			append(g47, g2);
    			append(g2, path0);
    			append(g2, polygon1);
    			append(g2, polygon2);
    			append(g2, path1);
    			append(g47, g3);
    			append(g3, path2);
    			append(g3, polygon3);
    			append(g3, polygon4);
    			append(g3, path3);
    			append(g47, g4);
    			append(g4, rect2);
    			append(g4, rect3);
    			append(g4, rect4);
    			append(g47, g5);
    			append(g5, polygon5);
    			append(g5, rect5);
    			append(g47, g6);
    			append(g6, rect6);
    			append(g6, polygon6);
    			append(g47, g7);
    			append(g7, rect7);
    			append(g7, polygon7);
    			append(g47, g8);
    			append(g8, rect8);
    			append(g8, polygon8);
    			append(g47, g9);
    			append(g9, rect9);
    			append(g9, rect10);
    			append(g47, g10);
    			append(g10, rect11);
    			append(g47, g11);
    			append(g11, rect12);
    			append(g11, polygon9);
    			append(g47, g12);
    			append(g12, rect13);
    			append(g12, rect14);
    			append(g47, g13);
    			append(g13, rect15);
    			append(g47, g14);
    			append(g14, rect16);
    			append(g14, path4);
    			append(g14, rect17);
    			append(g47, g15);
    			append(g15, rect18);
    			append(g15, path5);
    			append(g47, g16);
    			append(g16, rect19);
    			append(g16, rect20);
    			append(g16, polygon10);
    			append(g47, g17);
    			append(g17, rect21);
    			append(g17, rect22);
    			append(g17, polygon11);
    			append(g47, g18);
    			append(g18, rect23);
    			append(g18, rect24);
    			append(g18, polygon12);
    			append(g47, g19);
    			append(g19, polygon13);
    			append(g19, polygon14);
    			append(g19, path6);
    			append(g47, g20);
    			append(g20, polygon15);
    			append(g20, polygon16);
    			append(g47, g21);
    			append(g21, polygon17);
    			append(g21, rect25);
    			append(g47, g22);
    			append(g22, polygon18);
    			append(g47, g23);
    			append(g23, polygon19);
    			append(g47, g24);
    			append(g24, polygon20);
    			append(g24, rect26);
    			append(g24, polygon21);
    			append(g47, g25);
    			append(g25, polygon22);
    			append(g25, rect27);
    			append(g25, polygon23);
    			append(g47, g26);
    			append(g26, polygon24);
    			append(g26, rect28);
    			append(g26, polygon25);
    			append(g47, g27);
    			append(g27, polygon26);
    			append(g27, rect29);
    			append(g47, g28);
    			append(g28, polygon27);
    			append(g28, rect30);
    			append(g47, g29);
    			append(g29, polygon28);
    			append(g47, g30);
    			append(g30, polygon29);
    			append(g47, g32);
    			append(g32, rect31);
    			append(g32, g31);
    			append(g31, polygon30);
    			append(g31, polygon31);
    			append(g31, polygon32);
    			append(g47, g33);
    			append(g33, rect32);
    			append(g33, polygon33);
    			append(g33, polygon34);
    			append(g33, polygon35);
    			append(g47, g35);
    			append(g35, rect33);
    			append(g35, polygon36);
    			append(g35, g34);
    			append(g34, polygon37);
    			append(g34, polygon38);
    			append(g47, g36);
    			append(g36, rect34);
    			append(g36, polygon39);
    			append(g47, g37);
    			append(g37, polygon40);
    			append(g47, g38);
    			append(g38, path7);
    			append(g38, path8);
    			append(g47, g39);
    			append(g39, path9);
    			append(g39, path10);
    			append(g47, g40);
    			append(g40, path11);
    			append(g47, g41);
    			append(g41, path12);
    			append(g41, rect35);
    			append(g47, g42);
    			append(g42, path13);
    			append(g42, rect36);
    			append(g47, g43);
    			append(g43, polygon41);
    			append(g43, polygon42);
    			append(g43, polygon43);
    			append(g43, polygon44);
    			append(g47, g44);
    			append(g44, polygon45);
    			append(g44, polygon46);
    			append(g44, polygon47);
    			append(g44, polygon48);
    			append(g47, g45);
    			append(g45, polygon49);
    			append(g45, polygon50);
    			append(g45, polygon51);
    			append(g45, polygon52);
    			append(g47, g46);
    			append(g46, polygon53);
    			append(g46, polygon54);
    			append(g46, polygon55);
    			append(g46, polygon56);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colors) && g0_fill_value !== (g0_fill_value = ctx.colors[0])) {
    				attr(g0, "fill", g0_fill_value);
    			}

    			if ((changed.colors) && rect1_fill_value !== (rect1_fill_value = ctx.colors[1])) {
    				attr(rect1, "fill", rect1_fill_value);
    			}

    			if ((changed.colors) && polygon0_fill_value !== (polygon0_fill_value = ctx.colors[2])) {
    				attr(polygon0, "fill", polygon0_fill_value);
    			}

    			if ((changed.colors) && path0_fill_value !== (path0_fill_value = ctx.colors[2])) {
    				attr(path0, "fill", path0_fill_value);
    			}

    			if ((changed.colors) && polygon1_fill_value !== (polygon1_fill_value = ctx.colors[3])) {
    				attr(polygon1, "fill", polygon1_fill_value);
    			}

    			if ((changed.colors) && polygon2_fill_value !== (polygon2_fill_value = ctx.colors[5])) {
    				attr(polygon2, "fill", polygon2_fill_value);
    			}

    			if ((changed.colors) && path1_fill_value !== (path1_fill_value = ctx.colors[6])) {
    				attr(path1, "fill", path1_fill_value);
    			}

    			if ((changed.colors) && path2_fill_value !== (path2_fill_value = ctx.colors[1])) {
    				attr(path2, "fill", path2_fill_value);
    			}

    			if ((changed.colors) && polygon3_fill_value !== (polygon3_fill_value = ctx.colors[5])) {
    				attr(polygon3, "fill", polygon3_fill_value);
    			}

    			if ((changed.colors) && polygon4_fill_value !== (polygon4_fill_value = ctx.colors[3])) {
    				attr(polygon4, "fill", polygon4_fill_value);
    			}

    			if ((changed.colors) && path3_fill_value !== (path3_fill_value = ctx.colors[6])) {
    				attr(path3, "fill", path3_fill_value);
    			}

    			if ((changed.colors) && rect2_fill_value !== (rect2_fill_value = ctx.colors[5])) {
    				attr(rect2, "fill", rect2_fill_value);
    			}

    			if ((changed.colors) && rect3_fill_value !== (rect3_fill_value = ctx.colors[7])) {
    				attr(rect3, "fill", rect3_fill_value);
    			}

    			if ((changed.colors) && rect4_fill_value !== (rect4_fill_value = ctx.colors[6])) {
    				attr(rect4, "fill", rect4_fill_value);
    			}

    			if ((changed.colors) && polygon5_fill_value !== (polygon5_fill_value = ctx.colors[7])) {
    				attr(polygon5, "fill", polygon5_fill_value);
    			}

    			if ((changed.colors) && rect5_fill_value !== (rect5_fill_value = ctx.colors[0])) {
    				attr(rect5, "fill", rect5_fill_value);
    			}

    			if ((changed.colors) && rect6_fill_value !== (rect6_fill_value = ctx.colors[3])) {
    				attr(rect6, "fill", rect6_fill_value);
    			}

    			if ((changed.colors) && polygon6_fill_value !== (polygon6_fill_value = ctx.colors[2])) {
    				attr(polygon6, "fill", polygon6_fill_value);
    			}

    			if ((changed.colors) && rect7_fill_value !== (rect7_fill_value = ctx.colors[6])) {
    				attr(rect7, "fill", rect7_fill_value);
    			}

    			if ((changed.colors) && polygon7_fill_value !== (polygon7_fill_value = ctx.colors[5])) {
    				attr(polygon7, "fill", polygon7_fill_value);
    			}

    			if ((changed.colors) && rect8_fill_value !== (rect8_fill_value = ctx.colors[3])) {
    				attr(rect8, "fill", rect8_fill_value);
    			}

    			if ((changed.colors) && polygon8_fill_value !== (polygon8_fill_value = ctx.colors[6])) {
    				attr(polygon8, "fill", polygon8_fill_value);
    			}

    			if ((changed.colors) && rect9_fill_value !== (rect9_fill_value = ctx.colors[7])) {
    				attr(rect9, "fill", rect9_fill_value);
    			}

    			if ((changed.colors) && rect10_fill_value !== (rect10_fill_value = ctx.colors[0])) {
    				attr(rect10, "fill", rect10_fill_value);
    			}

    			if ((changed.colors) && g10_fill_value !== (g10_fill_value = ctx.colors[2])) {
    				attr(g10, "fill", g10_fill_value);
    			}

    			if ((changed.colors) && rect12_fill_value !== (rect12_fill_value = ctx.colors[2])) {
    				attr(rect12, "fill", rect12_fill_value);
    			}

    			if ((changed.colors) && polygon9_fill_value !== (polygon9_fill_value = ctx.colors[1])) {
    				attr(polygon9, "fill", polygon9_fill_value);
    			}

    			if ((changed.colors) && rect13_fill_value !== (rect13_fill_value = ctx.colors[7])) {
    				attr(rect13, "fill", rect13_fill_value);
    			}

    			if ((changed.colors) && rect14_fill_value !== (rect14_fill_value = ctx.colors[0])) {
    				attr(rect14, "fill", rect14_fill_value);
    			}

    			if ((changed.colors) && g13_fill_value !== (g13_fill_value = ctx.colors[2])) {
    				attr(g13, "fill", g13_fill_value);
    			}

    			if ((changed.colors) && rect16_fill_value !== (rect16_fill_value = ctx.colors[3])) {
    				attr(rect16, "fill", rect16_fill_value);
    			}

    			if ((changed.colors) && path4_fill_value !== (path4_fill_value = ctx.colors[0])) {
    				attr(path4, "fill", path4_fill_value);
    			}

    			if ((changed.colors) && rect17_fill_value !== (rect17_fill_value = ctx.colors[5])) {
    				attr(rect17, "fill", rect17_fill_value);
    			}

    			if ((changed.colors) && rect18_fill_value !== (rect18_fill_value = ctx.colors[3])) {
    				attr(rect18, "fill", rect18_fill_value);
    			}

    			if ((changed.colors) && path5_fill_value !== (path5_fill_value = ctx.colors[1])) {
    				attr(path5, "fill", path5_fill_value);
    			}

    			if ((changed.colors) && rect19_fill_value !== (rect19_fill_value = ctx.colors[5])) {
    				attr(rect19, "fill", rect19_fill_value);
    			}

    			if ((changed.colors) && rect20_fill_value !== (rect20_fill_value = ctx.colors[3])) {
    				attr(rect20, "fill", rect20_fill_value);
    			}

    			if ((changed.colors) && polygon10_fill_value !== (polygon10_fill_value = ctx.colors[6])) {
    				attr(polygon10, "fill", polygon10_fill_value);
    			}

    			if ((changed.colors) && rect21_fill_value !== (rect21_fill_value = ctx.colors[5])) {
    				attr(rect21, "fill", rect21_fill_value);
    			}

    			if ((changed.colors) && rect22_fill_value !== (rect22_fill_value = ctx.colors[3])) {
    				attr(rect22, "fill", rect22_fill_value);
    			}

    			if ((changed.colors) && polygon11_fill_value !== (polygon11_fill_value = ctx.colors[6])) {
    				attr(polygon11, "fill", polygon11_fill_value);
    			}

    			if ((changed.colors) && rect23_fill_value !== (rect23_fill_value = ctx.colors[5])) {
    				attr(rect23, "fill", rect23_fill_value);
    			}

    			if ((changed.colors) && rect24_fill_value !== (rect24_fill_value = ctx.colors[3])) {
    				attr(rect24, "fill", rect24_fill_value);
    			}

    			if ((changed.colors) && polygon12_fill_value !== (polygon12_fill_value = ctx.colors[6])) {
    				attr(polygon12, "fill", polygon12_fill_value);
    			}

    			if ((changed.colors) && polygon13_fill_value !== (polygon13_fill_value = ctx.colors[7])) {
    				attr(polygon13, "fill", polygon13_fill_value);
    			}

    			if ((changed.colors) && polygon14_fill_value !== (polygon14_fill_value = ctx.colors[0])) {
    				attr(polygon14, "fill", polygon14_fill_value);
    			}

    			if ((changed.colors) && path6_fill_value !== (path6_fill_value = ctx.colors[3])) {
    				attr(path6, "fill", path6_fill_value);
    			}

    			if ((changed.colors) && polygon15_fill_value !== (polygon15_fill_value = ctx.colors[3])) {
    				attr(polygon15, "fill", polygon15_fill_value);
    			}

    			if ((changed.colors) && polygon16_fill_value !== (polygon16_fill_value = ctx.colors[1])) {
    				attr(polygon16, "fill", polygon16_fill_value);
    			}

    			if ((changed.colors) && polygon17_fill_value !== (polygon17_fill_value = ctx.colors[6])) {
    				attr(polygon17, "fill", polygon17_fill_value);
    			}

    			if ((changed.colors) && rect25_fill_value !== (rect25_fill_value = ctx.colors[5])) {
    				attr(rect25, "fill", rect25_fill_value);
    			}

    			if ((changed.colors) && g22_fill_value !== (g22_fill_value = ctx.colors[6])) {
    				attr(g22, "fill", g22_fill_value);
    			}

    			if ((changed.colors) && g23_fill_value !== (g23_fill_value = ctx.colors[0])) {
    				attr(g23, "fill", g23_fill_value);
    			}

    			if ((changed.colors) && polygon20_fill_value !== (polygon20_fill_value = ctx.colors[2])) {
    				attr(polygon20, "fill", polygon20_fill_value);
    			}

    			if ((changed.colors) && rect26_fill_value !== (rect26_fill_value = ctx.colors[5])) {
    				attr(rect26, "fill", rect26_fill_value);
    			}

    			if ((changed.colors) && polygon21_fill_value !== (polygon21_fill_value = ctx.colors[1])) {
    				attr(polygon21, "fill", polygon21_fill_value);
    			}

    			if ((changed.colors) && polygon22_fill_value !== (polygon22_fill_value = ctx.colors[2])) {
    				attr(polygon22, "fill", polygon22_fill_value);
    			}

    			if ((changed.colors) && rect27_fill_value !== (rect27_fill_value = ctx.colors[1])) {
    				attr(rect27, "fill", rect27_fill_value);
    			}

    			if ((changed.colors) && polygon23_fill_value !== (polygon23_fill_value = ctx.colors[1])) {
    				attr(polygon23, "fill", polygon23_fill_value);
    			}

    			if ((changed.colors) && polygon24_fill_value !== (polygon24_fill_value = ctx.colors[2])) {
    				attr(polygon24, "fill", polygon24_fill_value);
    			}

    			if ((changed.colors) && rect28_fill_value !== (rect28_fill_value = ctx.colors[5])) {
    				attr(rect28, "fill", rect28_fill_value);
    			}

    			if ((changed.colors) && polygon25_fill_value !== (polygon25_fill_value = ctx.colors[1])) {
    				attr(polygon25, "fill", polygon25_fill_value);
    			}

    			if ((changed.colors) && polygon26_fill_value !== (polygon26_fill_value = ctx.colors[1])) {
    				attr(polygon26, "fill", polygon26_fill_value);
    			}

    			if ((changed.colors) && rect29_fill_value !== (rect29_fill_value = ctx.colors[2])) {
    				attr(rect29, "fill", rect29_fill_value);
    			}

    			if ((changed.colors) && polygon27_fill_value !== (polygon27_fill_value = ctx.colors[2])) {
    				attr(polygon27, "fill", polygon27_fill_value);
    			}

    			if ((changed.colors) && rect30_fill_value !== (rect30_fill_value = ctx.colors[6])) {
    				attr(rect30, "fill", rect30_fill_value);
    			}

    			if ((changed.colors) && g29_fill_value !== (g29_fill_value = ctx.colors[7])) {
    				attr(g29, "fill", g29_fill_value);
    			}

    			if ((changed.colors) && g30_fill_value !== (g30_fill_value = ctx.colors[7])) {
    				attr(g30, "fill", g30_fill_value);
    			}

    			if ((changed.colors) && rect31_fill_value !== (rect31_fill_value = ctx.colors[7])) {
    				attr(rect31, "fill", rect31_fill_value);
    			}

    			if ((changed.colors) && polygon30_fill_value !== (polygon30_fill_value = ctx.colors[3])) {
    				attr(polygon30, "fill", polygon30_fill_value);
    			}

    			if ((changed.colors) && polygon31_fill_value !== (polygon31_fill_value = ctx.colors[0])) {
    				attr(polygon31, "fill", polygon31_fill_value);
    			}

    			if ((changed.colors) && polygon32_fill_value !== (polygon32_fill_value = ctx.colors[0])) {
    				attr(polygon32, "fill", polygon32_fill_value);
    			}

    			if ((changed.colors) && rect32_fill_value !== (rect32_fill_value = ctx.colors[6])) {
    				attr(rect32, "fill", rect32_fill_value);
    			}

    			if ((changed.colors) && polygon33_fill_value !== (polygon33_fill_value = ctx.colors[5])) {
    				attr(polygon33, "fill", polygon33_fill_value);
    			}

    			if ((changed.colors) && polygon34_fill_value !== (polygon34_fill_value = ctx.colors[1])) {
    				attr(polygon34, "fill", polygon34_fill_value);
    			}

    			if ((changed.colors) && polygon35_fill_value !== (polygon35_fill_value = ctx.colors[1])) {
    				attr(polygon35, "fill", polygon35_fill_value);
    			}

    			if ((changed.colors) && rect33_fill_value !== (rect33_fill_value = ctx.colors[6])) {
    				attr(rect33, "fill", rect33_fill_value);
    			}

    			if ((changed.colors) && polygon36_fill_value !== (polygon36_fill_value = ctx.colors[5])) {
    				attr(polygon36, "fill", polygon36_fill_value);
    			}

    			if ((changed.colors) && g34_fill_value !== (g34_fill_value = ctx.colors[1])) {
    				attr(g34, "fill", g34_fill_value);
    			}

    			if ((changed.colors) && rect34_fill_value !== (rect34_fill_value = ctx.colors[1])) {
    				attr(rect34, "fill", rect34_fill_value);
    			}

    			if ((changed.colors) && polygon39_fill_value !== (polygon39_fill_value = ctx.colors[2])) {
    				attr(polygon39, "fill", polygon39_fill_value);
    			}

    			if ((changed.colors) && g37_fill_value !== (g37_fill_value = ctx.colors[2])) {
    				attr(g37, "fill", g37_fill_value);
    			}

    			if ((changed.colors) && path7_fill_value !== (path7_fill_value = ctx.colors[1])) {
    				attr(path7, "fill", path7_fill_value);
    			}

    			if ((changed.colors) && path8_fill_value !== (path8_fill_value = ctx.colors[3])) {
    				attr(path8, "fill", path8_fill_value);
    			}

    			if ((changed.colors) && path9_fill_value !== (path9_fill_value = ctx.colors[0])) {
    				attr(path9, "fill", path9_fill_value);
    			}

    			if ((changed.colors) && path10_fill_value !== (path10_fill_value = ctx.colors[7])) {
    				attr(path10, "fill", path10_fill_value);
    			}

    			if ((changed.colors) && g40_fill_value !== (g40_fill_value = ctx.colors[5])) {
    				attr(g40, "fill", g40_fill_value);
    			}

    			if ((changed.colors) && path12_fill_value !== (path12_fill_value = ctx.colors[2])) {
    				attr(path12, "fill", path12_fill_value);
    			}

    			if ((changed.colors) && rect35_fill_value !== (rect35_fill_value = ctx.colors[3])) {
    				attr(rect35, "fill", rect35_fill_value);
    			}

    			if ((changed.colors) && path13_fill_value !== (path13_fill_value = ctx.colors[1])) {
    				attr(path13, "fill", path13_fill_value);
    			}

    			if ((changed.colors) && rect36_fill_value !== (rect36_fill_value = ctx.colors[7])) {
    				attr(rect36, "fill", rect36_fill_value);
    			}

    			if ((changed.colors) && g43_fill_value !== (g43_fill_value = ctx.colors[0])) {
    				attr(g43, "fill", g43_fill_value);
    			}

    			if ((changed.colors) && g44_fill_value !== (g44_fill_value = ctx.colors[5])) {
    				attr(g44, "fill", g44_fill_value);
    			}

    			if ((changed.colors) && g45_fill_value !== (g45_fill_value = ctx.colors[2])) {
    				attr(g45, "fill", g45_fill_value);
    			}

    			if ((changed.colors) && polygon53_fill_value !== (polygon53_fill_value = ctx.colors[2])) {
    				attr(polygon53, "fill", polygon53_fill_value);
    			}

    			if ((changed.colors) && polygon54_fill_value !== (polygon54_fill_value = ctx.colors[2])) {
    				attr(polygon54, "fill", polygon54_fill_value);
    			}

    			if ((changed.colors) && polygon55_fill_value !== (polygon55_fill_value = ctx.colors[5])) {
    				attr(polygon55, "fill", polygon55_fill_value);
    			}

    			if ((changed.colors) && polygon56_fill_value !== (polygon56_fill_value = ctx.colors[5])) {
    				attr(polygon56, "fill", polygon56_fill_value);
    			}

    			if (changed.styles) {
    				attr(svg, "style", ctx.styles);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(svg);
    			}
    		}
    	};
    }

    function instance$5($$self, $$props, $$invalidate) {

      let { colors, styles } = $$props;

    	const writable_props = ['colors', 'styles'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Kander> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('colors' in $$props) $$invalidate('colors', colors = $$props.colors);
    		if ('styles' in $$props) $$invalidate('styles', styles = $$props.styles);
    	};

    	return { colors, styles };
    }

    class Kander extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, ["colors", "styles"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.colors === undefined && !('colors' in props)) {
    			console.warn("<Kander> was created without expected prop 'colors'");
    		}
    		if (ctx.styles === undefined && !('styles' in props)) {
    			console.warn("<Kander> was created without expected prop 'styles'");
    		}
    	}

    	get colors() {
    		throw new Error("<Kander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colors(value) {
    		throw new Error("<Kander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Kander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Kander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/patterns/Linth.svelte generated by Svelte v3.6.7 */

    const file$6 = "src/patterns/Linth.svelte";

    function create_fragment$6(ctx) {
    	var svg, defs, linearGradient, stop0, stop0_stop_color_value, stop1, stop1_stop_color_value, g49, g48, g47, g0, circle0, circle0_fill_value, circle1, circle1_fill_value, circle2, circle2_fill_value, g1, circle3, circle3_fill_value, circle4, circle4_fill_value, circle5, circle5_fill_value, g2, circle6, circle6_fill_value, circle7, circle7_fill_value, circle8, circle8_fill_value, g3, path0, path0_fill_value, path1, path1_fill_value, path2, path2_fill_value, path3, path3_fill_value, g4, rect0, rect0_fill_value, polygon0, polygon0_fill_value, path4, path4_fill_value, path5, path5_fill_value, path6, path6_fill_value, path7, path7_fill_value, g6, g5, polygon1, polygon1_fill_value, polygon2, polygon2_fill_value, g8, g7, path8, path8_fill_value, path9, path9_fill_value, path10, path10_fill_value, path11, path11_fill_value, g10, g9, path12, path12_fill_value, path13, path13_fill_value, path14, path14_fill_value, g12, g11, path15, path15_fill_value, path16, path16_fill_value, path17, path17_fill_value, g14, g13, path18, path18_fill_value, path19, path19_fill_value, path20, path20_fill_value, path21, path21_fill_value, g15, ellipse0, ellipse0_fill_value, path22, path22_fill_value, path23, path23_fill_value, path24, path24_fill_value, path25, path25_fill_value, g16, circle9, circle9_fill_value, path26, path26_fill_value, path27, path27_fill_value, path28, path28_fill_value, path29, path29_fill_value, g17, circle10, circle10_fill_value, path30, path30_fill_value, path31, path31_fill_value, path32, path32_fill_value, path33, path33_fill_value, g18, path34, path34_fill_value, path35, path35_fill_value, path36, path36_fill_value, g19, path37, path37_fill_value, path38, path38_fill_value, path39, path39_fill_value, g20, path40, path40_fill_value, path41, path41_fill_value, path42, path42_fill_value, g21, path43, path43_fill_value, path44, path44_fill_value, path45, path45_fill_value, g22, path46, path46_fill_value, path47, path47_fill_value, path48, path48_fill_value, path49, path49_fill_value, g23, path50, path50_fill_value, path51, path51_fill_value, path52, path52_fill_value, path53, path53_fill_value, g24, path54, path54_fill_value, path55, path55_fill_value, path56, path56_fill_value, path57, path57_fill_value, g25, path58, path58_fill_value, path59, path59_fill_value, path60, path60_fill_value, path61, path61_fill_value, g26, path62, path62_fill_value, path63, path63_fill_value, path64, path64_fill_value, path65, path65_fill_value, g27, rect1, rect1_fill_value, polygon3, polygon3_fill_value, path66, path66_fill_value, path67, path67_fill_value, path68, path68_fill_value, path69, path69_fill_value, g29, g28, polygon4, polygon4_fill_value, polygon5, polygon5_fill_value, g31, g30, rect2, rect2_fill_value, rect3, rect3_fill_value, rect4, rect4_fill_value, rect5, rect5_fill_value, rect6, rect6_fill_value, rect7, rect7_fill_value, rect8, rect8_fill_value, rect9, rect9_fill_value, g33, g32, polygon6, polygon6_fill_value, polygon7, polygon7_fill_value, g35, g34, path70, path70_fill_value, path71, path71_fill_value, path72, path72_fill_value, path73, path73_fill_value, g37, g36, path74, path74_fill_value, path75, path75_fill_value, path76, path76_fill_value, g39, g38, path77, path77_fill_value, path78, path78_fill_value, path79, path79_fill_value, g41, g40, path80, path80_fill_value, path81, path81_fill_value, path82, path82_fill_value, path83, path83_fill_value, g42, ellipse1, ellipse1_fill_value, path84, path84_fill_value, path85, path85_fill_value, path86, path86_fill_value, path87, path87_fill_value, g43, polygon8, polygon8_fill_value, polygon9, polygon9_fill_value, polygon10, polygon10_fill_value, g44, polygon11, polygon11_fill_value, polygon12, polygon12_fill_value, polygon13, polygon13_fill_value, g45, polygon14, polygon14_fill_value, polygon15, polygon15_fill_value, polygon16, polygon16_fill_value, g46, polygon17, polygon17_fill_value, polygon18, polygon18_fill_value, polygon19, polygon19_fill_value;

    	return {
    		c: function create() {
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			g49 = svg_element("g");
    			g48 = svg_element("g");
    			g47 = svg_element("g");
    			g0 = svg_element("g");
    			circle0 = svg_element("circle");
    			circle1 = svg_element("circle");
    			circle2 = svg_element("circle");
    			g1 = svg_element("g");
    			circle3 = svg_element("circle");
    			circle4 = svg_element("circle");
    			circle5 = svg_element("circle");
    			g2 = svg_element("g");
    			circle6 = svg_element("circle");
    			circle7 = svg_element("circle");
    			circle8 = svg_element("circle");
    			g3 = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			g4 = svg_element("g");
    			rect0 = svg_element("rect");
    			polygon0 = svg_element("polygon");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			g6 = svg_element("g");
    			g5 = svg_element("g");
    			polygon1 = svg_element("polygon");
    			polygon2 = svg_element("polygon");
    			g8 = svg_element("g");
    			g7 = svg_element("g");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			g10 = svg_element("g");
    			g9 = svg_element("g");
    			path12 = svg_element("path");
    			path13 = svg_element("path");
    			path14 = svg_element("path");
    			g12 = svg_element("g");
    			g11 = svg_element("g");
    			path15 = svg_element("path");
    			path16 = svg_element("path");
    			path17 = svg_element("path");
    			g14 = svg_element("g");
    			g13 = svg_element("g");
    			path18 = svg_element("path");
    			path19 = svg_element("path");
    			path20 = svg_element("path");
    			path21 = svg_element("path");
    			g15 = svg_element("g");
    			ellipse0 = svg_element("ellipse");
    			path22 = svg_element("path");
    			path23 = svg_element("path");
    			path24 = svg_element("path");
    			path25 = svg_element("path");
    			g16 = svg_element("g");
    			circle9 = svg_element("circle");
    			path26 = svg_element("path");
    			path27 = svg_element("path");
    			path28 = svg_element("path");
    			path29 = svg_element("path");
    			g17 = svg_element("g");
    			circle10 = svg_element("circle");
    			path30 = svg_element("path");
    			path31 = svg_element("path");
    			path32 = svg_element("path");
    			path33 = svg_element("path");
    			g18 = svg_element("g");
    			path34 = svg_element("path");
    			path35 = svg_element("path");
    			path36 = svg_element("path");
    			g19 = svg_element("g");
    			path37 = svg_element("path");
    			path38 = svg_element("path");
    			path39 = svg_element("path");
    			g20 = svg_element("g");
    			path40 = svg_element("path");
    			path41 = svg_element("path");
    			path42 = svg_element("path");
    			g21 = svg_element("g");
    			path43 = svg_element("path");
    			path44 = svg_element("path");
    			path45 = svg_element("path");
    			g22 = svg_element("g");
    			path46 = svg_element("path");
    			path47 = svg_element("path");
    			path48 = svg_element("path");
    			path49 = svg_element("path");
    			g23 = svg_element("g");
    			path50 = svg_element("path");
    			path51 = svg_element("path");
    			path52 = svg_element("path");
    			path53 = svg_element("path");
    			g24 = svg_element("g");
    			path54 = svg_element("path");
    			path55 = svg_element("path");
    			path56 = svg_element("path");
    			path57 = svg_element("path");
    			g25 = svg_element("g");
    			path58 = svg_element("path");
    			path59 = svg_element("path");
    			path60 = svg_element("path");
    			path61 = svg_element("path");
    			g26 = svg_element("g");
    			path62 = svg_element("path");
    			path63 = svg_element("path");
    			path64 = svg_element("path");
    			path65 = svg_element("path");
    			g27 = svg_element("g");
    			rect1 = svg_element("rect");
    			polygon3 = svg_element("polygon");
    			path66 = svg_element("path");
    			path67 = svg_element("path");
    			path68 = svg_element("path");
    			path69 = svg_element("path");
    			g29 = svg_element("g");
    			g28 = svg_element("g");
    			polygon4 = svg_element("polygon");
    			polygon5 = svg_element("polygon");
    			g31 = svg_element("g");
    			g30 = svg_element("g");
    			rect2 = svg_element("rect");
    			rect3 = svg_element("rect");
    			rect4 = svg_element("rect");
    			rect5 = svg_element("rect");
    			rect6 = svg_element("rect");
    			rect7 = svg_element("rect");
    			rect8 = svg_element("rect");
    			rect9 = svg_element("rect");
    			g33 = svg_element("g");
    			g32 = svg_element("g");
    			polygon6 = svg_element("polygon");
    			polygon7 = svg_element("polygon");
    			g35 = svg_element("g");
    			g34 = svg_element("g");
    			path70 = svg_element("path");
    			path71 = svg_element("path");
    			path72 = svg_element("path");
    			path73 = svg_element("path");
    			g37 = svg_element("g");
    			g36 = svg_element("g");
    			path74 = svg_element("path");
    			path75 = svg_element("path");
    			path76 = svg_element("path");
    			g39 = svg_element("g");
    			g38 = svg_element("g");
    			path77 = svg_element("path");
    			path78 = svg_element("path");
    			path79 = svg_element("path");
    			g41 = svg_element("g");
    			g40 = svg_element("g");
    			path80 = svg_element("path");
    			path81 = svg_element("path");
    			path82 = svg_element("path");
    			path83 = svg_element("path");
    			g42 = svg_element("g");
    			ellipse1 = svg_element("ellipse");
    			path84 = svg_element("path");
    			path85 = svg_element("path");
    			path86 = svg_element("path");
    			path87 = svg_element("path");
    			g43 = svg_element("g");
    			polygon8 = svg_element("polygon");
    			polygon9 = svg_element("polygon");
    			polygon10 = svg_element("polygon");
    			g44 = svg_element("g");
    			polygon11 = svg_element("polygon");
    			polygon12 = svg_element("polygon");
    			polygon13 = svg_element("polygon");
    			g45 = svg_element("g");
    			polygon14 = svg_element("polygon");
    			polygon15 = svg_element("polygon");
    			polygon16 = svg_element("polygon");
    			g46 = svg_element("g");
    			polygon17 = svg_element("polygon");
    			polygon18 = svg_element("polygon");
    			polygon19 = svg_element("polygon");
    			attr(stop0, "stop-color", stop0_stop_color_value = ctx.colors[0]);
    			attr(stop0, "offset", "0%");
    			add_location(stop0, file$6, 13, 6, 474);
    			attr(stop1, "stop-color", stop1_stop_color_value = ctx.colors[1]);
    			attr(stop1, "offset", "100%");
    			add_location(stop1, file$6, 14, 6, 531);
    			attr(linearGradient, "x1", "50%");
    			attr(linearGradient, "y1", "100%");
    			attr(linearGradient, "x2", "50%");
    			attr(linearGradient, "y2", "1.14423775e-15%");
    			attr(linearGradient, "id", "linearGradient-1");
    			add_location(linearGradient, file$6, 12, 4, 380);
    			add_location(defs, file$6, 11, 2, 369);
    			attr(circle0, "id", "Shape");
    			attr(circle0, "fill", circle0_fill_value = ctx.colors[2]);
    			attr(circle0, "cx", "120");
    			attr(circle0, "cy", "120");
    			attr(circle0, "r", "120");
    			add_location(circle0, file$6, 21, 10, 871);
    			attr(circle1, "id", "Shape");
    			attr(circle1, "fill", circle1_fill_value = ctx.colors[3]);
    			attr(circle1, "cx", "120.597015");
    			attr(circle1, "cy", "120.597015");
    			attr(circle1, "r", "70.4477612");
    			add_location(circle1, file$6, 22, 10, 955);
    			attr(circle2, "id", "Shape");
    			attr(circle2, "fill", circle2_fill_value = ctx.colors[4]);
    			attr(circle2, "cx", "120.597015");
    			attr(circle2, "cy", "120.597015");
    			attr(circle2, "r", "37.0149254");
    			add_location(circle2, file$6, 23, 10, 1060);
    			attr(g0, "transform", "translate(240.600000, 241.000000)");
    			add_location(g0, file$6, 20, 8, 811);
    			attr(circle3, "id", "Shape");
    			attr(circle3, "fill", circle3_fill_value = ctx.colors[5]);
    			attr(circle3, "cx", "120");
    			attr(circle3, "cy", "120");
    			attr(circle3, "r", "120");
    			add_location(circle3, file$6, 26, 10, 1236);
    			attr(circle4, "id", "Shape");
    			attr(circle4, "fill", circle4_fill_value = ctx.colors[3]);
    			attr(circle4, "cx", "120.597015");
    			attr(circle4, "cy", "120.597015");
    			attr(circle4, "r", "70.4477612");
    			add_location(circle4, file$6, 27, 10, 1320);
    			attr(circle5, "id", "Shape");
    			attr(circle5, "fill", circle5_fill_value = ctx.colors[6]);
    			attr(circle5, "cx", "120.597015");
    			attr(circle5, "cy", "120.597015");
    			attr(circle5, "r", "37.0149254");
    			add_location(circle5, file$6, 28, 10, 1425);
    			attr(g1, "transform", "translate(720.000000, 241.000000)");
    			add_location(g1, file$6, 25, 8, 1176);
    			attr(circle6, "id", "Shape");
    			attr(circle6, "fill", circle6_fill_value = ctx.colors[5]);
    			attr(circle6, "cx", "120");
    			attr(circle6, "cy", "120");
    			attr(circle6, "r", "120");
    			add_location(circle6, file$6, 31, 10, 1707);
    			attr(circle7, "id", "Shape");
    			attr(circle7, "fill", circle7_fill_value = ctx.colors[3]);
    			attr(circle7, "cx", "120.597015");
    			attr(circle7, "cy", "120.597015");
    			attr(circle7, "r", "70.4477612");
    			add_location(circle7, file$6, 32, 10, 1791);
    			attr(circle8, "id", "Shape");
    			attr(circle8, "fill", circle8_fill_value = ctx.colors[6]);
    			attr(circle8, "cx", "120.597015");
    			attr(circle8, "cy", "120.597015");
    			attr(circle8, "r", "37.0149254");
    			add_location(circle8, file$6, 33, 10, 1896);
    			attr(g2, "transform", "translate(1320.000000, 841.000000) scale(-1, 1) rotate(-180.000000) translate(-1320.000000, -841.000000) translate(1200.000000, 721.000000)");
    			add_location(g2, file$6, 30, 8, 1541);
    			attr(path0, "d", "M180.737101,121.769042 C213.30426,121.769042 239.70516,148.169941 239.70516,180.737101 C239.70516,213.30426 213.30426,239.70516 180.737101,239.70516 C148.169941,239.70516 121.769042,213.30426 121.769042,180.737101 C121.769042,148.169941 148.169941,121.769042 180.737101,121.769042 Z");
    			attr(path0, "id", "Shape");
    			attr(path0, "fill", path0_fill_value = ctx.colors[2]);
    			add_location(path0, file$6, 36, 10, 2177);
    			attr(path1, "d", "M180.737101,0.294840295 C213.30426,0.294840295 239.70516,26.6957396 239.70516,59.2628993 C239.70516,91.830059 213.30426,118.230958 180.737101,118.230958 C148.169941,118.230958 121.769042,91.830059 121.769042,59.2628993 C121.769042,26.6957396 148.169941,0.294840295 180.737101,0.294840295 Z");
    			attr(path1, "id", "Shape");
    			attr(path1, "fill", path1_fill_value = ctx.colors[5]);
    			add_location(path1, file$6, 37, 10, 2518);
    			attr(path2, "d", "M61.6216216,121.769042 C94.1887813,121.769042 120.589681,148.169941 120.589681,180.737101 C120.589681,213.30426 94.1887813,239.70516 61.6216216,239.70516 C29.0544619,239.70516 2.65356265,213.30426 2.65356265,180.737101 C2.65356265,148.169941 29.0544619,121.769042 61.6216216,121.769042 Z");
    			attr(path2, "id", "Shape");
    			attr(path2, "fill", path2_fill_value = ctx.colors[5]);
    			add_location(path2, file$6, 38, 10, 2866);
    			attr(path3, "d", "M0,0 L60.1474201,0 C93.365923,0 120.29484,27.0609218 120.29484,60.4422604 C120.29484,93.8235991 93.365923,120.884521 60.1474201,120.884521 C26.9289173,120.884521 0,93.8235991 0,60.4422604 L0,0 Z");
    			attr(path3, "id", "Shape");
    			attr(path3, "fill", path3_fill_value = ctx.colors[4]);
    			add_location(path3, file$6, 39, 10, 3212);
    			attr(g3, "transform", "translate(1080.000000, 361.000000) scale(-1, 1) rotate(-270.000000) translate(-1080.000000, -361.000000) translate(960.000000, 241.000000)");
    			add_location(g3, file$6, 35, 8, 2012);
    			attr(rect0, "id", "Shape");
    			attr(rect0, "fill", rect0_fill_value = ctx.colors[6]);
    			attr(rect0, "x", "35.5783784");
    			attr(rect0, "y", "36.168059");
    			attr(rect0, "width", "122.653563");
    			attr(rect0, "height", "122.653563");
    			add_location(rect0, file$6, 42, 10, 3622);
    			attr(polygon0, "id", "Shape");
    			attr(polygon0, "fill", polygon0_fill_value = ctx.colors[4]);
    			attr(polygon0, "transform", "translate(97.803015, 97.803015) rotate(-315.000000) translate(-97.803015, -97.803015) ");
    			attr(polygon0, "points", "60.4160804 60.4160804 135.18995 60.4160804 135.18995 135.18995 60.4160804 135.18995");
    			add_location(polygon0, file$6, 43, 10, 3744);
    			attr(path4, "d", "M0.197542998,0.197542998 L72.7282555,0.197542998 C72.7282555,40.2551494 40.2551494,72.7282555 0.197542998,72.7282555 L0.197542998,0.197542998 Z");
    			attr(path4, "id", "Shape");
    			attr(path4, "fill", path4_fill_value = ctx.colors[2]);
    			add_location(path4, file$6, 44, 10, 3996);
    			attr(path5, "d", "M0.197542998,194.202457 L0.197542998,121.671744 C40.2551494,121.671744 72.7282555,154.144851 72.7282555,194.202457 L0.197542998,194.202457 Z");
    			attr(path5, "id", "Shape");
    			attr(path5, "fill", path5_fill_value = ctx.colors[2]);
    			add_location(path5, file$6, 45, 10, 4198);
    			attr(path6, "d", "M192.433415,194.202457 L119.902703,194.202457 C119.902703,154.144851 152.375809,121.671744 192.433415,121.671744 L192.433415,194.202457 Z");
    			attr(path6, "id", "Shape");
    			attr(path6, "fill", path6_fill_value = ctx.colors[2]);
    			add_location(path6, file$6, 46, 10, 4397);
    			attr(path7, "d", "M192.433415,0.197542998 L192.433415,72.7282555 C152.375809,72.7282555 119.902703,40.2551494 119.902703,0.197542998 L192.433415,0.197542998 Z");
    			attr(path7, "id", "Shape");
    			attr(path7, "fill", path7_fill_value = ctx.colors[2]);
    			add_location(path7, file$6, 47, 10, 4593);
    			attr(g4, "transform", "translate(1320.900000, 361.000000) scale(-1, 1) translate(-1320.900000, -361.000000) translate(1224.600000, 263.800000)");
    			add_location(g4, file$6, 41, 8, 3476);
    			attr(polygon1, "fill", polygon1_fill_value = ctx.colors[3]);
    			attr(polygon1, "transform", "translate(85.583922, 85.673323) rotate(45.000000) translate(-85.583922, -85.673323) ");
    			attr(polygon1, "points", "25.3460718 25.435472 145.777823 25.4794224 145.821773 145.911173 25.3900222 145.867223");
    			add_location(polygon1, file$6, 51, 12, 5021);
    			attr(polygon2, "fill", polygon2_fill_value = ctx.colors[4]);
    			attr(polygon2, "points", "55.2741547 55.3414243 115.89369 55.3414243 115.89369 116.005221 55.2741547 116.005221");
    			add_location(polygon2, file$6, 52, 12, 5265);
    			attr(g5, "id", "Shape");
    			attr(g5, "transform", "translate(0.000000, -0.000000)");
    			add_location(g5, file$6, 50, 10, 4951);
    			attr(g6, "transform", "translate(1560.900000, 1080.700000) scale(-1, 1) translate(-1560.900000, -1080.700000) translate(1475.400000, 995.200000)");
    			add_location(g6, file$6, 49, 8, 4803);
    			attr(path8, "d", "M120,1.03250741e-14 C186.27417,1.03250741e-14 240,53.72583 240,120 C240,186.27417 186.27417,240 120,240 L-2.84217094e-14,240 L-2.84217094e-14,120 C-2.84217094e-14,53.72583 53.72583,1.03250741e-14 120,1.03250741e-14 Z");
    			attr(path8, "fill", path8_fill_value = ctx.colors[6]);
    			add_location(path8, file$6, 57, 12, 5667);
    			attr(path9, "d", "M71.758794,96.4824121 C111.390082,96.4824121 143.517588,128.609918 143.517588,168.241206 C143.517588,207.872494 111.390082,240 71.758794,240 L0,240 L0,168.241206 C0,128.609918 32.1275064,96.4824121 71.758794,96.4824121 Z");
    			attr(path9, "fill", path9_fill_value = ctx.colors[3]);
    			add_location(path9, file$6, 58, 12, 5933);
    			attr(path10, "d", "M120,45.5276382 C160.463878,45.5276382 193.266332,78.3300922 193.266332,118.79397 C193.266332,159.257848 160.463878,192.060302 120,192.060302 C79.5361223,192.060302 46.7336683,159.257848 46.7336683,118.79397 C46.7336683,78.3300922 79.5361223,45.5276382 120,45.5276382 Z");
    			attr(path10, "fill", path10_fill_value = ctx.colors[4]);
    			add_location(path10, file$6, 59, 12, 6203);
    			attr(path11, "d", "M120,75.9045226 C143.687188,75.9045226 162.889447,95.1067822 162.889447,118.79397 C162.889447,142.481157 143.687188,161.683417 120,161.683417 C96.3128124,161.683417 77.1105528,142.481157 77.1105528,118.79397 C77.1105528,95.1067822 96.3128124,75.9045226 120,75.9045226 Z");
    			attr(path11, "fill", path11_fill_value = ctx.colors[3]);
    			add_location(path11, file$6, 60, 12, 6522);
    			attr(g7, "id", "Shape");
    			attr(g7, "transform", "translate(0.000000, 0.000000)");
    			add_location(g7, file$6, 56, 10, 5598);
    			attr(g8, "transform", "translate(1080.000000, 121.000000) scale(-1, 1) rotate(-180.000000) translate(-1080.000000, -121.000000) translate(960.000000, 1.000000)");
    			add_location(g8, file$6, 55, 8, 5435);
    			attr(path12, "d", "M120.603015,1.03250741e-14 L240,1.03250741e-14 L240,119.396985 C240,186.004191 186.004191,240 119.396985,240 L-2.84217094e-14,240 L-2.84217094e-14,120.603015 C-2.84217094e-14,53.9958091 53.9958091,1.03250741e-14 120.603015,1.03250741e-14 Z");
    			attr(path12, "fill", path12_fill_value = ctx.colors[4]);
    			add_location(path12, file$6, 65, 12, 7056);
    			attr(path13, "d", "M120,51.8592965 C158.965216,51.8592965 190.552764,83.4468448 190.552764,122.41206 C190.552764,161.377276 158.965216,192.964824 120,192.964824 L49.4472362,192.964824 L49.4472362,122.41206 C49.4472362,83.4468448 81.0347845,51.8592965 120,51.8592965 Z");
    			attr(path13, "fill", path13_fill_value = ctx.colors[3]);
    			add_location(path13, file$6, 66, 12, 7345);
    			attr(path14, "d", "M192.603015,0 L240.603015,0 L240.603015,48 C240.603015,87.764502 208.367517,120 168.603015,120 L120.603015,120 L120.603015,72 C120.603015,32.235498 152.838513,0 192.603015,0 Z");
    			attr(path14, "fill", path14_fill_value = ctx.colors[5]);
    			add_location(path14, file$6, 67, 12, 7643);
    			attr(g9, "id", "Shape");
    			add_location(g9, file$6, 64, 10, 7029);
    			attr(g10, "transform", "translate(1320.000000, 121.600000) scale(-1, 1) rotate(-270.000000) translate(-1320.000000, -121.600000) translate(1199.400000, 1.600000)");
    			add_location(g10, file$6, 63, 8, 6865);
    			attr(path15, "d", "M120.603015,1.03250741e-14 L240,1.03250741e-14 L240,119.396985 C240,186.004191 186.004191,240 119.396985,240 L-2.84217094e-14,240 L-2.84217094e-14,120.603015 C-2.84217094e-14,53.9958091 53.9958091,1.03250741e-14 120.603015,1.03250741e-14 Z");
    			attr(path15, "fill", path15_fill_value = ctx.colors[2]);
    			add_location(path15, file$6, 72, 12, 8070);
    			attr(path16, "d", "M120,51.8592965 C158.965216,51.8592965 190.552764,83.4468448 190.552764,122.41206 C190.552764,161.377276 158.965216,192.964824 120,192.964824 L49.4472362,192.964824 L49.4472362,122.41206 C49.4472362,83.4468448 81.0347845,51.8592965 120,51.8592965 Z");
    			attr(path16, "fill", path16_fill_value = ctx.colors[3]);
    			add_location(path16, file$6, 73, 12, 8359);
    			attr(path17, "d", "M192.603015,0 L240.603015,0 L240.603015,48 C240.603015,87.764502 208.367517,120 168.603015,120 L120.603015,120 L120.603015,72 C120.603015,32.235498 152.838513,0 192.603015,0 Z");
    			attr(path17, "fill", path17_fill_value = ctx.colors[5]);
    			add_location(path17, file$6, 74, 12, 8657);
    			attr(g11, "id", "Shape");
    			add_location(g11, file$6, 71, 10, 8043);
    			attr(g12, "transform", "translate(1560.000000, 121.600000) rotate(-270.000000) translate(-1560.000000, -121.600000) translate(1439.400000, 1.600000)");
    			add_location(g12, file$6, 70, 8, 7892);
    			attr(path18, "d", "M120,1.03250741e-14 C186.27417,1.03250741e-14 240,53.72583 240,120 C240,186.27417 186.27417,240 120,240 L-2.84217094e-14,240 L-2.84217094e-14,120 C-2.84217094e-14,53.72583 53.72583,1.03250741e-14 120,1.03250741e-14 Z");
    			attr(path18, "fill", path18_fill_value = ctx.colors[6]);
    			add_location(path18, file$6, 79, 12, 9079);
    			attr(path19, "d", "M71.758794,96.4824121 C111.390082,96.4824121 143.517588,128.609918 143.517588,168.241206 C143.517588,207.872494 111.390082,240 71.758794,240 L0,240 L0,168.241206 C-4.85343295e-15,128.609918 32.1275064,96.4824121 71.758794,96.4824121 Z");
    			attr(path19, "fill", path19_fill_value = ctx.colors[2]);
    			attr(path19, "transform", "translate(71.758794, 168.241206) rotate(-360.000000) translate(-71.758794, -168.241206) ");
    			add_location(path19, file$6, 80, 12, 9345);
    			attr(path20, "d", "M120,45.5276382 C160.463878,45.5276382 193.266332,78.3300922 193.266332,118.79397 C193.266332,159.257848 160.463878,192.060302 120,192.060302 C79.5361223,192.060302 46.7336683,159.257848 46.7336683,118.79397 C46.7336683,78.3300922 79.5361223,45.5276382 120,45.5276382 Z");
    			attr(path20, "fill", path20_fill_value = ctx.colors[4]);
    			add_location(path20, file$6, 81, 12, 9730);
    			attr(path21, "d", "M120,75.9045226 C143.687188,75.9045226 162.889447,95.1067822 162.889447,118.79397 C162.889447,142.481157 143.687188,161.683417 120,161.683417 C96.3128124,161.683417 77.1105528,142.481157 77.1105528,118.79397 C77.1105528,95.1067822 96.3128124,75.9045226 120,75.9045226 Z");
    			attr(path21, "fill", path21_fill_value = ctx.colors[3]);
    			add_location(path21, file$6, 82, 12, 10049);
    			attr(g13, "id", "Shape");
    			add_location(g13, file$6, 78, 10, 9052);
    			attr(g14, "transform", "translate(1560.000000, 841.000000) scale(-1, 1) translate(-1560.000000, -841.000000) translate(1440.000000, 721.000000)");
    			add_location(g14, file$6, 77, 8, 8906);
    			attr(ellipse0, "id", "Shape");
    			attr(ellipse0, "fill", ellipse0_fill_value = ctx.colors[6]);
    			attr(ellipse0, "cx", "120.29484");
    			attr(ellipse0, "cy", "119.704433");
    			attr(ellipse0, "rx", "100.835381");
    			attr(ellipse0, "ry", "100.788177");
    			add_location(ellipse0, file$6, 86, 10, 10452);
    			attr(path22, "d", "M240,0 C240,65.9476962 186.670183,119.408867 120.884521,119.408867 C120.884521,53.4611708 174.214337,0 240,0 Z");
    			attr(path22, "id", "Shape");
    			attr(path22, "fill", path22_fill_value = ctx.colors[2]);
    			add_location(path22, file$6, 87, 10, 10575);
    			attr(path23, "d", "M115.784245,0.14669394 L119.262173,0.14669394 L119.262173,3.61607683 C119.262173,67.4856522 67.3581238,119.262173 3.33123423,119.262173 L-0.14669394,119.262173 L-0.14669394,115.79279 C-0.14669394,51.9232148 51.7573553,0.14669394 115.784245,0.14669394 Z");
    			attr(path23, "id", "Shape");
    			attr(path23, "fill", path23_fill_value = ctx.colors[4]);
    			attr(path23, "transform", "translate(59.557740, 59.704433) rotate(-270.000000) translate(-59.557740, -59.704433) ");
    			add_location(path23, file$6, 88, 10, 10744);
    			attr(path24, "d", "M115.646096,120.591133 L119.115479,120.591133 L119.115479,124.069061 C119.115479,188.095951 67.3389582,240 3.46938289,240 L0,240 L0,236.522072 C0,172.495182 51.7765209,120.591133 115.646096,120.591133 Z");
    			attr(path24, "id", "Shape");
    			attr(path24, "fill", path24_fill_value = ctx.colors[2]);
    			add_location(path24, file$6, 89, 10, 11154);
    			attr(path25, "d", "M236.668766,120.737827 L240.146694,120.737827 L240.146694,124.20721 C240.146694,188.076785 188.242645,239.853306 124.215755,239.853306 L120.737827,239.853306 L120.737827,236.383923 C120.737827,172.514348 172.641876,120.737827 236.668766,120.737827 Z");
    			attr(path25, "id", "Shape");
    			attr(path25, "fill", path25_fill_value = ctx.colors[4]);
    			attr(path25, "transform", "translate(180.442260, 180.295567) rotate(-270.000000) translate(-180.442260, -180.295567) ");
    			add_location(path25, file$6, 90, 10, 11415);
    			attr(g15, "transform", "translate(240.000000, 481.000000)");
    			add_location(g15, file$6, 85, 8, 10392);
    			attr(circle9, "id", "Shape");
    			attr(circle9, "fill", circle9_fill_value = ctx.colors[6]);
    			attr(circle9, "cx", "120.035381");
    			attr(circle9, "cy", "119.435381");
    			attr(circle9, "r", "100.835381");
    			add_location(circle9, file$6, 93, 10, 11897);
    			attr(path26, "d", "M116.504854,240 C52.161,240 0,187.839 0,123.495146 L0,120 L3.49514563,120 C67.839,120 120,172.161 120,236.504854 L120,240 L116.504854,240 Z");
    			attr(path26, "id", "Shape");
    			attr(path26, "fill", path26_fill_value = ctx.colors[2]);
    			add_location(path26, file$6, 94, 10, 12002);
    			attr(path27, "d", "M236.504854,120 L240,120 L240,123.495146 C240,187.839 187.839,240 123.495146,240 L120,240 L120,236.504854 C120,172.161 172.161,120 236.504854,120 Z");
    			attr(path27, "id", "Shape");
    			attr(path27, "fill", path27_fill_value = ctx.colors[4]);
    			add_location(path27, file$6, 95, 10, 12200);
    			attr(path28, "d", "M123.495146,120 L120,120 L120,116.504854 C120,52.161 172.161,0 236.504854,0 L240,0 L240,3.49514563 C240,67.839 187.839,120 123.495146,120 Z");
    			attr(path28, "id", "Shape");
    			attr(path28, "fill", path28_fill_value = ctx.colors[2]);
    			add_location(path28, file$6, 96, 10, 12406);
    			attr(path29, "d", "M3.49514563,0 C67.839,0 120,52.161 120,116.504854 L120,120 L116.504854,120 C52.161,120 0,67.839 0,3.49514563 L0,0 L3.49514563,0 Z");
    			attr(path29, "id", "Shape");
    			attr(path29, "fill", path29_fill_value = ctx.colors[4]);
    			add_location(path29, file$6, 97, 10, 12604);
    			attr(g16, "transform", "translate(960.000000, 481.000000)");
    			add_location(g16, file$6, 92, 8, 11837);
    			attr(circle10, "id", "Shape");
    			attr(circle10, "fill", circle10_fill_value = ctx.colors[6]);
    			attr(circle10, "cx", "120.035381");
    			attr(circle10, "cy", "119.435381");
    			attr(circle10, "r", "100.835381");
    			add_location(circle10, file$6, 100, 10, 12951);
    			attr(path30, "d", "M116.504854,240 C52.161,240 0,187.839 0,123.495146 L0,120 L3.49514563,120 C67.839,120 120,172.161 120,236.504854 L120,240 L116.504854,240 Z");
    			attr(path30, "id", "Shape");
    			attr(path30, "fill", path30_fill_value = ctx.colors[2]);
    			add_location(path30, file$6, 101, 10, 13056);
    			attr(path31, "d", "M236.504854,120 L240,120 L240,123.495146 C240,187.839 187.839,240 123.495146,240 L120,240 L120,236.504854 C120,172.161 172.161,120 236.504854,120 Z");
    			attr(path31, "id", "Shape");
    			attr(path31, "fill", path31_fill_value = ctx.colors[4]);
    			add_location(path31, file$6, 102, 10, 13254);
    			attr(path32, "d", "M123.495146,120 L120,120 L120,116.504854 C120,52.161 172.161,0 236.504854,0 L240,0 L240,3.49514563 C240,67.839 187.839,120 123.495146,120 Z");
    			attr(path32, "id", "Shape");
    			attr(path32, "fill", path32_fill_value = ctx.colors[2]);
    			add_location(path32, file$6, 103, 10, 13460);
    			attr(path33, "d", "M3.49514563,0 C67.839,0 120,52.161 120,116.504854 L120,120 L116.504854,120 C52.161,120 0,67.839 0,3.49514563 L0,0 L3.49514563,0 Z");
    			attr(path33, "id", "Shape");
    			attr(path33, "fill", path33_fill_value = ctx.colors[4]);
    			add_location(path33, file$6, 104, 10, 13658);
    			attr(g17, "transform", "translate(120.000000, 841.000000) rotate(-270.000000) translate(-120.000000, -841.000000) translate(0.000000, 721.000000)");
    			add_location(g17, file$6, 99, 8, 12803);
    			attr(path34, "d", "M240,0 L240,240 L0,240 C0,107.45166 107.45166,0 240,0 Z");
    			attr(path34, "id", "Shape");
    			attr(path34, "fill", path34_fill_value = ctx.colors[2]);
    			add_location(path34, file$6, 107, 10, 13915);
    			attr(path35, "d", "M240,103.783784 L240,240 L103.448276,240 C103.448276,164.769861 164.584565,103.783784 240,103.783784 Z");
    			attr(path35, "id", "Shape");
    			attr(path35, "fill", path35_fill_value = ctx.colors[6]);
    			add_location(path35, file$6, 108, 10, 14029);
    			attr(path36, "d", "M240,177.493857 L240,240 L177.339901,240 C177.339901,205.478811 205.393783,177.493857 240,177.493857 Z");
    			attr(path36, "id", "Shape");
    			attr(path36, "fill", path36_fill_value = ctx.colors[3]);
    			add_location(path36, file$6, 109, 10, 14190);
    			attr(g18, "transform", "translate(480.000000, 1.000000)");
    			add_location(g18, file$6, 106, 8, 13857);
    			attr(path37, "d", "M240,0 L240,240 L0,240 C0,107.45166 107.45166,0 240,0 Z");
    			attr(path37, "id", "Shape");
    			attr(path37, "fill", path37_fill_value = ctx.colors[2]);
    			add_location(path37, file$6, 112, 10, 14515);
    			attr(path38, "d", "M240,103.783784 L240,240 L103.448276,240 C103.448276,164.769861 164.584565,103.783784 240,103.783784 Z");
    			attr(path38, "id", "Shape");
    			attr(path38, "fill", path38_fill_value = ctx.colors[6]);
    			add_location(path38, file$6, 113, 10, 14629);
    			attr(path39, "d", "M240,177.493857 L240,240 L177.339901,240 C177.339901,205.478811 205.393783,177.493857 240,177.493857 Z");
    			attr(path39, "id", "Shape");
    			attr(path39, "fill", path39_fill_value = ctx.colors[3]);
    			add_location(path39, file$6, 114, 10, 14790);
    			attr(g19, "transform", "translate(1560.000000, 601.000000) rotate(-270.000000) translate(-1560.000000, -601.000000) translate(1440.000000, 481.000000)");
    			add_location(g19, file$6, 111, 8, 14362);
    			attr(path40, "d", "M240,0 L240,240 L0,240 C0,107.45166 107.45166,0 240,0 Z");
    			attr(path40, "id", "Shape");
    			attr(path40, "fill", path40_fill_value = ctx.colors[4]);
    			add_location(path40, file$6, 117, 10, 15110);
    			attr(path41, "d", "M240,103.448276 L240,240 L103.783784,240 C103.783784,164.584565 164.769861,103.448276 240,103.448276 Z");
    			attr(path41, "id", "Shape");
    			attr(path41, "fill", path41_fill_value = ctx.colors[6]);
    			add_location(path41, file$6, 118, 10, 15224);
    			attr(path42, "d", "M240,177.339901 L240,240 L177.493857,240 C177.493857,205.393783 205.478811,177.339901 240,177.339901 Z");
    			attr(path42, "id", "Shape");
    			attr(path42, "fill", path42_fill_value = ctx.colors[3]);
    			add_location(path42, file$6, 119, 10, 15385);
    			attr(g20, "transform", "translate(120.000000, 601.000000) rotate(-180.000000) translate(-120.000000, -601.000000) translate(0.000000, 481.000000)");
    			add_location(g20, file$6, 116, 8, 14962);
    			attr(path43, "d", "M240,0 L240,240 L0,240 C0,107.45166 107.45166,0 240,0 Z");
    			attr(path43, "id", "Shape");
    			attr(path43, "fill", path43_fill_value = ctx.colors[4]);
    			add_location(path43, file$6, 122, 10, 15710);
    			attr(path44, "d", "M240,103.448276 L240,240 L103.783784,240 C103.783784,164.584565 164.769861,103.448276 240,103.448276 Z");
    			attr(path44, "id", "Shape");
    			attr(path44, "fill", path44_fill_value = ctx.colors[6]);
    			add_location(path44, file$6, 123, 10, 15824);
    			attr(path45, "d", "M240,177.339901 L240,240 L177.493857,240 C177.493857,205.393783 205.478811,177.339901 240,177.339901 Z");
    			attr(path45, "id", "Shape");
    			attr(path45, "fill", path45_fill_value = ctx.colors[3]);
    			add_location(path45, file$6, 124, 10, 15985);
    			attr(g21, "transform", "translate(1320.000000, 601.000000) rotate(-360.000000) translate(-1320.000000, -601.000000) translate(1200.000000, 481.000000)");
    			add_location(g21, file$6, 121, 8, 15557);
    			attr(path46, "d", "M120,0 C186.27417,0 240,53.72583 240,120 C240,186.27417 186.27417,240 120,240 C53.72583,240 0,186.27417 0,120 C0,53.72583 53.72583,0 120,0 Z");
    			attr(path46, "id", "Shape");
    			attr(path46, "fill", path46_fill_value = ctx.colors[4]);
    			add_location(path46, file$6, 127, 10, 16303);
    			attr(path47, "d", "M120.589681,48.3538084 C160.484451,48.3538084 192.825553,80.69491 192.825553,120.589681 C192.825553,160.484451 160.484451,192.825553 120.589681,192.825553 C80.69491,192.825553 48.3538084,160.484451 48.3538084,120.589681 C48.3538084,80.69491 80.69491,48.3538084 120.589681,48.3538084 Z");
    			attr(path47, "id", "Shape");
    			attr(path47, "fill", path47_fill_value = ctx.colors[6]);
    			add_location(path47, file$6, 128, 10, 16502);
    			attr(path48, "d", "M121.769042,83.1449631 C143.100531,83.1449631 160.39312,100.437552 160.39312,121.769042 C160.39312,143.100531 143.100531,160.39312 121.769042,160.39312 C100.437552,160.39312 83.1449631,143.100531 83.1449631,121.769042 C83.1449631,100.437552 100.437552,83.1449631 121.769042,83.1449631 Z");
    			attr(path48, "id", "Shape");
    			attr(path48, "fill", path48_fill_value = ctx.colors[3]);
    			add_location(path48, file$6, 129, 10, 16845);
    			attr(path49, "d", "M240,94.3488943 L240,240 L94.3488943,240 C94.3488943,159.559116 159.559116,94.3488943 240,94.3488943 Z");
    			attr(path49, "id", "Shape");
    			attr(path49, "fill", path49_fill_value = ctx.colors[2]);
    			add_location(path49, file$6, 130, 10, 17190);
    			attr(g22, "transform", "translate(120.600000, 121.000000) rotate(-360.000000) translate(-120.600000, -121.000000) translate(0.600000, 1.000000)");
    			add_location(g22, file$6, 126, 8, 16157);
    			attr(path50, "d", "M120,0 C186.27417,0 240,53.72583 240,120 C240,186.27417 186.27417,240 120,240 C53.72583,240 0,186.27417 0,120 C0,53.72583 53.72583,0 120,0 Z");
    			attr(path50, "id", "Shape");
    			attr(path50, "fill", path50_fill_value = ctx.colors[4]);
    			add_location(path50, file$6, 133, 10, 17517);
    			attr(path51, "d", "M120.589681,48.3538084 C160.484451,48.3538084 192.825553,80.69491 192.825553,120.589681 C192.825553,160.484451 160.484451,192.825553 120.589681,192.825553 C80.69491,192.825553 48.3538084,160.484451 48.3538084,120.589681 C48.3538084,80.69491 80.69491,48.3538084 120.589681,48.3538084 Z");
    			attr(path51, "id", "Shape");
    			attr(path51, "fill", path51_fill_value = ctx.colors[6]);
    			add_location(path51, file$6, 134, 10, 17716);
    			attr(path52, "d", "M121.769042,83.1449631 C143.100531,83.1449631 160.39312,100.437552 160.39312,121.769042 C160.39312,143.100531 143.100531,160.39312 121.769042,160.39312 C100.437552,160.39312 83.1449631,143.100531 83.1449631,121.769042 C83.1449631,100.437552 100.437552,83.1449631 121.769042,83.1449631 Z");
    			attr(path52, "id", "Shape");
    			attr(path52, "fill", path52_fill_value = ctx.colors[3]);
    			add_location(path52, file$6, 135, 10, 18059);
    			attr(path53, "d", "M240,94.3488943 L240,240 L94.3488943,240 C94.3488943,159.559116 159.559116,94.3488943 240,94.3488943 Z");
    			attr(path53, "id", "Shape");
    			attr(path53, "fill", path53_fill_value = ctx.colors[2]);
    			add_location(path53, file$6, 136, 10, 18404);
    			attr(g23, "transform", "translate(1320.000000, 1081.000000) rotate(-360.000000) translate(-1320.000000, -1081.000000) translate(1200.000000, 961.000000)");
    			add_location(g23, file$6, 132, 8, 17362);
    			attr(path54, "d", "M181.031941,122.063882 C213.599101,122.063882 240,148.464781 240,181.031941 C240,213.599101 213.599101,240 181.031941,240 C148.464781,240 122.063882,213.599101 122.063882,181.031941 C122.063882,148.464781 148.464781,122.063882 181.031941,122.063882 Z");
    			attr(path54, "id", "Shape");
    			attr(path54, "fill", path54_fill_value = ctx.colors[5]);
    			add_location(path54, file$6, 139, 10, 18724);
    			attr(path55, "d", "M181.031941,0 C213.599101,0 240,26.4008993 240,58.968059 C240,91.5352187 213.599101,117.936118 181.031941,117.936118 C148.464781,117.936118 122.063882,91.5352187 122.063882,58.968059 C122.063882,26.4008993 148.464781,0 181.031941,0 Z");
    			attr(path55, "id", "Shape");
    			attr(path55, "fill", path55_fill_value = ctx.colors[2]);
    			add_location(path55, file$6, 140, 10, 19033);
    			attr(path56, "d", "M61.3267813,122.063882 C93.893941,122.063882 120.29484,148.464781 120.29484,181.031941 C120.29484,213.599101 93.893941,240 61.3267813,240 C28.7596216,240 2.35872236,213.599101 2.35872236,181.031941 C2.35872236,148.464781 28.7596216,122.063882 61.3267813,122.063882 Z");
    			attr(path56, "id", "Shape");
    			attr(path56, "fill", path56_fill_value = ctx.colors[2]);
    			add_location(path56, file$6, 141, 10, 19325);
    			attr(path57, "d", "M0,0 L60.4422604,0 C93.8235991,0 120.884521,27.0609218 120.884521,60.4422604 C120.884521,93.8235991 93.8235991,120.884521 60.4422604,120.884521 C27.0609218,120.884521 0,93.8235991 0,60.4422604 L0,0 Z");
    			attr(path57, "id", "Shape");
    			attr(path57, "fill", path57_fill_value = ctx.colors[4]);
    			add_location(path57, file$6, 142, 10, 19650);
    			attr(g24, "transform", "translate(360.600000, 120.400000) rotate(-180.000000) translate(-360.600000, -120.400000) translate(240.600000, 0.400000)");
    			add_location(g24, file$6, 138, 8, 18576);
    			attr(path58, "d", "M180.737101,121.769042 C213.30426,121.769042 239.70516,148.169941 239.70516,180.737101 C239.70516,213.30426 213.30426,239.70516 180.737101,239.70516 C148.169941,239.70516 121.769042,213.30426 121.769042,180.737101 C121.769042,148.169941 148.169941,121.769042 180.737101,121.769042 Z");
    			attr(path58, "id", "Shape");
    			attr(path58, "fill", path58_fill_value = ctx.colors[2]);
    			add_location(path58, file$6, 145, 10, 20068);
    			attr(path59, "d", "M180.737101,0.294840295 C213.30426,0.294840295 239.70516,26.6957396 239.70516,59.2628993 C239.70516,91.830059 213.30426,118.230958 180.737101,118.230958 C148.169941,118.230958 121.769042,91.830059 121.769042,59.2628993 C121.769042,26.6957396 148.169941,0.294840295 180.737101,0.294840295 Z");
    			attr(path59, "id", "Shape");
    			attr(path59, "fill", path59_fill_value = ctx.colors[5]);
    			add_location(path59, file$6, 146, 10, 20409);
    			attr(path60, "d", "M61.6216216,121.769042 C94.1887813,121.769042 120.589681,148.169941 120.589681,180.737101 C120.589681,213.30426 94.1887813,239.70516 61.6216216,239.70516 C29.0544619,239.70516 2.65356265,213.30426 2.65356265,180.737101 C2.65356265,148.169941 29.0544619,121.769042 61.6216216,121.769042 Z");
    			attr(path60, "id", "Shape");
    			attr(path60, "fill", path60_fill_value = ctx.colors[5]);
    			add_location(path60, file$6, 147, 10, 20757);
    			attr(path61, "d", "M0,0 L60.1474201,0 C93.365923,0 120.29484,27.0609218 120.29484,60.4422604 C120.29484,93.8235991 93.365923,120.884521 60.1474201,120.884521 C26.9289173,120.884521 0,93.8235991 0,60.4422604 L0,0 Z");
    			attr(path61, "id", "Shape");
    			attr(path61, "fill", path61_fill_value = ctx.colors[4]);
    			add_location(path61, file$6, 148, 10, 21103);
    			attr(g25, "transform", "translate(600.000000, 841.000000) rotate(-90.000000) translate(-600.000000, -841.000000) translate(480.000000, 721.000000)");
    			add_location(g25, file$6, 144, 8, 19919);
    			attr(path62, "d", "M181.031941,122.063882 C213.599101,122.063882 240,148.464781 240,181.031941 C240,213.599101 213.599101,240 181.031941,240 C148.464781,240 122.063882,213.599101 122.063882,181.031941 C122.063882,148.464781 148.464781,122.063882 181.031941,122.063882 Z");
    			attr(path62, "id", "Shape");
    			attr(path62, "fill", path62_fill_value = ctx.colors[2]);
    			add_location(path62, file$6, 151, 10, 21517);
    			attr(path63, "d", "M181.031941,0 C213.599101,0 240,26.4008993 240,58.968059 C240,91.5352187 213.599101,117.936118 181.031941,117.936118 C148.464781,117.936118 122.063882,91.5352187 122.063882,58.968059 C122.063882,26.4008993 148.464781,0 181.031941,0 Z");
    			attr(path63, "id", "Shape");
    			attr(path63, "fill", path63_fill_value = ctx.colors[5]);
    			add_location(path63, file$6, 152, 10, 21826);
    			attr(path64, "d", "M61.3267813,122.063882 C93.893941,122.063882 120.29484,148.464781 120.29484,181.031941 C120.29484,213.599101 93.893941,240 61.3267813,240 C28.7596216,240 2.35872236,213.599101 2.35872236,181.031941 C2.35872236,148.464781 28.7596216,122.063882 61.3267813,122.063882 Z");
    			attr(path64, "id", "Shape");
    			attr(path64, "fill", path64_fill_value = ctx.colors[5]);
    			add_location(path64, file$6, 153, 10, 22118);
    			attr(path65, "d", "M0,0 L60.4422604,0 C93.8235991,0 120.884521,27.0609218 120.884521,60.4422604 C120.884521,93.8235991 93.8235991,120.884521 60.4422604,120.884521 C27.0609218,120.884521 0,93.8235991 0,60.4422604 L0,0 Z");
    			attr(path65, "id", "Shape");
    			attr(path65, "fill", path65_fill_value = ctx.colors[4]);
    			add_location(path65, file$6, 154, 10, 22443);
    			attr(g26, "transform", "translate(120.000000, 1081.000000) rotate(-180.000000) translate(-120.000000, -1081.000000) translate(0.000000, 961.000000)");
    			add_location(g26, file$6, 150, 8, 21367);
    			attr(rect1, "id", "Shape");
    			attr(rect1, "fill", rect1_fill_value = ctx.colors[6]);
    			attr(rect1, "x", "35.5783784");
    			attr(rect1, "y", "36.168059");
    			attr(rect1, "width", "122.653563");
    			attr(rect1, "height", "122.653563");
    			add_location(rect1, file$6, 157, 10, 22862);
    			attr(polygon3, "id", "Shape");
    			attr(polygon3, "fill", polygon3_fill_value = ctx.colors[4]);
    			attr(polygon3, "transform", "translate(97.803015, 97.803015) rotate(-315.000000) translate(-97.803015, -97.803015) ");
    			attr(polygon3, "points", "60.4160804 60.4160804 135.18995 60.4160804 135.18995 135.18995 60.4160804 135.18995");
    			add_location(polygon3, file$6, 158, 10, 22984);
    			attr(path66, "d", "M0.197542998,0.197542998 L72.7282555,0.197542998 C72.7282555,40.2551494 40.2551494,72.7282555 0.197542998,72.7282555 L0.197542998,0.197542998 Z");
    			attr(path66, "id", "Shape");
    			attr(path66, "fill", path66_fill_value = ctx.colors[2]);
    			add_location(path66, file$6, 159, 10, 23236);
    			attr(path67, "d", "M0.197542998,194.202457 L0.197542998,121.671744 C40.2551494,121.671744 72.7282555,154.144851 72.7282555,194.202457 L0.197542998,194.202457 Z");
    			attr(path67, "id", "Shape");
    			attr(path67, "fill", path67_fill_value = ctx.colors[2]);
    			add_location(path67, file$6, 160, 10, 23438);
    			attr(path68, "d", "M192.433415,194.202457 L119.902703,194.202457 C119.902703,154.144851 152.375809,121.671744 192.433415,121.671744 L192.433415,194.202457 Z");
    			attr(path68, "id", "Shape");
    			attr(path68, "fill", path68_fill_value = ctx.colors[2]);
    			add_location(path68, file$6, 161, 10, 23637);
    			attr(path69, "d", "M192.433415,0.197542998 L192.433415,72.7282555 C152.375809,72.7282555 119.902703,40.2551494 119.902703,0.197542998 L192.433415,0.197542998 Z");
    			attr(path69, "id", "Shape");
    			attr(path69, "fill", path69_fill_value = ctx.colors[2]);
    			add_location(path69, file$6, 162, 10, 23833);
    			attr(g27, "transform", "translate(840.900000, 841.000000) rotate(-180.000000) translate(-840.900000, -841.000000) translate(744.600000, 743.800000)");
    			add_location(g27, file$6, 156, 8, 22712);
    			attr(polygon4, "fill", polygon4_fill_value = ctx.colors[5]);
    			attr(polygon4, "transform", "translate(85.583192, 85.672588) rotate(45.000000) translate(-85.583192, -85.672588) ");
    			attr(polygon4, "points", "25.3457107 25.4351067 145.776724 25.4790568 145.820674 145.91007 25.3896608 145.86612");
    			add_location(polygon4, file$6, 166, 12, 24219);
    			attr(polygon5, "fill", polygon5_fill_value = ctx.colors[6]);
    			attr(polygon5, "transform", "translate(85.583192, 85.672588) rotate(45.000000) translate(-85.583192, -85.672588) ");
    			attr(polygon5, "points", "55.2514797 55.3408757 115.892774 55.3630062 115.914905 116.004301 55.2736102 115.98217");
    			add_location(polygon5, file$6, 167, 12, 24462);
    			attr(g28, "id", "Shape");
    			add_location(g28, file$6, 165, 10, 24192);
    			attr(g29, "transform", "translate(120.900000, 361.300000) rotate(-180.000000) translate(-120.900000, -361.300000) translate(35.400000, 275.800000)");
    			add_location(g29, file$6, 164, 8, 24043);
    			attr(rect2, "fill", rect2_fill_value = ctx.colors[6]);
    			attr(rect2, "x", "96.6572864");
    			attr(rect2, "y", "94.2512563");
    			attr(rect2, "width", "74.7738693");
    			attr(rect2, "height", "74.7738693");
    			add_location(rect2, file$6, 172, 12, 24906);
    			attr(rect3, "fill", rect3_fill_value = ctx.colors[6]);
    			attr(rect3, "x", "96.6572864");
    			attr(rect3, "y", "0.180904523");
    			attr(rect3, "width", "74.7738693");
    			attr(rect3, "height", "74.7738693");
    			add_location(rect3, file$6, 173, 12, 25020);
    			attr(rect4, "fill", rect4_fill_value = ctx.colors[6]);
    			attr(rect4, "x", "0.174874372");
    			attr(rect4, "y", "94.2512563");
    			attr(rect4, "width", "74.7738693");
    			attr(rect4, "height", "74.7738693");
    			add_location(rect4, file$6, 174, 12, 25135);
    			attr(rect5, "fill", rect5_fill_value = ctx.colors[6]);
    			attr(rect5, "x", "0.174874372");
    			attr(rect5, "y", "0.180904523");
    			attr(rect5, "width", "74.7738693");
    			attr(rect5, "height", "74.7738693");
    			add_location(rect5, file$6, 175, 12, 25250);
    			attr(rect6, "fill", rect6_fill_value = ctx.colors[3]);
    			attr(rect6, "x", "117.159799");
    			attr(rect6, "y", "114.753769");
    			attr(rect6, "width", "34.9748744");
    			attr(rect6, "height", "34.9748744");
    			add_location(rect6, file$6, 176, 12, 25366);
    			attr(rect7, "fill", rect7_fill_value = ctx.colors[3]);
    			attr(rect7, "x", "117.159799");
    			attr(rect7, "y", "20.6834171");
    			attr(rect7, "width", "34.9748744");
    			attr(rect7, "height", "34.9748744");
    			add_location(rect7, file$6, 177, 12, 25480);
    			attr(rect8, "fill", rect8_fill_value = ctx.colors[3]);
    			attr(rect8, "x", "20.6773869");
    			attr(rect8, "y", "114.753769");
    			attr(rect8, "width", "34.9748744");
    			attr(rect8, "height", "34.9748744");
    			add_location(rect8, file$6, 178, 12, 25594);
    			attr(rect9, "fill", rect9_fill_value = ctx.colors[3]);
    			attr(rect9, "x", "20.6773869");
    			attr(rect9, "y", "20.6834171");
    			attr(rect9, "width", "34.9748744");
    			attr(rect9, "height", "34.9748744");
    			add_location(rect9, file$6, 179, 12, 25708);
    			attr(g30, "id", "Shape");
    			add_location(g30, file$6, 171, 10, 24879);
    			attr(g31, "transform", "translate(839.400000, 120.400000) rotate(-180.000000) translate(-839.400000, -120.400000) translate(753.600000, 35.800000)");
    			add_location(g31, file$6, 170, 8, 24730);
    			attr(polygon6, "fill", polygon6_fill_value = ctx.colors[3]);
    			attr(polygon6, "transform", "translate(85.583922, 85.673323) rotate(45.000000) translate(-85.583922, -85.673323) ");
    			attr(polygon6, "points", "25.3460718 25.435472 145.777823 25.4794224 145.821773 145.911173 25.3900222 145.867223");
    			add_location(polygon6, file$6, 184, 12, 26066);
    			attr(polygon7, "fill", polygon7_fill_value = ctx.colors[4]);
    			attr(polygon7, "points", "55.2741547 55.3414243 115.89369 55.3414243 115.89369 116.005221 55.2741547 116.005221");
    			add_location(polygon7, file$6, 185, 12, 26310);
    			attr(g32, "id", "Shape");
    			attr(g32, "transform", "translate(0.000000, -0.000000)");
    			add_location(g32, file$6, 183, 10, 25996);
    			attr(g33, "transform", "translate(601.500000, 601.300000) rotate(-180.000000) translate(-601.500000, -601.300000) translate(516.000000, 515.800000)");
    			add_location(g33, file$6, 182, 8, 25846);
    			attr(path70, "d", "M120,1.03250741e-14 C186.27417,1.03250741e-14 240,53.72583 240,120 C240,186.27417 186.27417,240 120,240 L-2.84217094e-14,240 L-2.84217094e-14,120 C-2.84217094e-14,53.72583 53.72583,1.03250741e-14 120,1.03250741e-14 Z");
    			attr(path70, "fill", path70_fill_value = ctx.colors[6]);
    			add_location(path70, file$6, 190, 12, 26701);
    			attr(path71, "d", "M71.758794,96.4824121 C111.390082,96.4824121 143.517588,128.609918 143.517588,168.241206 C143.517588,207.872494 111.390082,240 71.758794,240 L0,240 L0,168.241206 C0,128.609918 32.1275064,96.4824121 71.758794,96.4824121 Z");
    			attr(path71, "fill", path71_fill_value = ctx.colors[3]);
    			add_location(path71, file$6, 191, 12, 26967);
    			attr(path72, "d", "M120,45.5276382 C160.463878,45.5276382 193.266332,78.3300922 193.266332,118.79397 C193.266332,159.257848 160.463878,192.060302 120,192.060302 C79.5361223,192.060302 46.7336683,159.257848 46.7336683,118.79397 C46.7336683,78.3300922 79.5361223,45.5276382 120,45.5276382 Z");
    			attr(path72, "fill", path72_fill_value = ctx.colors[4]);
    			add_location(path72, file$6, 192, 12, 27237);
    			attr(path73, "d", "M120,75.9045226 C143.687188,75.9045226 162.889447,95.1067822 162.889447,118.79397 C162.889447,142.481157 143.687188,161.683417 120,161.683417 C96.3128124,161.683417 77.1105528,142.481157 77.1105528,118.79397 C77.1105528,95.1067822 96.3128124,75.9045226 120,75.9045226 Z");
    			attr(path73, "fill", path73_fill_value = ctx.colors[3]);
    			add_location(path73, file$6, 193, 12, 27556);
    			attr(g34, "id", "Shape");
    			attr(g34, "transform", "translate(0.000000, 0.000000)");
    			add_location(g34, file$6, 189, 10, 26632);
    			attr(g35, "transform", "translate(600.000000, 1081.000000) rotate(-360.000000) translate(-600.000000, -1081.000000) translate(480.000000, 961.000000)");
    			add_location(g35, file$6, 188, 8, 26480);
    			attr(path74, "d", "M120,1.03250741e-14 L240,1.03250741e-14 L240,120 C240,186.27417 186.27417,240 120,240 L-2.84217094e-14,240 L-2.84217094e-14,120 C-2.84217094e-14,53.72583 53.72583,1.03250741e-14 120,1.03250741e-14 Z");
    			attr(path74, "fill", path74_fill_value = ctx.colors[4]);
    			add_location(path74, file$6, 198, 12, 28076);
    			attr(path75, "d", "M120,51.8592965 C158.965216,51.8592965 190.552764,83.4468448 190.552764,122.41206 C190.552764,161.377276 158.965216,192.964824 120,192.964824 L49.4472362,192.964824 L49.4472362,122.41206 C49.4472362,83.4468448 81.0347845,51.8592965 120,51.8592965 Z");
    			attr(path75, "fill", path75_fill_value = ctx.colors[3]);
    			add_location(path75, file$6, 199, 12, 28324);
    			attr(path76, "d", "M192.603015,0 L240.603015,0 L240.603015,48 C240.603015,87.764502 208.367517,120 168.603015,120 L120.603015,120 L120.603015,72 C120.603015,32.235498 152.838513,0 192.603015,0 Z");
    			attr(path76, "fill", path76_fill_value = ctx.colors[6]);
    			add_location(path76, file$6, 200, 12, 28622);
    			attr(g36, "id", "Shape");
    			add_location(g36, file$6, 197, 10, 28049);
    			attr(g37, "transform", "translate(360.600000, 841.000000) rotate(-360.000000) translate(-360.600000, -841.000000) translate(240.000000, 721.000000)");
    			add_location(g37, file$6, 196, 8, 27899);
    			attr(path77, "d", "M120.603015,1.03250741e-14 L240,1.03250741e-14 L240,119.396985 C240,186.004191 186.004191,240 119.396985,240 L-2.84217094e-14,240 L-2.84217094e-14,120.603015 C-2.84217094e-14,53.9958091 53.9958091,1.03250741e-14 120.603015,1.03250741e-14 Z");
    			attr(path77, "fill", path77_fill_value = ctx.colors[4]);
    			add_location(path77, file$6, 205, 12, 29049);
    			attr(path78, "d", "M120,51.8592965 C158.965216,51.8592965 190.552764,83.4468448 190.552764,122.41206 C190.552764,161.377276 158.965216,192.964824 120,192.964824 L49.4472362,192.964824 L49.4472362,122.41206 C49.4472362,83.4468448 81.0347845,51.8592965 120,51.8592965 Z");
    			attr(path78, "fill", path78_fill_value = ctx.colors[3]);
    			add_location(path78, file$6, 206, 12, 29338);
    			attr(path79, "d", "M192.603015,0 L240.603015,0 L240.603015,48 C240.603015,87.764502 208.367517,120 168.603015,120 L120.603015,120 L120.603015,72 C120.603015,32.235498 152.838513,0 192.603015,0 Z");
    			attr(path79, "fill", path79_fill_value = ctx.colors[5]);
    			add_location(path79, file$6, 207, 12, 29636);
    			attr(g38, "id", "Shape");
    			add_location(g38, file$6, 204, 10, 29022);
    			attr(g39, "transform", "translate(840.000000, 1080.400000) rotate(-90.000000) translate(-840.000000, -1080.400000) translate(719.400000, 960.400000)");
    			add_location(g39, file$6, 203, 8, 28871);
    			attr(path80, "d", "M120,1.03250741e-14 C186.27417,1.03250741e-14 240,53.72583 240,120 C240,186.27417 186.27417,240 120,240 L-2.84217094e-14,240 L-2.84217094e-14,120 C-2.84217094e-14,53.72583 53.72583,1.03250741e-14 120,1.03250741e-14 Z");
    			attr(path80, "fill", path80_fill_value = ctx.colors[6]);
    			add_location(path80, file$6, 212, 12, 30062);
    			attr(path81, "d", "M71.758794,96.4824121 C111.390082,96.4824121 143.517588,128.609918 143.517588,168.241206 C143.517588,207.872494 111.390082,240 71.758794,240 L0,240 L0,168.241206 C-4.85343295e-15,128.609918 32.1275064,96.4824121 71.758794,96.4824121 Z");
    			attr(path81, "fill", path81_fill_value = ctx.colors[2]);
    			attr(path81, "transform", "translate(71.758794, 168.241206) rotate(-360.000000) translate(-71.758794, -168.241206) ");
    			add_location(path81, file$6, 213, 12, 30328);
    			attr(path82, "d", "M120,45.5276382 C160.463878,45.5276382 193.266332,78.3300922 193.266332,118.79397 C193.266332,159.257848 160.463878,192.060302 120,192.060302 C79.5361223,192.060302 46.7336683,159.257848 46.7336683,118.79397 C46.7336683,78.3300922 79.5361223,45.5276382 120,45.5276382 Z");
    			attr(path82, "fill", path82_fill_value = ctx.colors[4]);
    			add_location(path82, file$6, 214, 12, 30713);
    			attr(path83, "d", "M120,75.9045226 C143.687188,75.9045226 162.889447,95.1067822 162.889447,118.79397 C162.889447,142.481157 143.687188,161.683417 120,161.683417 C96.3128124,161.683417 77.1105528,142.481157 77.1105528,118.79397 C77.1105528,95.1067822 96.3128124,75.9045226 120,75.9045226 Z");
    			attr(path83, "fill", path83_fill_value = ctx.colors[3]);
    			add_location(path83, file$6, 215, 12, 31032);
    			attr(g40, "id", "Shape");
    			add_location(g40, file$6, 211, 10, 30035);
    			attr(g41, "transform", "translate(840.000000, 601.000000) rotate(-180.000000) translate(-840.000000, -601.000000) translate(720.000000, 481.000000)");
    			add_location(g41, file$6, 210, 8, 29885);
    			attr(ellipse1, "id", "Shape");
    			attr(ellipse1, "fill", ellipse1_fill_value = ctx.colors[6]);
    			attr(ellipse1, "cx", "120.29484");
    			attr(ellipse1, "cy", "119.704433");
    			attr(ellipse1, "rx", "100.835381");
    			attr(ellipse1, "ry", "100.788177");
    			add_location(ellipse1, file$6, 219, 10, 31436);
    			attr(path84, "d", "M240,0 C240,65.9476962 186.670183,119.408867 120.884521,119.408867 C120.884521,53.4611708 174.214337,0 240,0 Z");
    			attr(path84, "id", "Shape");
    			attr(path84, "fill", path84_fill_value = ctx.colors[2]);
    			add_location(path84, file$6, 220, 10, 31559);
    			attr(path85, "d", "M115.784245,0.14669394 L119.262173,0.14669394 L119.262173,3.61607683 C119.262173,67.4856522 67.3581238,119.262173 3.33123423,119.262173 L-0.14669394,119.262173 L-0.14669394,115.79279 C-0.14669394,51.9232148 51.7573553,0.14669394 115.784245,0.14669394 Z");
    			attr(path85, "id", "Shape");
    			attr(path85, "fill", path85_fill_value = ctx.colors[4]);
    			attr(path85, "transform", "translate(59.557740, 59.704433) rotate(-270.000000) translate(-59.557740, -59.704433) ");
    			add_location(path85, file$6, 221, 10, 31728);
    			attr(path86, "d", "M115.646096,120.591133 L119.115479,120.591133 L119.115479,124.069061 C119.115479,188.095951 67.3389582,240 3.46938289,240 L0,240 L0,236.522072 C0,172.495182 51.7765209,120.591133 115.646096,120.591133 Z");
    			attr(path86, "id", "Shape");
    			attr(path86, "fill", path86_fill_value = ctx.colors[2]);
    			add_location(path86, file$6, 222, 10, 32138);
    			attr(path87, "d", "M236.668766,120.737827 L240.146694,120.737827 L240.146694,124.20721 C240.146694,188.076785 188.242645,239.853306 124.215755,239.853306 L120.737827,239.853306 L120.737827,236.383923 C120.737827,172.514348 172.641876,120.737827 236.668766,120.737827 Z");
    			attr(path87, "id", "Shape");
    			attr(path87, "fill", path87_fill_value = ctx.colors[4]);
    			attr(path87, "transform", "translate(180.442260, 180.295567) rotate(-270.000000) translate(-180.442260, -180.295567) ");
    			add_location(path87, file$6, 223, 10, 32399);
    			attr(g42, "transform", "translate(1440.000000, 241.000000)");
    			add_location(g42, file$6, 218, 8, 31375);
    			attr(polygon8, "id", "Shape");
    			attr(polygon8, "fill", polygon8_fill_value = ctx.colors[5]);
    			attr(polygon8, "points", "59.4 5.38236122e-14 180.6 5.38236122e-14 120 60.6");
    			add_location(polygon8, file$6, 226, 10, 32881);
    			attr(polygon9, "id", "Shape");
    			attr(polygon9, "fill", polygon9_fill_value = ctx.colors[4]);
    			attr(polygon9, "points", "240 6.82121026e-13 240 240 0 240");
    			add_location(polygon9, file$6, 227, 10, 33000);
    			attr(polygon10, "id", "Shape");
    			attr(polygon10, "fill", polygon10_fill_value = ctx.colors[6]);
    			attr(polygon10, "points", "0 5.61328761e-13 240 240 0 240");
    			add_location(polygon10, file$6, 228, 10, 33102);
    			attr(g43, "transform", "translate(480.000000, 241.000000)");
    			add_location(g43, file$6, 225, 8, 32821);
    			attr(polygon11, "id", "Shape");
    			attr(polygon11, "fill", polygon11_fill_value = ctx.colors[4]);
    			attr(polygon11, "points", "180.6 240 59.4 240 120 179.4");
    			add_location(polygon11, file$6, 231, 10, 33273);
    			attr(polygon12, "id", "Shape");
    			attr(polygon12, "fill", polygon12_fill_value = ctx.colors[6]);
    			attr(polygon12, "points", "0 240 3.41060513e-14 0 240 0");
    			add_location(polygon12, file$6, 232, 10, 33371);
    			attr(polygon13, "id", "Shape");
    			attr(polygon13, "fill", polygon13_fill_value = ctx.colors[2]);
    			attr(polygon13, "points", "240 240 3.41060513e-14 2.27373675e-13 240 2.27373675e-13");
    			add_location(polygon13, file$6, 233, 10, 33469);
    			attr(g44, "transform", "translate(240.000000, 961.000000)");
    			add_location(g44, file$6, 230, 8, 33213);
    			attr(polygon14, "id", "Shape");
    			attr(polygon14, "fill", polygon14_fill_value = ctx.colors[5]);
    			attr(polygon14, "transform", "translate(120.000000, 209.700000) rotate(-180.000000) translate(-120.000000, -209.700000) ");
    			attr(polygon14, "points", "59.4 179.4 180.6 179.4 120 240");
    			add_location(polygon14, file$6, 236, 10, 33666);
    			attr(polygon15, "id", "Shape");
    			attr(polygon15, "fill", polygon15_fill_value = ctx.colors[4]);
    			attr(polygon15, "transform", "translate(120.000000, 120.000000) rotate(-180.000000) translate(-120.000000, -120.000000) ");
    			attr(polygon15, "points", "240 0 240 240 0 240");
    			add_location(polygon15, file$6, 237, 10, 33869);
    			attr(polygon16, "id", "Shape");
    			attr(polygon16, "fill", polygon16_fill_value = ctx.colors[6]);
    			attr(polygon16, "transform", "translate(120.000000, 120.000000) rotate(-180.000000) translate(-120.000000, -120.000000) ");
    			attr(polygon16, "points", "0 3.33955086e-13 240 240 0 240");
    			add_location(polygon16, file$6, 238, 10, 34061);
    			attr(g45, "transform", "translate(960.600000, 721.000000)");
    			add_location(g45, file$6, 235, 8, 33606);
    			attr(polygon17, "id", "Shape");
    			attr(polygon17, "fill", polygon17_fill_value = ctx.colors[5]);
    			attr(polygon17, "points", "59.4 0 180.6 0 120 60.6");
    			add_location(polygon17, file$6, 241, 10, 34335);
    			attr(polygon18, "id", "Shape");
    			attr(polygon18, "fill", polygon18_fill_value = ctx.colors[4]);
    			attr(polygon18, "points", "240 6.82121026e-13 240 240 0 240");
    			add_location(polygon18, file$6, 242, 10, 34428);
    			attr(polygon19, "id", "Shape");
    			attr(polygon19, "fill", polygon19_fill_value = ctx.colors[6]);
    			attr(polygon19, "points", "0 4.54747351e-13 240 240 0 240");
    			add_location(polygon19, file$6, 243, 10, 34530);
    			attr(g46, "transform", "translate(960.600000, 961.000000)");
    			add_location(g46, file$6, 240, 8, 34275);
    			attr(g47, "transform", "translate(0.000000, -1.000000)");
    			attr(g47, "id", "Module");
    			add_location(g47, file$6, 19, 6, 744);
    			attr(g48, "id", "Linth");
    			attr(g48, "fill-rule", "nonzero");
    			add_location(g48, file$6, 18, 4, 703);
    			attr(g49, "id", "Patterns");
    			attr(g49, "stroke", "none");
    			attr(g49, "stroke-width", "1");
    			attr(g49, "fill", "none");
    			attr(g49, "fill-rule", "evenodd");
    			add_location(g49, file$6, 17, 2, 618);
    			attr(svg, "viewBox", "0 0 1600 1200");
    			attr(svg, "version", "1.1");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr(svg, "style", ctx.styles);
    			add_location(svg, file$6, 10, 0, 228);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, defs);
    			append(defs, linearGradient);
    			append(linearGradient, stop0);
    			append(linearGradient, stop1);
    			append(svg, g49);
    			append(g49, g48);
    			append(g48, g47);
    			append(g47, g0);
    			append(g0, circle0);
    			append(g0, circle1);
    			append(g0, circle2);
    			append(g47, g1);
    			append(g1, circle3);
    			append(g1, circle4);
    			append(g1, circle5);
    			append(g47, g2);
    			append(g2, circle6);
    			append(g2, circle7);
    			append(g2, circle8);
    			append(g47, g3);
    			append(g3, path0);
    			append(g3, path1);
    			append(g3, path2);
    			append(g3, path3);
    			append(g47, g4);
    			append(g4, rect0);
    			append(g4, polygon0);
    			append(g4, path4);
    			append(g4, path5);
    			append(g4, path6);
    			append(g4, path7);
    			append(g47, g6);
    			append(g6, g5);
    			append(g5, polygon1);
    			append(g5, polygon2);
    			append(g47, g8);
    			append(g8, g7);
    			append(g7, path8);
    			append(g7, path9);
    			append(g7, path10);
    			append(g7, path11);
    			append(g47, g10);
    			append(g10, g9);
    			append(g9, path12);
    			append(g9, path13);
    			append(g9, path14);
    			append(g47, g12);
    			append(g12, g11);
    			append(g11, path15);
    			append(g11, path16);
    			append(g11, path17);
    			append(g47, g14);
    			append(g14, g13);
    			append(g13, path18);
    			append(g13, path19);
    			append(g13, path20);
    			append(g13, path21);
    			append(g47, g15);
    			append(g15, ellipse0);
    			append(g15, path22);
    			append(g15, path23);
    			append(g15, path24);
    			append(g15, path25);
    			append(g47, g16);
    			append(g16, circle9);
    			append(g16, path26);
    			append(g16, path27);
    			append(g16, path28);
    			append(g16, path29);
    			append(g47, g17);
    			append(g17, circle10);
    			append(g17, path30);
    			append(g17, path31);
    			append(g17, path32);
    			append(g17, path33);
    			append(g47, g18);
    			append(g18, path34);
    			append(g18, path35);
    			append(g18, path36);
    			append(g47, g19);
    			append(g19, path37);
    			append(g19, path38);
    			append(g19, path39);
    			append(g47, g20);
    			append(g20, path40);
    			append(g20, path41);
    			append(g20, path42);
    			append(g47, g21);
    			append(g21, path43);
    			append(g21, path44);
    			append(g21, path45);
    			append(g47, g22);
    			append(g22, path46);
    			append(g22, path47);
    			append(g22, path48);
    			append(g22, path49);
    			append(g47, g23);
    			append(g23, path50);
    			append(g23, path51);
    			append(g23, path52);
    			append(g23, path53);
    			append(g47, g24);
    			append(g24, path54);
    			append(g24, path55);
    			append(g24, path56);
    			append(g24, path57);
    			append(g47, g25);
    			append(g25, path58);
    			append(g25, path59);
    			append(g25, path60);
    			append(g25, path61);
    			append(g47, g26);
    			append(g26, path62);
    			append(g26, path63);
    			append(g26, path64);
    			append(g26, path65);
    			append(g47, g27);
    			append(g27, rect1);
    			append(g27, polygon3);
    			append(g27, path66);
    			append(g27, path67);
    			append(g27, path68);
    			append(g27, path69);
    			append(g47, g29);
    			append(g29, g28);
    			append(g28, polygon4);
    			append(g28, polygon5);
    			append(g47, g31);
    			append(g31, g30);
    			append(g30, rect2);
    			append(g30, rect3);
    			append(g30, rect4);
    			append(g30, rect5);
    			append(g30, rect6);
    			append(g30, rect7);
    			append(g30, rect8);
    			append(g30, rect9);
    			append(g47, g33);
    			append(g33, g32);
    			append(g32, polygon6);
    			append(g32, polygon7);
    			append(g47, g35);
    			append(g35, g34);
    			append(g34, path70);
    			append(g34, path71);
    			append(g34, path72);
    			append(g34, path73);
    			append(g47, g37);
    			append(g37, g36);
    			append(g36, path74);
    			append(g36, path75);
    			append(g36, path76);
    			append(g47, g39);
    			append(g39, g38);
    			append(g38, path77);
    			append(g38, path78);
    			append(g38, path79);
    			append(g47, g41);
    			append(g41, g40);
    			append(g40, path80);
    			append(g40, path81);
    			append(g40, path82);
    			append(g40, path83);
    			append(g47, g42);
    			append(g42, ellipse1);
    			append(g42, path84);
    			append(g42, path85);
    			append(g42, path86);
    			append(g42, path87);
    			append(g47, g43);
    			append(g43, polygon8);
    			append(g43, polygon9);
    			append(g43, polygon10);
    			append(g47, g44);
    			append(g44, polygon11);
    			append(g44, polygon12);
    			append(g44, polygon13);
    			append(g47, g45);
    			append(g45, polygon14);
    			append(g45, polygon15);
    			append(g45, polygon16);
    			append(g47, g46);
    			append(g46, polygon17);
    			append(g46, polygon18);
    			append(g46, polygon19);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colors) && stop0_stop_color_value !== (stop0_stop_color_value = ctx.colors[0])) {
    				attr(stop0, "stop-color", stop0_stop_color_value);
    			}

    			if ((changed.colors) && stop1_stop_color_value !== (stop1_stop_color_value = ctx.colors[1])) {
    				attr(stop1, "stop-color", stop1_stop_color_value);
    			}

    			if ((changed.colors) && circle0_fill_value !== (circle0_fill_value = ctx.colors[2])) {
    				attr(circle0, "fill", circle0_fill_value);
    			}

    			if ((changed.colors) && circle1_fill_value !== (circle1_fill_value = ctx.colors[3])) {
    				attr(circle1, "fill", circle1_fill_value);
    			}

    			if ((changed.colors) && circle2_fill_value !== (circle2_fill_value = ctx.colors[4])) {
    				attr(circle2, "fill", circle2_fill_value);
    			}

    			if ((changed.colors) && circle3_fill_value !== (circle3_fill_value = ctx.colors[5])) {
    				attr(circle3, "fill", circle3_fill_value);
    			}

    			if ((changed.colors) && circle4_fill_value !== (circle4_fill_value = ctx.colors[3])) {
    				attr(circle4, "fill", circle4_fill_value);
    			}

    			if ((changed.colors) && circle5_fill_value !== (circle5_fill_value = ctx.colors[6])) {
    				attr(circle5, "fill", circle5_fill_value);
    			}

    			if ((changed.colors) && circle6_fill_value !== (circle6_fill_value = ctx.colors[5])) {
    				attr(circle6, "fill", circle6_fill_value);
    			}

    			if ((changed.colors) && circle7_fill_value !== (circle7_fill_value = ctx.colors[3])) {
    				attr(circle7, "fill", circle7_fill_value);
    			}

    			if ((changed.colors) && circle8_fill_value !== (circle8_fill_value = ctx.colors[6])) {
    				attr(circle8, "fill", circle8_fill_value);
    			}

    			if ((changed.colors) && path0_fill_value !== (path0_fill_value = ctx.colors[2])) {
    				attr(path0, "fill", path0_fill_value);
    			}

    			if ((changed.colors) && path1_fill_value !== (path1_fill_value = ctx.colors[5])) {
    				attr(path1, "fill", path1_fill_value);
    			}

    			if ((changed.colors) && path2_fill_value !== (path2_fill_value = ctx.colors[5])) {
    				attr(path2, "fill", path2_fill_value);
    			}

    			if ((changed.colors) && path3_fill_value !== (path3_fill_value = ctx.colors[4])) {
    				attr(path3, "fill", path3_fill_value);
    			}

    			if ((changed.colors) && rect0_fill_value !== (rect0_fill_value = ctx.colors[6])) {
    				attr(rect0, "fill", rect0_fill_value);
    			}

    			if ((changed.colors) && polygon0_fill_value !== (polygon0_fill_value = ctx.colors[4])) {
    				attr(polygon0, "fill", polygon0_fill_value);
    			}

    			if ((changed.colors) && path4_fill_value !== (path4_fill_value = ctx.colors[2])) {
    				attr(path4, "fill", path4_fill_value);
    			}

    			if ((changed.colors) && path5_fill_value !== (path5_fill_value = ctx.colors[2])) {
    				attr(path5, "fill", path5_fill_value);
    			}

    			if ((changed.colors) && path6_fill_value !== (path6_fill_value = ctx.colors[2])) {
    				attr(path6, "fill", path6_fill_value);
    			}

    			if ((changed.colors) && path7_fill_value !== (path7_fill_value = ctx.colors[2])) {
    				attr(path7, "fill", path7_fill_value);
    			}

    			if ((changed.colors) && polygon1_fill_value !== (polygon1_fill_value = ctx.colors[3])) {
    				attr(polygon1, "fill", polygon1_fill_value);
    			}

    			if ((changed.colors) && polygon2_fill_value !== (polygon2_fill_value = ctx.colors[4])) {
    				attr(polygon2, "fill", polygon2_fill_value);
    			}

    			if ((changed.colors) && path8_fill_value !== (path8_fill_value = ctx.colors[6])) {
    				attr(path8, "fill", path8_fill_value);
    			}

    			if ((changed.colors) && path9_fill_value !== (path9_fill_value = ctx.colors[3])) {
    				attr(path9, "fill", path9_fill_value);
    			}

    			if ((changed.colors) && path10_fill_value !== (path10_fill_value = ctx.colors[4])) {
    				attr(path10, "fill", path10_fill_value);
    			}

    			if ((changed.colors) && path11_fill_value !== (path11_fill_value = ctx.colors[3])) {
    				attr(path11, "fill", path11_fill_value);
    			}

    			if ((changed.colors) && path12_fill_value !== (path12_fill_value = ctx.colors[4])) {
    				attr(path12, "fill", path12_fill_value);
    			}

    			if ((changed.colors) && path13_fill_value !== (path13_fill_value = ctx.colors[3])) {
    				attr(path13, "fill", path13_fill_value);
    			}

    			if ((changed.colors) && path14_fill_value !== (path14_fill_value = ctx.colors[5])) {
    				attr(path14, "fill", path14_fill_value);
    			}

    			if ((changed.colors) && path15_fill_value !== (path15_fill_value = ctx.colors[2])) {
    				attr(path15, "fill", path15_fill_value);
    			}

    			if ((changed.colors) && path16_fill_value !== (path16_fill_value = ctx.colors[3])) {
    				attr(path16, "fill", path16_fill_value);
    			}

    			if ((changed.colors) && path17_fill_value !== (path17_fill_value = ctx.colors[5])) {
    				attr(path17, "fill", path17_fill_value);
    			}

    			if ((changed.colors) && path18_fill_value !== (path18_fill_value = ctx.colors[6])) {
    				attr(path18, "fill", path18_fill_value);
    			}

    			if ((changed.colors) && path19_fill_value !== (path19_fill_value = ctx.colors[2])) {
    				attr(path19, "fill", path19_fill_value);
    			}

    			if ((changed.colors) && path20_fill_value !== (path20_fill_value = ctx.colors[4])) {
    				attr(path20, "fill", path20_fill_value);
    			}

    			if ((changed.colors) && path21_fill_value !== (path21_fill_value = ctx.colors[3])) {
    				attr(path21, "fill", path21_fill_value);
    			}

    			if ((changed.colors) && ellipse0_fill_value !== (ellipse0_fill_value = ctx.colors[6])) {
    				attr(ellipse0, "fill", ellipse0_fill_value);
    			}

    			if ((changed.colors) && path22_fill_value !== (path22_fill_value = ctx.colors[2])) {
    				attr(path22, "fill", path22_fill_value);
    			}

    			if ((changed.colors) && path23_fill_value !== (path23_fill_value = ctx.colors[4])) {
    				attr(path23, "fill", path23_fill_value);
    			}

    			if ((changed.colors) && path24_fill_value !== (path24_fill_value = ctx.colors[2])) {
    				attr(path24, "fill", path24_fill_value);
    			}

    			if ((changed.colors) && path25_fill_value !== (path25_fill_value = ctx.colors[4])) {
    				attr(path25, "fill", path25_fill_value);
    			}

    			if ((changed.colors) && circle9_fill_value !== (circle9_fill_value = ctx.colors[6])) {
    				attr(circle9, "fill", circle9_fill_value);
    			}

    			if ((changed.colors) && path26_fill_value !== (path26_fill_value = ctx.colors[2])) {
    				attr(path26, "fill", path26_fill_value);
    			}

    			if ((changed.colors) && path27_fill_value !== (path27_fill_value = ctx.colors[4])) {
    				attr(path27, "fill", path27_fill_value);
    			}

    			if ((changed.colors) && path28_fill_value !== (path28_fill_value = ctx.colors[2])) {
    				attr(path28, "fill", path28_fill_value);
    			}

    			if ((changed.colors) && path29_fill_value !== (path29_fill_value = ctx.colors[4])) {
    				attr(path29, "fill", path29_fill_value);
    			}

    			if ((changed.colors) && circle10_fill_value !== (circle10_fill_value = ctx.colors[6])) {
    				attr(circle10, "fill", circle10_fill_value);
    			}

    			if ((changed.colors) && path30_fill_value !== (path30_fill_value = ctx.colors[2])) {
    				attr(path30, "fill", path30_fill_value);
    			}

    			if ((changed.colors) && path31_fill_value !== (path31_fill_value = ctx.colors[4])) {
    				attr(path31, "fill", path31_fill_value);
    			}

    			if ((changed.colors) && path32_fill_value !== (path32_fill_value = ctx.colors[2])) {
    				attr(path32, "fill", path32_fill_value);
    			}

    			if ((changed.colors) && path33_fill_value !== (path33_fill_value = ctx.colors[4])) {
    				attr(path33, "fill", path33_fill_value);
    			}

    			if ((changed.colors) && path34_fill_value !== (path34_fill_value = ctx.colors[2])) {
    				attr(path34, "fill", path34_fill_value);
    			}

    			if ((changed.colors) && path35_fill_value !== (path35_fill_value = ctx.colors[6])) {
    				attr(path35, "fill", path35_fill_value);
    			}

    			if ((changed.colors) && path36_fill_value !== (path36_fill_value = ctx.colors[3])) {
    				attr(path36, "fill", path36_fill_value);
    			}

    			if ((changed.colors) && path37_fill_value !== (path37_fill_value = ctx.colors[2])) {
    				attr(path37, "fill", path37_fill_value);
    			}

    			if ((changed.colors) && path38_fill_value !== (path38_fill_value = ctx.colors[6])) {
    				attr(path38, "fill", path38_fill_value);
    			}

    			if ((changed.colors) && path39_fill_value !== (path39_fill_value = ctx.colors[3])) {
    				attr(path39, "fill", path39_fill_value);
    			}

    			if ((changed.colors) && path40_fill_value !== (path40_fill_value = ctx.colors[4])) {
    				attr(path40, "fill", path40_fill_value);
    			}

    			if ((changed.colors) && path41_fill_value !== (path41_fill_value = ctx.colors[6])) {
    				attr(path41, "fill", path41_fill_value);
    			}

    			if ((changed.colors) && path42_fill_value !== (path42_fill_value = ctx.colors[3])) {
    				attr(path42, "fill", path42_fill_value);
    			}

    			if ((changed.colors) && path43_fill_value !== (path43_fill_value = ctx.colors[4])) {
    				attr(path43, "fill", path43_fill_value);
    			}

    			if ((changed.colors) && path44_fill_value !== (path44_fill_value = ctx.colors[6])) {
    				attr(path44, "fill", path44_fill_value);
    			}

    			if ((changed.colors) && path45_fill_value !== (path45_fill_value = ctx.colors[3])) {
    				attr(path45, "fill", path45_fill_value);
    			}

    			if ((changed.colors) && path46_fill_value !== (path46_fill_value = ctx.colors[4])) {
    				attr(path46, "fill", path46_fill_value);
    			}

    			if ((changed.colors) && path47_fill_value !== (path47_fill_value = ctx.colors[6])) {
    				attr(path47, "fill", path47_fill_value);
    			}

    			if ((changed.colors) && path48_fill_value !== (path48_fill_value = ctx.colors[3])) {
    				attr(path48, "fill", path48_fill_value);
    			}

    			if ((changed.colors) && path49_fill_value !== (path49_fill_value = ctx.colors[2])) {
    				attr(path49, "fill", path49_fill_value);
    			}

    			if ((changed.colors) && path50_fill_value !== (path50_fill_value = ctx.colors[4])) {
    				attr(path50, "fill", path50_fill_value);
    			}

    			if ((changed.colors) && path51_fill_value !== (path51_fill_value = ctx.colors[6])) {
    				attr(path51, "fill", path51_fill_value);
    			}

    			if ((changed.colors) && path52_fill_value !== (path52_fill_value = ctx.colors[3])) {
    				attr(path52, "fill", path52_fill_value);
    			}

    			if ((changed.colors) && path53_fill_value !== (path53_fill_value = ctx.colors[2])) {
    				attr(path53, "fill", path53_fill_value);
    			}

    			if ((changed.colors) && path54_fill_value !== (path54_fill_value = ctx.colors[5])) {
    				attr(path54, "fill", path54_fill_value);
    			}

    			if ((changed.colors) && path55_fill_value !== (path55_fill_value = ctx.colors[2])) {
    				attr(path55, "fill", path55_fill_value);
    			}

    			if ((changed.colors) && path56_fill_value !== (path56_fill_value = ctx.colors[2])) {
    				attr(path56, "fill", path56_fill_value);
    			}

    			if ((changed.colors) && path57_fill_value !== (path57_fill_value = ctx.colors[4])) {
    				attr(path57, "fill", path57_fill_value);
    			}

    			if ((changed.colors) && path58_fill_value !== (path58_fill_value = ctx.colors[2])) {
    				attr(path58, "fill", path58_fill_value);
    			}

    			if ((changed.colors) && path59_fill_value !== (path59_fill_value = ctx.colors[5])) {
    				attr(path59, "fill", path59_fill_value);
    			}

    			if ((changed.colors) && path60_fill_value !== (path60_fill_value = ctx.colors[5])) {
    				attr(path60, "fill", path60_fill_value);
    			}

    			if ((changed.colors) && path61_fill_value !== (path61_fill_value = ctx.colors[4])) {
    				attr(path61, "fill", path61_fill_value);
    			}

    			if ((changed.colors) && path62_fill_value !== (path62_fill_value = ctx.colors[2])) {
    				attr(path62, "fill", path62_fill_value);
    			}

    			if ((changed.colors) && path63_fill_value !== (path63_fill_value = ctx.colors[5])) {
    				attr(path63, "fill", path63_fill_value);
    			}

    			if ((changed.colors) && path64_fill_value !== (path64_fill_value = ctx.colors[5])) {
    				attr(path64, "fill", path64_fill_value);
    			}

    			if ((changed.colors) && path65_fill_value !== (path65_fill_value = ctx.colors[4])) {
    				attr(path65, "fill", path65_fill_value);
    			}

    			if ((changed.colors) && rect1_fill_value !== (rect1_fill_value = ctx.colors[6])) {
    				attr(rect1, "fill", rect1_fill_value);
    			}

    			if ((changed.colors) && polygon3_fill_value !== (polygon3_fill_value = ctx.colors[4])) {
    				attr(polygon3, "fill", polygon3_fill_value);
    			}

    			if ((changed.colors) && path66_fill_value !== (path66_fill_value = ctx.colors[2])) {
    				attr(path66, "fill", path66_fill_value);
    			}

    			if ((changed.colors) && path67_fill_value !== (path67_fill_value = ctx.colors[2])) {
    				attr(path67, "fill", path67_fill_value);
    			}

    			if ((changed.colors) && path68_fill_value !== (path68_fill_value = ctx.colors[2])) {
    				attr(path68, "fill", path68_fill_value);
    			}

    			if ((changed.colors) && path69_fill_value !== (path69_fill_value = ctx.colors[2])) {
    				attr(path69, "fill", path69_fill_value);
    			}

    			if ((changed.colors) && polygon4_fill_value !== (polygon4_fill_value = ctx.colors[5])) {
    				attr(polygon4, "fill", polygon4_fill_value);
    			}

    			if ((changed.colors) && polygon5_fill_value !== (polygon5_fill_value = ctx.colors[6])) {
    				attr(polygon5, "fill", polygon5_fill_value);
    			}

    			if ((changed.colors) && rect2_fill_value !== (rect2_fill_value = ctx.colors[6])) {
    				attr(rect2, "fill", rect2_fill_value);
    			}

    			if ((changed.colors) && rect3_fill_value !== (rect3_fill_value = ctx.colors[6])) {
    				attr(rect3, "fill", rect3_fill_value);
    			}

    			if ((changed.colors) && rect4_fill_value !== (rect4_fill_value = ctx.colors[6])) {
    				attr(rect4, "fill", rect4_fill_value);
    			}

    			if ((changed.colors) && rect5_fill_value !== (rect5_fill_value = ctx.colors[6])) {
    				attr(rect5, "fill", rect5_fill_value);
    			}

    			if ((changed.colors) && rect6_fill_value !== (rect6_fill_value = ctx.colors[3])) {
    				attr(rect6, "fill", rect6_fill_value);
    			}

    			if ((changed.colors) && rect7_fill_value !== (rect7_fill_value = ctx.colors[3])) {
    				attr(rect7, "fill", rect7_fill_value);
    			}

    			if ((changed.colors) && rect8_fill_value !== (rect8_fill_value = ctx.colors[3])) {
    				attr(rect8, "fill", rect8_fill_value);
    			}

    			if ((changed.colors) && rect9_fill_value !== (rect9_fill_value = ctx.colors[3])) {
    				attr(rect9, "fill", rect9_fill_value);
    			}

    			if ((changed.colors) && polygon6_fill_value !== (polygon6_fill_value = ctx.colors[3])) {
    				attr(polygon6, "fill", polygon6_fill_value);
    			}

    			if ((changed.colors) && polygon7_fill_value !== (polygon7_fill_value = ctx.colors[4])) {
    				attr(polygon7, "fill", polygon7_fill_value);
    			}

    			if ((changed.colors) && path70_fill_value !== (path70_fill_value = ctx.colors[6])) {
    				attr(path70, "fill", path70_fill_value);
    			}

    			if ((changed.colors) && path71_fill_value !== (path71_fill_value = ctx.colors[3])) {
    				attr(path71, "fill", path71_fill_value);
    			}

    			if ((changed.colors) && path72_fill_value !== (path72_fill_value = ctx.colors[4])) {
    				attr(path72, "fill", path72_fill_value);
    			}

    			if ((changed.colors) && path73_fill_value !== (path73_fill_value = ctx.colors[3])) {
    				attr(path73, "fill", path73_fill_value);
    			}

    			if ((changed.colors) && path74_fill_value !== (path74_fill_value = ctx.colors[4])) {
    				attr(path74, "fill", path74_fill_value);
    			}

    			if ((changed.colors) && path75_fill_value !== (path75_fill_value = ctx.colors[3])) {
    				attr(path75, "fill", path75_fill_value);
    			}

    			if ((changed.colors) && path76_fill_value !== (path76_fill_value = ctx.colors[6])) {
    				attr(path76, "fill", path76_fill_value);
    			}

    			if ((changed.colors) && path77_fill_value !== (path77_fill_value = ctx.colors[4])) {
    				attr(path77, "fill", path77_fill_value);
    			}

    			if ((changed.colors) && path78_fill_value !== (path78_fill_value = ctx.colors[3])) {
    				attr(path78, "fill", path78_fill_value);
    			}

    			if ((changed.colors) && path79_fill_value !== (path79_fill_value = ctx.colors[5])) {
    				attr(path79, "fill", path79_fill_value);
    			}

    			if ((changed.colors) && path80_fill_value !== (path80_fill_value = ctx.colors[6])) {
    				attr(path80, "fill", path80_fill_value);
    			}

    			if ((changed.colors) && path81_fill_value !== (path81_fill_value = ctx.colors[2])) {
    				attr(path81, "fill", path81_fill_value);
    			}

    			if ((changed.colors) && path82_fill_value !== (path82_fill_value = ctx.colors[4])) {
    				attr(path82, "fill", path82_fill_value);
    			}

    			if ((changed.colors) && path83_fill_value !== (path83_fill_value = ctx.colors[3])) {
    				attr(path83, "fill", path83_fill_value);
    			}

    			if ((changed.colors) && ellipse1_fill_value !== (ellipse1_fill_value = ctx.colors[6])) {
    				attr(ellipse1, "fill", ellipse1_fill_value);
    			}

    			if ((changed.colors) && path84_fill_value !== (path84_fill_value = ctx.colors[2])) {
    				attr(path84, "fill", path84_fill_value);
    			}

    			if ((changed.colors) && path85_fill_value !== (path85_fill_value = ctx.colors[4])) {
    				attr(path85, "fill", path85_fill_value);
    			}

    			if ((changed.colors) && path86_fill_value !== (path86_fill_value = ctx.colors[2])) {
    				attr(path86, "fill", path86_fill_value);
    			}

    			if ((changed.colors) && path87_fill_value !== (path87_fill_value = ctx.colors[4])) {
    				attr(path87, "fill", path87_fill_value);
    			}

    			if ((changed.colors) && polygon8_fill_value !== (polygon8_fill_value = ctx.colors[5])) {
    				attr(polygon8, "fill", polygon8_fill_value);
    			}

    			if ((changed.colors) && polygon9_fill_value !== (polygon9_fill_value = ctx.colors[4])) {
    				attr(polygon9, "fill", polygon9_fill_value);
    			}

    			if ((changed.colors) && polygon10_fill_value !== (polygon10_fill_value = ctx.colors[6])) {
    				attr(polygon10, "fill", polygon10_fill_value);
    			}

    			if ((changed.colors) && polygon11_fill_value !== (polygon11_fill_value = ctx.colors[4])) {
    				attr(polygon11, "fill", polygon11_fill_value);
    			}

    			if ((changed.colors) && polygon12_fill_value !== (polygon12_fill_value = ctx.colors[6])) {
    				attr(polygon12, "fill", polygon12_fill_value);
    			}

    			if ((changed.colors) && polygon13_fill_value !== (polygon13_fill_value = ctx.colors[2])) {
    				attr(polygon13, "fill", polygon13_fill_value);
    			}

    			if ((changed.colors) && polygon14_fill_value !== (polygon14_fill_value = ctx.colors[5])) {
    				attr(polygon14, "fill", polygon14_fill_value);
    			}

    			if ((changed.colors) && polygon15_fill_value !== (polygon15_fill_value = ctx.colors[4])) {
    				attr(polygon15, "fill", polygon15_fill_value);
    			}

    			if ((changed.colors) && polygon16_fill_value !== (polygon16_fill_value = ctx.colors[6])) {
    				attr(polygon16, "fill", polygon16_fill_value);
    			}

    			if ((changed.colors) && polygon17_fill_value !== (polygon17_fill_value = ctx.colors[5])) {
    				attr(polygon17, "fill", polygon17_fill_value);
    			}

    			if ((changed.colors) && polygon18_fill_value !== (polygon18_fill_value = ctx.colors[4])) {
    				attr(polygon18, "fill", polygon18_fill_value);
    			}

    			if ((changed.colors) && polygon19_fill_value !== (polygon19_fill_value = ctx.colors[6])) {
    				attr(polygon19, "fill", polygon19_fill_value);
    			}

    			if (changed.styles) {
    				attr(svg, "style", ctx.styles);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(svg);
    			}
    		}
    	};
    }

    function instance$6($$self, $$props, $$invalidate) {

      let { colors, styles } = $$props;

    	const writable_props = ['colors', 'styles'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Linth> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('colors' in $$props) $$invalidate('colors', colors = $$props.colors);
    		if ('styles' in $$props) $$invalidate('styles', styles = $$props.styles);
    	};

    	return { colors, styles };
    }

    class Linth extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, ["colors", "styles"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.colors === undefined && !('colors' in props)) {
    			console.warn("<Linth> was created without expected prop 'colors'");
    		}
    		if (ctx.styles === undefined && !('styles' in props)) {
    			console.warn("<Linth> was created without expected prop 'styles'");
    		}
    	}

    	get colors() {
    		throw new Error("<Linth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colors(value) {
    		throw new Error("<Linth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Linth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Linth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;

    function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH = 2;
    /**
     * Used to print values in error messages.
     */

    function inspect(value) {
      return formatValue(value, []);
    }

    function formatValue(value, seenValues) {
      switch (_typeof(value)) {
        case 'string':
          return JSON.stringify(value);

        case 'function':
          return value.name ? "[function ".concat(value.name, "]") : '[function]';

        case 'object':
          if (value === null) {
            return 'null';
          }

          return formatObjectValue(value, seenValues);

        default:
          return String(value);
      }
    }

    function formatObjectValue(value, previouslySeenValues) {
      if (previouslySeenValues.indexOf(value) !== -1) {
        return '[Circular]';
      }

      var seenValues = [].concat(previouslySeenValues, [value]);
      var customInspectFn = getCustomFn(value);

      if (customInspectFn !== undefined) {
        // $FlowFixMe(>=0.90.0)
        var customValue = customInspectFn.call(value); // check for infinite recursion

        if (customValue !== value) {
          return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }

      return formatObject(value, seenValues);
    }

    function formatObject(object, seenValues) {
      var keys = Object.keys(object);

      if (keys.length === 0) {
        return '{}';
      }

      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return '[' + getObjectTag(object) + ']';
      }

      var properties = keys.map(function (key) {
        var value = formatValue(object[key], seenValues);
        return key + ': ' + value;
      });
      return '{ ' + properties.join(', ') + ' }';
    }

    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return '[]';
      }

      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return '[Array]';
      }

      var len = Math.min(MAX_ARRAY_LENGTH, array.length);
      var remaining = array.length - len;
      var items = [];

      for (var i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }

      if (remaining === 1) {
        items.push('... 1 more item');
      } else if (remaining > 1) {
        items.push("... ".concat(remaining, " more items"));
      }

      return '[' + items.join(', ') + ']';
    }

    function getCustomFn(object) {
      var customInspectFn = object[String(nodejsCustomInspectSymbol)];

      if (typeof customInspectFn === 'function') {
        return customInspectFn;
      }

      if (typeof object.inspect === 'function') {
        return object.inspect;
      }
    }

    function getObjectTag(object) {
      var tag = Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/]$/, '');

      if (tag === 'Object' && typeof object.constructor === 'function') {
        var name = object.constructor.name;

        if (typeof name === 'string') {
          return name;
        }
      }

      return tag;
    }

    var QueryDocumentKeys = {
      Name: [],
      Document: ['definitions'],
      OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
      VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
      Variable: ['name'],
      SelectionSet: ['selections'],
      Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
      Argument: ['name', 'value'],
      FragmentSpread: ['name', 'directives'],
      InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
      FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ['values'],
      ObjectValue: ['fields'],
      ObjectField: ['name', 'value'],
      Directive: ['name', 'arguments'],
      NamedType: ['name'],
      ListType: ['type'],
      NonNullType: ['type'],
      SchemaDefinition: ['directives', 'operationTypes'],
      OperationTypeDefinition: ['type'],
      ScalarTypeDefinition: ['description', 'name', 'directives'],
      ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
      FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
      InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
      InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],
      UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
      EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
      EnumValueDefinition: ['description', 'name', 'directives'],
      InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
      DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
      SchemaExtension: ['directives', 'operationTypes'],
      ScalarTypeExtension: ['name', 'directives'],
      ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
      InterfaceTypeExtension: ['name', 'directives', 'fields'],
      UnionTypeExtension: ['name', 'directives', 'types'],
      EnumTypeExtension: ['name', 'directives', 'values'],
      InputObjectTypeExtension: ['name', 'directives', 'fields']
    };
    var BREAK = Object.freeze({});
    /**
     * visit() will walk through an AST using a depth first traversal, calling
     * the visitor's enter function at each node in the traversal, and calling the
     * leave function after visiting that node and all of its child nodes.
     *
     * By returning different values from the enter and leave functions, the
     * behavior of the visitor can be altered, including skipping over a sub-tree of
     * the AST (by returning false), editing the AST by returning a value or null
     * to remove the value, or to stop the whole traversal by returning BREAK.
     *
     * When using visit() to edit an AST, the original AST will not be modified, and
     * a new version of the AST with the changes applied will be returned from the
     * visit function.
     *
     *     const editedAST = visit(ast, {
     *       enter(node, key, parent, path, ancestors) {
     *         // @return
     *         //   undefined: no action
     *         //   false: skip visiting this node
     *         //   visitor.BREAK: stop visiting altogether
     *         //   null: delete this node
     *         //   any value: replace this node with the returned value
     *       },
     *       leave(node, key, parent, path, ancestors) {
     *         // @return
     *         //   undefined: no action
     *         //   false: no action
     *         //   visitor.BREAK: stop visiting altogether
     *         //   null: delete this node
     *         //   any value: replace this node with the returned value
     *       }
     *     });
     *
     * Alternatively to providing enter() and leave() functions, a visitor can
     * instead provide functions named the same as the kinds of AST nodes, or
     * enter/leave visitors at a named key, leading to four permutations of
     * visitor API:
     *
     * 1) Named visitors triggered when entering a node a specific kind.
     *
     *     visit(ast, {
     *       Kind(node) {
     *         // enter the "Kind" node
     *       }
     *     })
     *
     * 2) Named visitors that trigger upon entering and leaving a node of
     *    a specific kind.
     *
     *     visit(ast, {
     *       Kind: {
     *         enter(node) {
     *           // enter the "Kind" node
     *         }
     *         leave(node) {
     *           // leave the "Kind" node
     *         }
     *       }
     *     })
     *
     * 3) Generic visitors that trigger upon entering and leaving any node.
     *
     *     visit(ast, {
     *       enter(node) {
     *         // enter any node
     *       },
     *       leave(node) {
     *         // leave any node
     *       }
     *     })
     *
     * 4) Parallel visitors for entering and leaving nodes of a specific kind.
     *
     *     visit(ast, {
     *       enter: {
     *         Kind(node) {
     *           // enter the "Kind" node
     *         }
     *       },
     *       leave: {
     *         Kind(node) {
     *           // leave the "Kind" node
     *         }
     *       }
     *     })
     */

    function visit(root, visitor) {
      var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;

      /* eslint-disable no-undef-init */
      var stack = undefined;
      var inArray = Array.isArray(root);
      var keys = [root];
      var index = -1;
      var edits = [];
      var node = undefined;
      var key = undefined;
      var parent = undefined;
      var path = [];
      var ancestors = [];
      var newRoot = root;
      /* eslint-enable no-undef-init */

      do {
        index++;
        var isLeaving = index === keys.length;
        var isEdited = isLeaving && edits.length !== 0;

        if (isLeaving) {
          key = ancestors.length === 0 ? undefined : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();

          if (isEdited) {
            if (inArray) {
              node = node.slice();
            } else {
              var clone = {};

              for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
                var k = _Object$keys[_i];
                clone[k] = node[k];
              }

              node = clone;
            }

            var editOffset = 0;

            for (var ii = 0; ii < edits.length; ii++) {
              var editKey = edits[ii][0];
              var editValue = edits[ii][1];

              if (inArray) {
                editKey -= editOffset;
              }

              if (inArray && editValue === null) {
                node.splice(editKey, 1);
                editOffset++;
              } else {
                node[editKey] = editValue;
              }
            }
          }

          index = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else {
          key = parent ? inArray ? index : keys[index] : undefined;
          node = parent ? parent[key] : newRoot;

          if (node === null || node === undefined) {
            continue;
          }

          if (parent) {
            path.push(key);
          }
        }

        var result = void 0;

        if (!Array.isArray(node)) {
          if (!isNode(node)) {
            throw new Error('Invalid AST Node: ' + inspect(node));
          }

          var visitFn = getVisitFn(visitor, node.kind, isLeaving);

          if (visitFn) {
            result = visitFn.call(visitor, node, key, parent, path, ancestors);

            if (result === BREAK) {
              break;
            }

            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== undefined) {
              edits.push([key, result]);

              if (!isLeaving) {
                if (isNode(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
        }

        if (result === undefined && isEdited) {
          edits.push([key, node]);
        }

        if (isLeaving) {
          path.pop();
        } else {
          stack = {
            inArray: inArray,
            index: index,
            keys: keys,
            edits: edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : visitorKeys[node.kind] || [];
          index = -1;
          edits = [];

          if (parent) {
            ancestors.push(parent);
          }

          parent = node;
        }
      } while (stack !== undefined);

      if (edits.length !== 0) {
        newRoot = edits[edits.length - 1][1];
      }

      return newRoot;
    }

    function isNode(maybeNode) {
      return Boolean(maybeNode && typeof maybeNode.kind === 'string');
    }
    /**
     * Given a visitor instance, if it is leaving or not, and a node kind, return
     * the function the visitor runtime should call.
     */

    function getVisitFn(visitor, kind, isLeaving) {
      var kindVisitor = visitor[kind];

      if (kindVisitor) {
        if (!isLeaving && typeof kindVisitor === 'function') {
          // { Kind() {} }
          return kindVisitor;
        }

        var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

        if (typeof kindSpecificVisitor === 'function') {
          // { Kind: { enter() {}, leave() {} } }
          return kindSpecificVisitor;
        }
      } else {
        var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

        if (specificVisitor) {
          if (typeof specificVisitor === 'function') {
            // { enter() {}, leave() {} }
            return specificVisitor;
          }

          var specificKindVisitor = specificVisitor[kind];

          if (typeof specificKindVisitor === 'function') {
            // { enter: { Kind() {} }, leave: { Kind() {} } }
            return specificKindVisitor;
          }
        }
      }
    }

    var genericMessage = "Invariant Violation";
    var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function (obj, proto) {
        obj.__proto__ = proto;
        return obj;
    } : _a;
    var InvariantError = /** @class */ (function (_super) {
        __extends(InvariantError, _super);
        function InvariantError(message) {
            if (message === void 0) { message = genericMessage; }
            var _this = _super.call(this, typeof message === "number"
                ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)"
                : message) || this;
            _this.framesToPop = 1;
            _this.name = genericMessage;
            setPrototypeOf(_this, InvariantError.prototype);
            return _this;
        }
        return InvariantError;
    }(Error));
    function invariant(condition, message) {
        if (!condition) {
            throw new InvariantError(message);
        }
    }
    function wrapConsoleMethod(method) {
        return function () {
            return console[method].apply(console, arguments);
        };
    }
    (function (invariant) {
        invariant.warn = wrapConsoleMethod("warn");
        invariant.error = wrapConsoleMethod("error");
    })(invariant || (invariant = {}));
    // Code that uses ts-invariant with rollup-plugin-invariant may want to
    // import this process stub to avoid errors evaluating process.env.NODE_ENV.
    // However, because most ESM-to-CJS compilers will rewrite the process import
    // as tsInvariant.process, which prevents proper replacement by minifiers, we
    // also attempt to define the stub globally when it is not already defined.
    var processStub = { env: {} };
    if (typeof process === "object") {
        processStub = process;
    }
    else
        try {
            // Using Function to evaluate this assignment in global scope also escapes
            // the strict mode of the current module, thereby allowing the assignment.
            // Inspired by https://github.com/facebook/regenerator/pull/369.
            Function("stub", "process = stub")(processStub);
        }
        catch (atLeastWeTried) {
            // The assignment can fail if a Content Security Policy heavy-handedly
            // forbids Function usage. In those environments, developers should take
            // extra care to replace process.env.NODE_ENV in their production builds,
            // or define an appropriate global.process polyfill.
        }
    //# sourceMappingURL=invariant.esm.js.map

    var fastJsonStableStringify = function (data, opts) {
        if (!opts) opts = {};
        if (typeof opts === 'function') opts = { cmp: opts };
        var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

        var cmp = opts.cmp && (function (f) {
            return function (node) {
                return function (a, b) {
                    var aobj = { key: a, value: node[a] };
                    var bobj = { key: b, value: node[b] };
                    return f(aobj, bobj);
                };
            };
        })(opts.cmp);

        var seen = [];
        return (function stringify (node) {
            if (node && node.toJSON && typeof node.toJSON === 'function') {
                node = node.toJSON();
            }

            if (node === undefined) return;
            if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
            if (typeof node !== 'object') return JSON.stringify(node);

            var i, out;
            if (Array.isArray(node)) {
                out = '[';
                for (i = 0; i < node.length; i++) {
                    if (i) out += ',';
                    out += stringify(node[i]) || 'null';
                }
                return out + ']';
            }

            if (node === null) return 'null';

            if (seen.indexOf(node) !== -1) {
                if (cycles) return JSON.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }

            var seenIndex = seen.push(node) - 1;
            var keys = Object.keys(node).sort(cmp && cmp(node));
            out = '';
            for (i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node[key]);

                if (!value) continue;
                if (out) out += ',';
                out += JSON.stringify(key) + ':' + value;
            }
            seen.splice(seenIndex, 1);
            return '{' + out + '}';
        })(data);
    };

    var _a$1 = Object.prototype, toString = _a$1.toString, hasOwnProperty = _a$1.hasOwnProperty;
    var previousComparisons = new Map();
    /**
     * Performs a deep equality check on two JavaScript values, tolerating cycles.
     */
    function equal(a, b) {
        try {
            return check(a, b);
        }
        finally {
            previousComparisons.clear();
        }
    }
    function check(a, b) {
        // If the two values are strictly equal, our job is easy.
        if (a === b) {
            return true;
        }
        // Object.prototype.toString returns a representation of the runtime type of
        // the given value that is considerably more precise than typeof.
        var aTag = toString.call(a);
        var bTag = toString.call(b);
        // If the runtime types of a and b are different, they could maybe be equal
        // under some interpretation of equality, but for simplicity and performance
        // we just return false instead.
        if (aTag !== bTag) {
            return false;
        }
        switch (aTag) {
            case '[object Array]':
                // Arrays are a lot like other objects, but we can cheaply compare their
                // lengths as a short-cut before comparing their elements.
                if (a.length !== b.length)
                    return false;
            // Fall through to object case...
            case '[object Object]': {
                if (previouslyCompared(a, b))
                    return true;
                var aKeys = Object.keys(a);
                var bKeys = Object.keys(b);
                // If `a` and `b` have a different number of enumerable keys, they
                // must be different.
                var keyCount = aKeys.length;
                if (keyCount !== bKeys.length)
                    return false;
                // Now make sure they have the same keys.
                for (var k = 0; k < keyCount; ++k) {
                    if (!hasOwnProperty.call(b, aKeys[k])) {
                        return false;
                    }
                }
                // Finally, check deep equality of all child properties.
                for (var k = 0; k < keyCount; ++k) {
                    var key = aKeys[k];
                    if (!check(a[key], b[key])) {
                        return false;
                    }
                }
                return true;
            }
            case '[object Error]':
                return a.name === b.name && a.message === b.message;
            case '[object Number]':
                // Handle NaN, which is !== itself.
                if (a !== a)
                    return b !== b;
            // Fall through to shared +a === +b case...
            case '[object Boolean]':
            case '[object Date]':
                return +a === +b;
            case '[object RegExp]':
            case '[object String]':
                return a == "" + b;
            case '[object Map]':
            case '[object Set]': {
                if (a.size !== b.size)
                    return false;
                if (previouslyCompared(a, b))
                    return true;
                var aIterator = a.entries();
                var isMap = aTag === '[object Map]';
                while (true) {
                    var info = aIterator.next();
                    if (info.done)
                        break;
                    // If a instanceof Set, aValue === aKey.
                    var _a = info.value, aKey = _a[0], aValue = _a[1];
                    // So this works the same way for both Set and Map.
                    if (!b.has(aKey)) {
                        return false;
                    }
                    // However, we care about deep equality of values only when dealing
                    // with Map structures.
                    if (isMap && !check(aValue, b.get(aKey))) {
                        return false;
                    }
                }
                return true;
            }
        }
        // Otherwise the values are not equal.
        return false;
    }
    function previouslyCompared(a, b) {
        // Though cyclic references can make an object graph appear infinite from the
        // perspective of a depth-first traversal, the graph still contains a finite
        // number of distinct object references. We use the previousComparisons cache
        // to avoid comparing the same pair of object references more than once, which
        // guarantees termination (even if we end up comparing every object in one
        // graph to every object in the other graph, which is extremely unlikely),
        // while still allowing weird isomorphic structures (like rings with different
        // lengths) a chance to pass the equality test.
        var bSet = previousComparisons.get(a);
        if (bSet) {
            // Return true here because we can be sure false will be returned somewhere
            // else if the objects are not equivalent.
            if (bSet.has(b))
                return true;
        }
        else {
            previousComparisons.set(a, bSet = new Set);
        }
        bSet.add(b);
        return false;
    }
    //# sourceMappingURL=equality.esm.js.map

    function isStringValue(value) {
        return value.kind === 'StringValue';
    }
    function isBooleanValue(value) {
        return value.kind === 'BooleanValue';
    }
    function isIntValue(value) {
        return value.kind === 'IntValue';
    }
    function isFloatValue(value) {
        return value.kind === 'FloatValue';
    }
    function isVariable(value) {
        return value.kind === 'Variable';
    }
    function isObjectValue(value) {
        return value.kind === 'ObjectValue';
    }
    function isListValue(value) {
        return value.kind === 'ListValue';
    }
    function isEnumValue(value) {
        return value.kind === 'EnumValue';
    }
    function isNullValue(value) {
        return value.kind === 'NullValue';
    }
    function valueToObjectRepresentation(argObj, name, value, variables) {
        if (isIntValue(value) || isFloatValue(value)) {
            argObj[name.value] = Number(value.value);
        }
        else if (isBooleanValue(value) || isStringValue(value)) {
            argObj[name.value] = value.value;
        }
        else if (isObjectValue(value)) {
            var nestedArgObj_1 = {};
            value.fields.map(function (obj) {
                return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
            });
            argObj[name.value] = nestedArgObj_1;
        }
        else if (isVariable(value)) {
            var variableValue = (variables || {})[value.name.value];
            argObj[name.value] = variableValue;
        }
        else if (isListValue(value)) {
            argObj[name.value] = value.values.map(function (listValue) {
                var nestedArgArrayObj = {};
                valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
                return nestedArgArrayObj[name.value];
            });
        }
        else if (isEnumValue(value)) {
            argObj[name.value] = value.value;
        }
        else if (isNullValue(value)) {
            argObj[name.value] = null;
        }
        else {
            throw process.env.NODE_ENV === "production" ? new InvariantError(17) : new InvariantError("The inline argument \"" + name.value + "\" of kind \"" + value.kind + "\"" +
                'is not supported. Use variables instead of inline arguments to ' +
                'overcome this limitation.');
        }
    }
    function storeKeyNameFromField(field, variables) {
        var directivesObj = null;
        if (field.directives) {
            directivesObj = {};
            field.directives.forEach(function (directive) {
                directivesObj[directive.name.value] = {};
                if (directive.arguments) {
                    directive.arguments.forEach(function (_a) {
                        var name = _a.name, value = _a.value;
                        return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                    });
                }
            });
        }
        var argObj = null;
        if (field.arguments && field.arguments.length) {
            argObj = {};
            field.arguments.forEach(function (_a) {
                var name = _a.name, value = _a.value;
                return valueToObjectRepresentation(argObj, name, value, variables);
            });
        }
        return getStoreKeyName(field.name.value, argObj, directivesObj);
    }
    var KNOWN_DIRECTIVES = [
        'connection',
        'include',
        'skip',
        'client',
        'rest',
        'export',
    ];
    function getStoreKeyName(fieldName, args, directives) {
        if (directives &&
            directives['connection'] &&
            directives['connection']['key']) {
            if (directives['connection']['filter'] &&
                directives['connection']['filter'].length > 0) {
                var filterKeys = directives['connection']['filter']
                    ? directives['connection']['filter']
                    : [];
                filterKeys.sort();
                var queryArgs_1 = args;
                var filteredArgs_1 = {};
                filterKeys.forEach(function (key) {
                    filteredArgs_1[key] = queryArgs_1[key];
                });
                return directives['connection']['key'] + "(" + JSON.stringify(filteredArgs_1) + ")";
            }
            else {
                return directives['connection']['key'];
            }
        }
        var completeFieldName = fieldName;
        if (args) {
            var stringifiedArgs = fastJsonStableStringify(args);
            completeFieldName += "(" + stringifiedArgs + ")";
        }
        if (directives) {
            Object.keys(directives).forEach(function (key) {
                if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
                    return;
                if (directives[key] && Object.keys(directives[key]).length) {
                    completeFieldName += "@" + key + "(" + JSON.stringify(directives[key]) + ")";
                }
                else {
                    completeFieldName += "@" + key;
                }
            });
        }
        return completeFieldName;
    }
    function argumentsObjectFromField(field, variables) {
        if (field.arguments && field.arguments.length) {
            var argObj_1 = {};
            field.arguments.forEach(function (_a) {
                var name = _a.name, value = _a.value;
                return valueToObjectRepresentation(argObj_1, name, value, variables);
            });
            return argObj_1;
        }
        return null;
    }
    function resultKeyNameFromField(field) {
        return field.alias ? field.alias.value : field.name.value;
    }
    function isField(selection) {
        return selection.kind === 'Field';
    }
    function isInlineFragment(selection) {
        return selection.kind === 'InlineFragment';
    }
    function isIdValue(idObject) {
        return idObject &&
            idObject.type === 'id' &&
            typeof idObject.generated === 'boolean';
    }
    function toIdValue(idConfig, generated) {
        if (generated === void 0) { generated = false; }
        return __assign({ type: 'id', generated: generated }, (typeof idConfig === 'string'
            ? { id: idConfig, typename: undefined }
            : idConfig));
    }
    function isJsonValue(jsonObject) {
        return (jsonObject != null &&
            typeof jsonObject === 'object' &&
            jsonObject.type === 'json');
    }

    function getDirectiveInfoFromField(field, variables) {
        if (field.directives && field.directives.length) {
            var directiveObj_1 = {};
            field.directives.forEach(function (directive) {
                directiveObj_1[directive.name.value] = argumentsObjectFromField(directive, variables);
            });
            return directiveObj_1;
        }
        return null;
    }
    function shouldInclude(selection, variables) {
        if (variables === void 0) { variables = {}; }
        return getInclusionDirectives(selection.directives).every(function (_a) {
            var directive = _a.directive, ifArgument = _a.ifArgument;
            var evaledValue = false;
            if (ifArgument.value.kind === 'Variable') {
                evaledValue = variables[ifArgument.value.name.value];
                process.env.NODE_ENV === "production" ? invariant(evaledValue !== void 0, 3) : invariant(evaledValue !== void 0, "Invalid variable referenced in @" + directive.name.value + " directive.");
            }
            else {
                evaledValue = ifArgument.value.value;
            }
            return directive.name.value === 'skip' ? !evaledValue : evaledValue;
        });
    }
    function getDirectiveNames(doc) {
        var names = [];
        visit(doc, {
            Directive: function (node) {
                names.push(node.name.value);
            },
        });
        return names;
    }
    function hasDirectives(names, doc) {
        return getDirectiveNames(doc).some(function (name) { return names.indexOf(name) > -1; });
    }
    function hasClientExports(document) {
        return (document &&
            hasDirectives(['client'], document) &&
            hasDirectives(['export'], document));
    }
    function isInclusionDirective(_a) {
        var value = _a.name.value;
        return value === 'skip' || value === 'include';
    }
    function getInclusionDirectives(directives) {
        return directives ? directives.filter(isInclusionDirective).map(function (directive) {
            var directiveArguments = directive.arguments;
            var directiveName = directive.name.value;
            process.env.NODE_ENV === "production" ? invariant(directiveArguments && directiveArguments.length === 1, 4) : invariant(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @" + directiveName + " directive.");
            var ifArgument = directiveArguments[0];
            process.env.NODE_ENV === "production" ? invariant(ifArgument.name && ifArgument.name.value === 'if', 5) : invariant(ifArgument.name && ifArgument.name.value === 'if', "Invalid argument for the @" + directiveName + " directive.");
            var ifValue = ifArgument.value;
            process.env.NODE_ENV === "production" ? invariant(ifValue &&
                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 6) : invariant(ifValue &&
                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), "Argument for the @" + directiveName + " directive must be a variable or a boolean value.");
            return { directive: directive, ifArgument: ifArgument };
        }) : [];
    }

    function getFragmentQueryDocument(document, fragmentName) {
        var actualFragmentName = fragmentName;
        var fragments = [];
        document.definitions.forEach(function (definition) {
            if (definition.kind === 'OperationDefinition') {
                throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : '') + ". " +
                    'No operations are allowed when using a fragment as a query. Only fragments are allowed.');
            }
            if (definition.kind === 'FragmentDefinition') {
                fragments.push(definition);
            }
        });
        if (typeof actualFragmentName === 'undefined') {
            process.env.NODE_ENV === "production" ? invariant(fragments.length === 1, 2) : invariant(fragments.length === 1, "Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.");
            actualFragmentName = fragments[0].name.value;
        }
        var query = __assign({}, document, { definitions: [
                {
                    kind: 'OperationDefinition',
                    operation: 'query',
                    selectionSet: {
                        kind: 'SelectionSet',
                        selections: [
                            {
                                kind: 'FragmentSpread',
                                name: {
                                    kind: 'Name',
                                    value: actualFragmentName,
                                },
                            },
                        ],
                    },
                }
            ].concat(document.definitions) });
        return query;
    }

    function assign$1(target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) {
            if (typeof source === 'undefined' || source === null) {
                return;
            }
            Object.keys(source).forEach(function (key) {
                target[key] = source[key];
            });
        });
        return target;
    }
    function checkDocument(doc) {
        process.env.NODE_ENV === "production" ? invariant(doc && doc.kind === 'Document', 8) : invariant(doc && doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
        var operations = doc.definitions
            .filter(function (d) { return d.kind !== 'FragmentDefinition'; })
            .map(function (definition) {
            if (definition.kind !== 'OperationDefinition') {
                throw process.env.NODE_ENV === "production" ? new InvariantError(9) : new InvariantError("Schema type definitions not allowed in queries. Found: \"" + definition.kind + "\"");
            }
            return definition;
        });
        process.env.NODE_ENV === "production" ? invariant(operations.length <= 1, 10) : invariant(operations.length <= 1, "Ambiguous GraphQL document: contains " + operations.length + " operations");
        return doc;
    }
    function getOperationDefinition(doc) {
        checkDocument(doc);
        return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];
    }
    function getOperationName(doc) {
        return (doc.definitions
            .filter(function (definition) {
            return definition.kind === 'OperationDefinition' && definition.name;
        })
            .map(function (x) { return x.name.value; })[0] || null);
    }
    function getFragmentDefinitions(doc) {
        return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });
    }
    function getQueryDefinition(doc) {
        var queryDef = getOperationDefinition(doc);
        process.env.NODE_ENV === "production" ? invariant(queryDef && queryDef.operation === 'query', 12) : invariant(queryDef && queryDef.operation === 'query', 'Must contain a query definition.');
        return queryDef;
    }
    function getFragmentDefinition(doc) {
        process.env.NODE_ENV === "production" ? invariant(doc.kind === 'Document', 13) : invariant(doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
        process.env.NODE_ENV === "production" ? invariant(doc.definitions.length <= 1, 14) : invariant(doc.definitions.length <= 1, 'Fragment must have exactly one definition.');
        var fragmentDef = doc.definitions[0];
        process.env.NODE_ENV === "production" ? invariant(fragmentDef.kind === 'FragmentDefinition', 15) : invariant(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.');
        return fragmentDef;
    }
    function getMainDefinition(queryDoc) {
        checkDocument(queryDoc);
        var fragmentDefinition;
        for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            if (definition.kind === 'OperationDefinition') {
                var operation = definition.operation;
                if (operation === 'query' ||
                    operation === 'mutation' ||
                    operation === 'subscription') {
                    return definition;
                }
            }
            if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
                fragmentDefinition = definition;
            }
        }
        if (fragmentDefinition) {
            return fragmentDefinition;
        }
        throw process.env.NODE_ENV === "production" ? new InvariantError(16) : new InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');
    }
    function createFragmentMap(fragments) {
        if (fragments === void 0) { fragments = []; }
        var symTable = {};
        fragments.forEach(function (fragment) {
            symTable[fragment.name.value] = fragment;
        });
        return symTable;
    }
    function getDefaultValues(definition) {
        if (definition &&
            definition.variableDefinitions &&
            definition.variableDefinitions.length) {
            var defaultValues = definition.variableDefinitions
                .filter(function (_a) {
                var defaultValue = _a.defaultValue;
                return defaultValue;
            })
                .map(function (_a) {
                var variable = _a.variable, defaultValue = _a.defaultValue;
                var defaultValueObj = {};
                valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);
                return defaultValueObj;
            });
            return assign$1.apply(void 0, [{}].concat(defaultValues));
        }
        return {};
    }

    function filterInPlace(array, test, context) {
        var target = 0;
        array.forEach(function (elem, i) {
            if (test.call(this, elem, i, array)) {
                array[target++] = elem;
            }
        }, context);
        array.length = target;
        return array;
    }

    var TYPENAME_FIELD = {
        kind: 'Field',
        name: {
            kind: 'Name',
            value: '__typename',
        },
    };
    function isEmpty(op, fragments) {
        return op.selectionSet.selections.every(function (selection) {
            return selection.kind === 'FragmentSpread' &&
                isEmpty(fragments[selection.name.value], fragments);
        });
    }
    function nullIfDocIsEmpty(doc) {
        return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))
            ? null
            : doc;
    }
    function getDirectiveMatcher(directives) {
        return function directiveMatcher(directive) {
            return directives.some(function (dir) {
                return (dir.name && dir.name === directive.name.value) ||
                    (dir.test && dir.test(directive));
            });
        };
    }
    function removeDirectivesFromDocument(directives, doc) {
        var variablesInUse = Object.create(null);
        var variablesToRemove = [];
        var fragmentSpreadsInUse = Object.create(null);
        var fragmentSpreadsToRemove = [];
        var modifiedDoc = nullIfDocIsEmpty(visit(doc, {
            Variable: {
                enter: function (node, _key, parent) {
                    if (parent.kind !== 'VariableDefinition') {
                        variablesInUse[node.name.value] = true;
                    }
                },
            },
            Field: {
                enter: function (node) {
                    if (directives && node.directives) {
                        var shouldRemoveField = directives.some(function (directive) { return directive.remove; });
                        if (shouldRemoveField &&
                            node.directives &&
                            node.directives.some(getDirectiveMatcher(directives))) {
                            if (node.arguments) {
                                node.arguments.forEach(function (arg) {
                                    if (arg.value.kind === 'Variable') {
                                        variablesToRemove.push({
                                            name: arg.value.name.value,
                                        });
                                    }
                                });
                            }
                            if (node.selectionSet) {
                                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {
                                    fragmentSpreadsToRemove.push({
                                        name: frag.name.value,
                                    });
                                });
                            }
                            return null;
                        }
                    }
                },
            },
            FragmentSpread: {
                enter: function (node) {
                    fragmentSpreadsInUse[node.name.value] = true;
                },
            },
            Directive: {
                enter: function (node) {
                    if (getDirectiveMatcher(directives)(node)) {
                        return null;
                    }
                },
            },
        }));
        if (modifiedDoc &&
            filterInPlace(variablesToRemove, function (v) { return !variablesInUse[v.name]; }).length) {
            modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
        }
        if (modifiedDoc &&
            filterInPlace(fragmentSpreadsToRemove, function (fs) { return !fragmentSpreadsInUse[fs.name]; })
                .length) {
            modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
        }
        return modifiedDoc;
    }
    function addTypenameToDocument(doc) {
        return visit(checkDocument(doc), {
            SelectionSet: {
                enter: function (node, _key, parent) {
                    if (parent &&
                        parent.kind === 'OperationDefinition') {
                        return;
                    }
                    var selections = node.selections;
                    if (!selections) {
                        return;
                    }
                    var skip = selections.some(function (selection) {
                        return (isField(selection) &&
                            (selection.name.value === '__typename' ||
                                selection.name.value.lastIndexOf('__', 0) === 0));
                    });
                    if (skip) {
                        return;
                    }
                    var field = parent;
                    if (isField(field) &&
                        field.directives &&
                        field.directives.some(function (d) { return d.name.value === 'export'; })) {
                        return;
                    }
                    return __assign({}, node, { selections: selections.concat([TYPENAME_FIELD]) });
                },
            },
        });
    }
    var connectionRemoveConfig = {
        test: function (directive) {
            var willRemove = directive.name.value === 'connection';
            if (willRemove) {
                if (!directive.arguments ||
                    !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {
                    process.env.NODE_ENV === "production" || invariant.warn('Removing an @connection directive even though it does not have a key. ' +
                        'You may want to use the key parameter to specify a store key.');
                }
            }
            return willRemove;
        },
    };
    function removeConnectionDirectiveFromDocument(doc) {
        return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
    }
    function getArgumentMatcher(config) {
        return function argumentMatcher(argument) {
            return config.some(function (aConfig) {
                return argument.value &&
                    argument.value.kind === 'Variable' &&
                    argument.value.name &&
                    (aConfig.name === argument.value.name.value ||
                        (aConfig.test && aConfig.test(argument)));
            });
        };
    }
    function removeArgumentsFromDocument(config, doc) {
        var argMatcher = getArgumentMatcher(config);
        return nullIfDocIsEmpty(visit(doc, {
            OperationDefinition: {
                enter: function (node) {
                    return __assign({}, node, { variableDefinitions: node.variableDefinitions.filter(function (varDef) {
                            return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });
                        }) });
                },
            },
            Field: {
                enter: function (node) {
                    var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });
                    if (shouldRemoveField) {
                        var argMatchCount_1 = 0;
                        node.arguments.forEach(function (arg) {
                            if (argMatcher(arg)) {
                                argMatchCount_1 += 1;
                            }
                        });
                        if (argMatchCount_1 === 1) {
                            return null;
                        }
                    }
                },
            },
            Argument: {
                enter: function (node) {
                    if (argMatcher(node)) {
                        return null;
                    }
                },
            },
        }));
    }
    function removeFragmentSpreadFromDocument(config, doc) {
        function enter(node) {
            if (config.some(function (def) { return def.name === node.name.value; })) {
                return null;
            }
        }
        return nullIfDocIsEmpty(visit(doc, {
            FragmentSpread: { enter: enter },
            FragmentDefinition: { enter: enter },
        }));
    }
    function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
        var allFragments = [];
        selectionSet.selections.forEach(function (selection) {
            if ((isField(selection) || isInlineFragment(selection)) &&
                selection.selectionSet) {
                getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) { return allFragments.push(frag); });
            }
            else if (selection.kind === 'FragmentSpread') {
                allFragments.push(selection);
            }
        });
        return allFragments;
    }
    function buildQueryFromSelectionSet(document) {
        var definition = getMainDefinition(document);
        var definitionOperation = definition.operation;
        if (definitionOperation === 'query') {
            return document;
        }
        var modifiedDoc = visit(document, {
            OperationDefinition: {
                enter: function (node) {
                    return __assign({}, node, { operation: 'query' });
                },
            },
        });
        return modifiedDoc;
    }
    function removeClientSetsFromDocument(document) {
        checkDocument(document);
        var modifiedDoc = removeDirectivesFromDocument([
            {
                test: function (directive) { return directive.name.value === 'client'; },
                remove: true,
            },
        ], document);
        if (modifiedDoc) {
            modifiedDoc = visit(modifiedDoc, {
                FragmentDefinition: {
                    enter: function (node) {
                        if (node.selectionSet) {
                            var isTypenameOnly = node.selectionSet.selections.every(function (selection) {
                                return isField(selection) && selection.name.value === '__typename';
                            });
                            if (isTypenameOnly) {
                                return null;
                            }
                        }
                    },
                },
            });
        }
        return modifiedDoc;
    }

    var canUseWeakMap = typeof WeakMap === 'function' && !(typeof navigator === 'object' &&
        navigator.product === 'ReactNative');

    var toString$1 = Object.prototype.toString;
    function cloneDeep(value) {
        return cloneDeepHelper(value, new Map());
    }
    function cloneDeepHelper(val, seen) {
        switch (toString$1.call(val)) {
            case "[object Array]": {
                if (seen.has(val))
                    return seen.get(val);
                var copy_1 = val.slice(0);
                seen.set(val, copy_1);
                copy_1.forEach(function (child, i) {
                    copy_1[i] = cloneDeepHelper(child, seen);
                });
                return copy_1;
            }
            case "[object Object]": {
                if (seen.has(val))
                    return seen.get(val);
                var copy_2 = Object.create(Object.getPrototypeOf(val));
                seen.set(val, copy_2);
                Object.keys(val).forEach(function (key) {
                    copy_2[key] = cloneDeepHelper(val[key], seen);
                });
                return copy_2;
            }
            default:
                return val;
        }
    }

    function getEnv() {
        if (typeof process !== 'undefined' && process.env.NODE_ENV) {
            return process.env.NODE_ENV;
        }
        return 'development';
    }
    function isEnv(env) {
        return getEnv() === env;
    }
    function isProduction() {
        return isEnv('production') === true;
    }
    function isDevelopment() {
        return isEnv('development') === true;
    }
    function isTest() {
        return isEnv('test') === true;
    }

    function tryFunctionOrLogError(f) {
        try {
            return f();
        }
        catch (e) {
            if (console.error) {
                console.error(e);
            }
        }
    }
    function graphQLResultHasError(result) {
        return result.errors && result.errors.length;
    }

    function deepFreeze(o) {
        Object.freeze(o);
        Object.getOwnPropertyNames(o).forEach(function (prop) {
            if (o[prop] !== null &&
                (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
                !Object.isFrozen(o[prop])) {
                deepFreeze(o[prop]);
            }
        });
        return o;
    }
    function maybeDeepFreeze(obj) {
        if (isDevelopment() || isTest()) {
            var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';
            if (!symbolIsPolyfilled) {
                return deepFreeze(obj);
            }
        }
        return obj;
    }

    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    function mergeDeep() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        return mergeDeepArray(sources);
    }
    function mergeDeepArray(sources) {
        var target = sources[0] || {};
        var count = sources.length;
        if (count > 1) {
            var pastCopies = [];
            target = shallowCopyForMerge(target, pastCopies);
            for (var i = 1; i < count; ++i) {
                target = mergeHelper(target, sources[i], pastCopies);
            }
        }
        return target;
    }
    function isObject(obj) {
        return obj !== null && typeof obj === 'object';
    }
    function mergeHelper(target, source, pastCopies) {
        if (isObject(source) && isObject(target)) {
            if (Object.isExtensible && !Object.isExtensible(target)) {
                target = shallowCopyForMerge(target, pastCopies);
            }
            Object.keys(source).forEach(function (sourceKey) {
                var sourceValue = source[sourceKey];
                if (hasOwnProperty$1.call(target, sourceKey)) {
                    var targetValue = target[sourceKey];
                    if (sourceValue !== targetValue) {
                        target[sourceKey] = mergeHelper(shallowCopyForMerge(targetValue, pastCopies), sourceValue, pastCopies);
                    }
                }
                else {
                    target[sourceKey] = sourceValue;
                }
            });
            return target;
        }
        return source;
    }
    function shallowCopyForMerge(value, pastCopies) {
        if (value !== null &&
            typeof value === 'object' &&
            pastCopies.indexOf(value) < 0) {
            if (Array.isArray(value)) {
                value = value.slice(0);
            }
            else {
                value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
            }
            pastCopies.push(value);
        }
        return value;
    }
    //# sourceMappingURL=bundle.esm.js.map

    var Observable_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    // === Symbol Support ===

    var hasSymbols = function () {
      return typeof Symbol === 'function';
    };
    var hasSymbol = function (name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };
    var getSymbol = function (name) {
      return hasSymbol(name) ? Symbol[name] : '@@' + name;
    };

    if (hasSymbols() && !hasSymbol('observable')) {
      Symbol.observable = Symbol('observable');
    }

    var SymbolIterator = getSymbol('iterator');
    var SymbolObservable = getSymbol('observable');
    var SymbolSpecies = getSymbol('species');

    // === Abstract Operations ===

    function getMethod(obj, key) {
      var value = obj[key];

      if (value == null) return undefined;

      if (typeof value !== 'function') throw new TypeError(value + ' is not a function');

      return value;
    }

    function getSpecies(obj) {
      var ctor = obj.constructor;
      if (ctor !== undefined) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) {
          ctor = undefined;
        }
      }
      return ctor !== undefined ? ctor : Observable;
    }

    function isObservable(x) {
      return x instanceof Observable; // SPEC: Brand check
    }

    function hostReportError(e) {
      if (hostReportError.log) {
        hostReportError.log(e);
      } else {
        setTimeout(function () {
          throw e;
        });
      }
    }

    function enqueue(fn) {
      Promise.resolve().then(function () {
        try {
          fn();
        } catch (e) {
          hostReportError(e);
        }
      });
    }

    function cleanupSubscription(subscription) {
      var cleanup = subscription._cleanup;
      if (cleanup === undefined) return;

      subscription._cleanup = undefined;

      if (!cleanup) {
        return;
      }

      try {
        if (typeof cleanup === 'function') {
          cleanup();
        } else {
          var unsubscribe = getMethod(cleanup, 'unsubscribe');
          if (unsubscribe) {
            unsubscribe.call(cleanup);
          }
        }
      } catch (e) {
        hostReportError(e);
      }
    }

    function closeSubscription(subscription) {
      subscription._observer = undefined;
      subscription._queue = undefined;
      subscription._state = 'closed';
    }

    function flushSubscription(subscription) {
      var queue = subscription._queue;
      if (!queue) {
        return;
      }
      subscription._queue = undefined;
      subscription._state = 'ready';
      for (var i = 0; i < queue.length; ++i) {
        notifySubscription(subscription, queue[i].type, queue[i].value);
        if (subscription._state === 'closed') break;
      }
    }

    function notifySubscription(subscription, type, value) {
      subscription._state = 'running';

      var observer = subscription._observer;

      try {
        var m = getMethod(observer, type);
        switch (type) {
          case 'next':
            if (m) m.call(observer, value);
            break;
          case 'error':
            closeSubscription(subscription);
            if (m) m.call(observer, value);else throw value;
            break;
          case 'complete':
            closeSubscription(subscription);
            if (m) m.call(observer);
            break;
        }
      } catch (e) {
        hostReportError(e);
      }

      if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
    }

    function onNotify(subscription, type, value) {
      if (subscription._state === 'closed') return;

      if (subscription._state === 'buffering') {
        subscription._queue.push({ type: type, value: value });
        return;
      }

      if (subscription._state !== 'ready') {
        subscription._state = 'buffering';
        subscription._queue = [{ type: type, value: value }];
        enqueue(function () {
          return flushSubscription(subscription);
        });
        return;
      }

      notifySubscription(subscription, type, value);
    }

    var Subscription = function () {
      function Subscription(observer, subscriber) {
        _classCallCheck(this, Subscription);

        // ASSERT: observer is an object
        // ASSERT: subscriber is callable

        this._cleanup = undefined;
        this._observer = observer;
        this._queue = undefined;
        this._state = 'initializing';

        var subscriptionObserver = new SubscriptionObserver(this);

        try {
          this._cleanup = subscriber.call(undefined, subscriptionObserver);
        } catch (e) {
          subscriptionObserver.error(e);
        }

        if (this._state === 'initializing') this._state = 'ready';
      }

      _createClass(Subscription, [{
        key: 'unsubscribe',
        value: function unsubscribe() {
          if (this._state !== 'closed') {
            closeSubscription(this);
            cleanupSubscription(this);
          }
        }
      }, {
        key: 'closed',
        get: function () {
          return this._state === 'closed';
        }
      }]);

      return Subscription;
    }();

    var SubscriptionObserver = function () {
      function SubscriptionObserver(subscription) {
        _classCallCheck(this, SubscriptionObserver);

        this._subscription = subscription;
      }

      _createClass(SubscriptionObserver, [{
        key: 'next',
        value: function next(value) {
          onNotify(this._subscription, 'next', value);
        }
      }, {
        key: 'error',
        value: function error(value) {
          onNotify(this._subscription, 'error', value);
        }
      }, {
        key: 'complete',
        value: function complete() {
          onNotify(this._subscription, 'complete');
        }
      }, {
        key: 'closed',
        get: function () {
          return this._subscription._state === 'closed';
        }
      }]);

      return SubscriptionObserver;
    }();

    var Observable = exports.Observable = function () {
      function Observable(subscriber) {
        _classCallCheck(this, Observable);

        if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');

        if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');

        this._subscriber = subscriber;
      }

      _createClass(Observable, [{
        key: 'subscribe',
        value: function subscribe(observer) {
          if (typeof observer !== 'object' || observer === null) {
            observer = {
              next: observer,
              error: arguments[1],
              complete: arguments[2]
            };
          }
          return new Subscription(observer, this._subscriber);
        }
      }, {
        key: 'forEach',
        value: function forEach(fn) {
          var _this = this;

          return new Promise(function (resolve, reject) {
            if (typeof fn !== 'function') {
              reject(new TypeError(fn + ' is not a function'));
              return;
            }

            function done() {
              subscription.unsubscribe();
              resolve();
            }

            var subscription = _this.subscribe({
              next: function (value) {
                try {
                  fn(value, done);
                } catch (e) {
                  reject(e);
                  subscription.unsubscribe();
                }
              },

              error: reject,
              complete: resolve
            });
          });
        }
      }, {
        key: 'map',
        value: function map(fn) {
          var _this2 = this;

          if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

          var C = getSpecies(this);

          return new C(function (observer) {
            return _this2.subscribe({
              next: function (value) {
                try {
                  value = fn(value);
                } catch (e) {
                  return observer.error(e);
                }
                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: 'filter',
        value: function filter(fn) {
          var _this3 = this;

          if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

          var C = getSpecies(this);

          return new C(function (observer) {
            return _this3.subscribe({
              next: function (value) {
                try {
                  if (!fn(value)) return;
                } catch (e) {
                  return observer.error(e);
                }
                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: 'reduce',
        value: function reduce(fn) {
          var _this4 = this;

          if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

          var C = getSpecies(this);
          var hasSeed = arguments.length > 1;
          var hasValue = false;
          var seed = arguments[1];
          var acc = seed;

          return new C(function (observer) {
            return _this4.subscribe({
              next: function (value) {
                var first = !hasValue;
                hasValue = true;

                if (!first || hasSeed) {
                  try {
                    acc = fn(acc, value);
                  } catch (e) {
                    return observer.error(e);
                  }
                } else {
                  acc = value;
                }
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));

                observer.next(acc);
                observer.complete();
              }
            });
          });
        }
      }, {
        key: 'concat',
        value: function concat() {
          var _this5 = this;

          for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }

          var C = getSpecies(this);

          return new C(function (observer) {
            var subscription = void 0;
            var index = 0;

            function startNext(next) {
              subscription = next.subscribe({
                next: function (v) {
                  observer.next(v);
                },
                error: function (e) {
                  observer.error(e);
                },
                complete: function () {
                  if (index === sources.length) {
                    subscription = undefined;
                    observer.complete();
                  } else {
                    startNext(C.from(sources[index++]));
                  }
                }
              });
            }

            startNext(_this5);

            return function () {
              if (subscription) {
                subscription.unsubscribe();
                subscription = undefined;
              }
            };
          });
        }
      }, {
        key: 'flatMap',
        value: function flatMap(fn) {
          var _this6 = this;

          if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

          var C = getSpecies(this);

          return new C(function (observer) {
            var subscriptions = [];

            var outer = _this6.subscribe({
              next: function (value) {
                if (fn) {
                  try {
                    value = fn(value);
                  } catch (e) {
                    return observer.error(e);
                  }
                }

                var inner = C.from(value).subscribe({
                  next: function (value) {
                    observer.next(value);
                  },
                  error: function (e) {
                    observer.error(e);
                  },
                  complete: function () {
                    var i = subscriptions.indexOf(inner);
                    if (i >= 0) subscriptions.splice(i, 1);
                    completeIfDone();
                  }
                });

                subscriptions.push(inner);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                completeIfDone();
              }
            });

            function completeIfDone() {
              if (outer.closed && subscriptions.length === 0) observer.complete();
            }

            return function () {
              subscriptions.forEach(function (s) {
                return s.unsubscribe();
              });
              outer.unsubscribe();
            };
          });
        }
      }, {
        key: SymbolObservable,
        value: function () {
          return this;
        }
      }], [{
        key: 'from',
        value: function from(x) {
          var C = typeof this === 'function' ? this : Observable;

          if (x == null) throw new TypeError(x + ' is not an object');

          var method = getMethod(x, SymbolObservable);
          if (method) {
            var observable = method.call(x);

            if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');

            if (isObservable(observable) && observable.constructor === C) return observable;

            return new C(function (observer) {
              return observable.subscribe(observer);
            });
          }

          if (hasSymbol('iterator')) {
            method = getMethod(x, SymbolIterator);
            if (method) {
              return new C(function (observer) {
                enqueue(function () {
                  if (observer.closed) return;
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = undefined;

                  try {
                    for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var item = _step.value;

                      observer.next(item);
                      if (observer.closed) return;
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }

                  observer.complete();
                });
              });
            }
          }

          if (Array.isArray(x)) {
            return new C(function (observer) {
              enqueue(function () {
                if (observer.closed) return;
                for (var i = 0; i < x.length; ++i) {
                  observer.next(x[i]);
                  if (observer.closed) return;
                }
                observer.complete();
              });
            });
          }

          throw new TypeError(x + ' is not observable');
        }
      }, {
        key: 'of',
        value: function of() {
          for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            items[_key2] = arguments[_key2];
          }

          var C = typeof this === 'function' ? this : Observable;

          return new C(function (observer) {
            enqueue(function () {
              if (observer.closed) return;
              for (var i = 0; i < items.length; ++i) {
                observer.next(items[i]);
                if (observer.closed) return;
              }
              observer.complete();
            });
          });
        }
      }, {
        key: SymbolSpecies,
        get: function () {
          return this;
        }
      }]);

      return Observable;
    }();

    if (hasSymbols()) {
      Object.defineProperty(Observable, Symbol('extensions'), {
        value: {
          symbol: SymbolObservable,
          hostReportError: hostReportError
        },
        configurable: true
      });
    }
    });

    unwrapExports(Observable_1);
    var Observable_2 = Observable_1.Observable;

    var zenObservable = Observable_1.Observable;

    var Observable = zenObservable;
    //# sourceMappingURL=bundle.esm.js.map

    function validateOperation(operation) {
        var OPERATION_FIELDS = [
            'query',
            'operationName',
            'variables',
            'extensions',
            'context',
        ];
        for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
            var key = _a[_i];
            if (OPERATION_FIELDS.indexOf(key) < 0) {
                throw process.env.NODE_ENV === "production" ? new InvariantError(2) : new InvariantError("illegal argument: " + key);
            }
        }
        return operation;
    }
    var LinkError = (function (_super) {
        __extends(LinkError, _super);
        function LinkError(message, link) {
            var _this = _super.call(this, message) || this;
            _this.link = link;
            return _this;
        }
        return LinkError;
    }(Error));
    function isTerminating(link) {
        return link.request.length <= 1;
    }
    function fromError(errorValue) {
        return new Observable(function (observer) {
            observer.error(errorValue);
        });
    }
    function transformOperation(operation) {
        var transformedOperation = {
            variables: operation.variables || {},
            extensions: operation.extensions || {},
            operationName: operation.operationName,
            query: operation.query,
        };
        if (!transformedOperation.operationName) {
            transformedOperation.operationName =
                typeof transformedOperation.query !== 'string'
                    ? getOperationName(transformedOperation.query)
                    : '';
        }
        return transformedOperation;
    }
    function createOperation(starting, operation) {
        var context = __assign({}, starting);
        var setContext = function (next) {
            if (typeof next === 'function') {
                context = __assign({}, context, next(context));
            }
            else {
                context = __assign({}, context, next);
            }
        };
        var getContext = function () { return (__assign({}, context)); };
        Object.defineProperty(operation, 'setContext', {
            enumerable: false,
            value: setContext,
        });
        Object.defineProperty(operation, 'getContext', {
            enumerable: false,
            value: getContext,
        });
        Object.defineProperty(operation, 'toKey', {
            enumerable: false,
            value: function () { return getKey(operation); },
        });
        return operation;
    }
    function getKey(operation) {
        var query = operation.query, variables = operation.variables, operationName = operation.operationName;
        return JSON.stringify([operationName, query, variables]);
    }

    function passthrough(op, forward) {
        return forward ? forward(op) : Observable.of();
    }
    function toLink(handler) {
        return typeof handler === 'function' ? new ApolloLink(handler) : handler;
    }
    function empty$1() {
        return new ApolloLink(function () { return Observable.of(); });
    }
    function from(links) {
        if (links.length === 0)
            return empty$1();
        return links.map(toLink).reduce(function (x, y) { return x.concat(y); });
    }
    function split(test, left, right) {
        var leftLink = toLink(left);
        var rightLink = toLink(right || new ApolloLink(passthrough));
        if (isTerminating(leftLink) && isTerminating(rightLink)) {
            return new ApolloLink(function (operation) {
                return test(operation)
                    ? leftLink.request(operation) || Observable.of()
                    : rightLink.request(operation) || Observable.of();
            });
        }
        else {
            return new ApolloLink(function (operation, forward) {
                return test(operation)
                    ? leftLink.request(operation, forward) || Observable.of()
                    : rightLink.request(operation, forward) || Observable.of();
            });
        }
    }
    var concat = function (first, second) {
        var firstLink = toLink(first);
        if (isTerminating(firstLink)) {
            process.env.NODE_ENV === "production" || invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
            return firstLink;
        }
        var nextLink = toLink(second);
        if (isTerminating(nextLink)) {
            return new ApolloLink(function (operation) {
                return firstLink.request(operation, function (op) { return nextLink.request(op) || Observable.of(); }) || Observable.of();
            });
        }
        else {
            return new ApolloLink(function (operation, forward) {
                return (firstLink.request(operation, function (op) {
                    return nextLink.request(op, forward) || Observable.of();
                }) || Observable.of());
            });
        }
    };
    var ApolloLink = (function () {
        function ApolloLink(request) {
            if (request)
                this.request = request;
        }
        ApolloLink.prototype.split = function (test, left, right) {
            return this.concat(split(test, left, right || new ApolloLink(passthrough)));
        };
        ApolloLink.prototype.concat = function (next) {
            return concat(this, next);
        };
        ApolloLink.prototype.request = function (operation, forward) {
            throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError('request is not implemented');
        };
        ApolloLink.empty = empty$1;
        ApolloLink.from = from;
        ApolloLink.split = split;
        ApolloLink.execute = execute;
        return ApolloLink;
    }());
    function execute(link, operation) {
        return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of());
    }
    //# sourceMappingURL=bundle.esm.js.map

    function symbolObservablePonyfill(root) {
    	var result;
    	var Symbol = root.Symbol;

    	if (typeof Symbol === 'function') {
    		if (Symbol.observable) {
    			result = Symbol.observable;
    		} else {
    			result = Symbol('observable');
    			Symbol.observable = result;
    		}
    	} else {
    		result = '@@observable';
    	}

    	return result;
    }

    /* global window */

    var root;

    if (typeof self !== 'undefined') {
      root = self;
    } else if (typeof window !== 'undefined') {
      root = window;
    } else if (typeof global !== 'undefined') {
      root = global;
    } else if (typeof module !== 'undefined') {
      root = module;
    } else {
      root = Function('return this')();
    }

    var result = symbolObservablePonyfill(root);

    var NetworkStatus;
    (function (NetworkStatus) {
        NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
        NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
        NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
        NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
        NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
        NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
        NetworkStatus[NetworkStatus["error"] = 8] = "error";
    })(NetworkStatus || (NetworkStatus = {}));
    function isNetworkRequestInFlight(networkStatus) {
        return networkStatus < 7;
    }

    var Observable$1 = (function (_super) {
        __extends(Observable, _super);
        function Observable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Observable.prototype[result] = function () {
            return this;
        };
        Observable.prototype['@@observable'] = function () {
            return this;
        };
        return Observable;
    }(Observable));

    function isNonEmptyArray(value) {
        return Array.isArray(value) && value.length > 0;
    }

    function isApolloError(err) {
        return err.hasOwnProperty('graphQLErrors');
    }
    var generateErrorMessage = function (err) {
        var message = '';
        if (isNonEmptyArray(err.graphQLErrors)) {
            err.graphQLErrors.forEach(function (graphQLError) {
                var errorMessage = graphQLError
                    ? graphQLError.message
                    : 'Error message not found.';
                message += "GraphQL error: " + errorMessage + "\n";
            });
        }
        if (err.networkError) {
            message += 'Network error: ' + err.networkError.message + '\n';
        }
        message = message.replace(/\n$/, '');
        return message;
    };
    var ApolloError = (function (_super) {
        __extends(ApolloError, _super);
        function ApolloError(_a) {
            var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
            var _this = _super.call(this, errorMessage) || this;
            _this.graphQLErrors = graphQLErrors || [];
            _this.networkError = networkError || null;
            if (!errorMessage) {
                _this.message = generateErrorMessage(_this);
            }
            else {
                _this.message = errorMessage;
            }
            _this.extraInfo = extraInfo;
            _this.__proto__ = ApolloError.prototype;
            return _this;
        }
        return ApolloError;
    }(Error));

    var FetchType;
    (function (FetchType) {
        FetchType[FetchType["normal"] = 1] = "normal";
        FetchType[FetchType["refetch"] = 2] = "refetch";
        FetchType[FetchType["poll"] = 3] = "poll";
    })(FetchType || (FetchType = {}));

    var hasError = function (storeValue, policy) {
        if (policy === void 0) { policy = 'none'; }
        return storeValue && (storeValue.networkError ||
            (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors)));
    };
    var ObservableQuery = (function (_super) {
        __extends(ObservableQuery, _super);
        function ObservableQuery(_a) {
            var queryManager = _a.queryManager, options = _a.options, _b = _a.shouldSubscribe, shouldSubscribe = _b === void 0 ? true : _b;
            var _this = _super.call(this, function (observer) {
                return _this.onSubscribe(observer);
            }) || this;
            _this.observers = new Set();
            _this.subscriptions = new Set();
            _this.isTornDown = false;
            _this.options = options;
            _this.variables = options.variables || {};
            _this.queryId = queryManager.generateQueryId();
            _this.shouldSubscribe = shouldSubscribe;
            var opDef = getOperationDefinition(options.query);
            _this.queryName = opDef && opDef.name && opDef.name.value;
            _this.queryManager = queryManager;
            return _this;
        }
        ObservableQuery.prototype.result = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var observer = {
                    next: function (result) {
                        resolve(result);
                        _this.observers.delete(observer);
                        if (!_this.observers.size) {
                            _this.queryManager.removeQuery(_this.queryId);
                        }
                        setTimeout(function () {
                            subscription.unsubscribe();
                        }, 0);
                    },
                    error: reject,
                };
                var subscription = _this.subscribe(observer);
            });
        };
        ObservableQuery.prototype.currentResult = function () {
            var result = this.getCurrentResult();
            if (result.data === undefined) {
                result.data = {};
            }
            return result;
        };
        ObservableQuery.prototype.getCurrentResult = function () {
            if (this.isTornDown) {
                var lastResult = this.lastResult;
                return {
                    data: !this.lastError && lastResult && lastResult.data || void 0,
                    error: this.lastError,
                    loading: false,
                    networkStatus: NetworkStatus.error,
                };
            }
            var _a = this.queryManager.getCurrentQueryResult(this), data = _a.data, partial = _a.partial;
            var queryStoreValue = this.queryManager.queryStore.get(this.queryId);
            var result;
            var fetchPolicy = this.options.fetchPolicy;
            var isNetworkFetchPolicy = fetchPolicy === 'network-only' ||
                fetchPolicy === 'no-cache';
            if (queryStoreValue) {
                var networkStatus = queryStoreValue.networkStatus;
                if (hasError(queryStoreValue, this.options.errorPolicy)) {
                    return {
                        data: void 0,
                        loading: false,
                        networkStatus: networkStatus,
                        error: new ApolloError({
                            graphQLErrors: queryStoreValue.graphQLErrors,
                            networkError: queryStoreValue.networkError,
                        }),
                    };
                }
                if (queryStoreValue.variables) {
                    this.options.variables = __assign({}, this.options.variables, queryStoreValue.variables);
                    this.variables = this.options.variables;
                }
                result = {
                    data: data,
                    loading: isNetworkRequestInFlight(networkStatus),
                    networkStatus: networkStatus,
                };
                if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {
                    result.errors = queryStoreValue.graphQLErrors;
                }
            }
            else {
                var loading = isNetworkFetchPolicy ||
                    (partial && fetchPolicy !== 'cache-only');
                result = {
                    data: data,
                    loading: loading,
                    networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,
                };
            }
            if (!partial) {
                this.updateLastResult(__assign({}, result, { stale: false }));
            }
            return __assign({}, result, { partial: partial });
        };
        ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {
            var snapshot = this.lastResultSnapshot;
            return !(snapshot &&
                newResult &&
                snapshot.networkStatus === newResult.networkStatus &&
                snapshot.stale === newResult.stale &&
                equal(snapshot.data, newResult.data));
        };
        ObservableQuery.prototype.getLastResult = function () {
            return this.lastResult;
        };
        ObservableQuery.prototype.getLastError = function () {
            return this.lastError;
        };
        ObservableQuery.prototype.resetLastResults = function () {
            delete this.lastResult;
            delete this.lastResultSnapshot;
            delete this.lastError;
            this.isTornDown = false;
        };
        ObservableQuery.prototype.resetQueryStoreErrors = function () {
            var queryStore = this.queryManager.queryStore.get(this.queryId);
            if (queryStore) {
                queryStore.networkError = null;
                queryStore.graphQLErrors = [];
            }
        };
        ObservableQuery.prototype.refetch = function (variables) {
            var fetchPolicy = this.options.fetchPolicy;
            if (fetchPolicy === 'cache-only') {
                return Promise.reject(process.env.NODE_ENV === "production" ? new InvariantError(3) : new InvariantError('cache-only fetchPolicy option should not be used together with query refetch.'));
            }
            if (fetchPolicy !== 'no-cache' &&
                fetchPolicy !== 'cache-and-network') {
                fetchPolicy = 'network-only';
            }
            if (!equal(this.variables, variables)) {
                this.variables = __assign({}, this.variables, variables);
            }
            if (!equal(this.options.variables, this.variables)) {
                this.options.variables = __assign({}, this.options.variables, this.variables);
            }
            return this.queryManager.fetchQuery(this.queryId, __assign({}, this.options, { fetchPolicy: fetchPolicy }), FetchType.refetch);
        };
        ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
            var _this = this;
            process.env.NODE_ENV === "production" ? invariant(fetchMoreOptions.updateQuery, 4) : invariant(fetchMoreOptions.updateQuery, 'updateQuery option is required. This function defines how to update the query data with the new results.');
            var combinedOptions = __assign({}, (fetchMoreOptions.query ? fetchMoreOptions : __assign({}, this.options, fetchMoreOptions, { variables: __assign({}, this.variables, fetchMoreOptions.variables) })), { fetchPolicy: 'network-only' });
            var qid = this.queryManager.generateQueryId();
            return this.queryManager
                .fetchQuery(qid, combinedOptions, FetchType.normal, this.queryId)
                .then(function (fetchMoreResult) {
                _this.updateQuery(function (previousResult) {
                    return fetchMoreOptions.updateQuery(previousResult, {
                        fetchMoreResult: fetchMoreResult.data,
                        variables: combinedOptions.variables,
                    });
                });
                _this.queryManager.stopQuery(qid);
                return fetchMoreResult;
            }, function (error) {
                _this.queryManager.stopQuery(qid);
                throw error;
            });
        };
        ObservableQuery.prototype.subscribeToMore = function (options) {
            var _this = this;
            var subscription = this.queryManager
                .startGraphQLSubscription({
                query: options.document,
                variables: options.variables,
            })
                .subscribe({
                next: function (subscriptionData) {
                    var updateQuery = options.updateQuery;
                    if (updateQuery) {
                        _this.updateQuery(function (previous, _a) {
                            var variables = _a.variables;
                            return updateQuery(previous, {
                                subscriptionData: subscriptionData,
                                variables: variables,
                            });
                        });
                    }
                },
                error: function (err) {
                    if (options.onError) {
                        options.onError(err);
                        return;
                    }
                    process.env.NODE_ENV === "production" || invariant.error('Unhandled GraphQL subscription error', err);
                },
            });
            this.subscriptions.add(subscription);
            return function () {
                if (_this.subscriptions.delete(subscription)) {
                    subscription.unsubscribe();
                }
            };
        };
        ObservableQuery.prototype.setOptions = function (opts) {
            var oldFetchPolicy = this.options.fetchPolicy;
            this.options = __assign({}, this.options, opts);
            if (opts.pollInterval) {
                this.startPolling(opts.pollInterval);
            }
            else if (opts.pollInterval === 0) {
                this.stopPolling();
            }
            var fetchPolicy = opts.fetchPolicy;
            return this.setVariables(this.options.variables, oldFetchPolicy !== fetchPolicy && (oldFetchPolicy === 'cache-only' ||
                oldFetchPolicy === 'standby' ||
                fetchPolicy === 'network-only'), opts.fetchResults);
        };
        ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {
            if (tryFetch === void 0) { tryFetch = false; }
            if (fetchResults === void 0) { fetchResults = true; }
            this.isTornDown = false;
            variables = variables || this.variables;
            if (!tryFetch && equal(variables, this.variables)) {
                return this.observers.size && fetchResults
                    ? this.result()
                    : Promise.resolve();
            }
            this.variables = this.options.variables = variables;
            if (!this.observers.size) {
                return Promise.resolve();
            }
            return this.queryManager.fetchQuery(this.queryId, this.options);
        };
        ObservableQuery.prototype.updateQuery = function (mapFn) {
            var queryManager = this.queryManager;
            var _a = queryManager.getQueryWithPreviousResult(this.queryId), previousResult = _a.previousResult, variables = _a.variables, document = _a.document;
            var newResult = tryFunctionOrLogError(function () {
                return mapFn(previousResult, { variables: variables });
            });
            if (newResult) {
                queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);
                queryManager.broadcastQueries();
            }
        };
        ObservableQuery.prototype.stopPolling = function () {
            this.queryManager.stopPollingQuery(this.queryId);
            this.options.pollInterval = undefined;
        };
        ObservableQuery.prototype.startPolling = function (pollInterval) {
            assertNotCacheFirstOrOnly(this);
            this.options.pollInterval = pollInterval;
            this.queryManager.startPollingQuery(this.options, this.queryId);
        };
        ObservableQuery.prototype.updateLastResult = function (newResult) {
            var previousResult = this.lastResult;
            this.lastResult = newResult;
            this.lastResultSnapshot = this.queryManager.assumeImmutableResults
                ? newResult
                : cloneDeep(newResult);
            return previousResult;
        };
        ObservableQuery.prototype.onSubscribe = function (observer) {
            var _this = this;
            try {
                var subObserver = observer._subscription._observer;
                if (subObserver && !subObserver.error) {
                    subObserver.error = defaultSubscriptionObserverErrorCallback;
                }
            }
            catch (_a) { }
            var first = !this.observers.size;
            this.observers.add(observer);
            if (observer.next && this.lastResult)
                observer.next(this.lastResult);
            if (observer.error && this.lastError)
                observer.error(this.lastError);
            if (first) {
                this.setUpQuery();
            }
            return function () {
                if (_this.observers.delete(observer) && !_this.observers.size) {
                    _this.tearDownQuery();
                }
            };
        };
        ObservableQuery.prototype.setUpQuery = function () {
            var _this = this;
            var _a = this, queryManager = _a.queryManager, queryId = _a.queryId;
            if (this.shouldSubscribe) {
                queryManager.addObservableQuery(queryId, this);
            }
            if (this.options.pollInterval) {
                assertNotCacheFirstOrOnly(this);
                queryManager.startPollingQuery(this.options, queryId);
            }
            var onError = function (error) {
                iterateObserversSafely(_this.observers, 'error', _this.lastError = error);
            };
            queryManager.observeQuery(queryId, this.options, {
                next: function (result) {
                    if (_this.lastError || _this.isDifferentFromLastResult(result)) {
                        var previousResult_1 = _this.updateLastResult(result);
                        var _a = _this.options, query_1 = _a.query, variables = _a.variables, fetchPolicy_1 = _a.fetchPolicy;
                        if (queryManager.transform(query_1).hasClientExports) {
                            queryManager.getLocalState().addExportedVariables(query_1, variables).then(function (variables) {
                                var previousVariables = _this.variables;
                                _this.variables = _this.options.variables = variables;
                                if (!result.loading &&
                                    previousResult_1 &&
                                    fetchPolicy_1 !== 'cache-only' &&
                                    queryManager.transform(query_1).serverQuery &&
                                    !equal(previousVariables, variables)) {
                                    _this.refetch();
                                }
                                else {
                                    iterateObserversSafely(_this.observers, 'next', result);
                                }
                            });
                        }
                        else {
                            iterateObserversSafely(_this.observers, 'next', result);
                        }
                    }
                },
                error: onError,
            }).catch(onError);
        };
        ObservableQuery.prototype.tearDownQuery = function () {
            var queryManager = this.queryManager;
            this.isTornDown = true;
            queryManager.stopPollingQuery(this.queryId);
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            this.subscriptions.clear();
            queryManager.removeObservableQuery(this.queryId);
            queryManager.stopQuery(this.queryId);
            this.observers.clear();
        };
        return ObservableQuery;
    }(Observable$1));
    function defaultSubscriptionObserverErrorCallback(error) {
        process.env.NODE_ENV === "production" || invariant.error('Unhandled error', error.message, error.stack);
    }
    function iterateObserversSafely(observers, method, argument) {
        var observersWithMethod = [];
        observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });
        observersWithMethod.forEach(function (obs) { return obs[method](argument); });
    }
    function assertNotCacheFirstOrOnly(obsQuery) {
        var fetchPolicy = obsQuery.options.fetchPolicy;
        process.env.NODE_ENV === "production" ? invariant(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 5) : invariant(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');
    }

    var MutationStore = (function () {
        function MutationStore() {
            this.store = {};
        }
        MutationStore.prototype.getStore = function () {
            return this.store;
        };
        MutationStore.prototype.get = function (mutationId) {
            return this.store[mutationId];
        };
        MutationStore.prototype.initMutation = function (mutationId, mutation, variables) {
            this.store[mutationId] = {
                mutation: mutation,
                variables: variables || {},
                loading: true,
                error: null,
            };
        };
        MutationStore.prototype.markMutationError = function (mutationId, error) {
            var mutation = this.store[mutationId];
            if (mutation) {
                mutation.loading = false;
                mutation.error = error;
            }
        };
        MutationStore.prototype.markMutationResult = function (mutationId) {
            var mutation = this.store[mutationId];
            if (mutation) {
                mutation.loading = false;
                mutation.error = null;
            }
        };
        MutationStore.prototype.reset = function () {
            this.store = {};
        };
        return MutationStore;
    }());

    var QueryStore = (function () {
        function QueryStore() {
            this.store = {};
        }
        QueryStore.prototype.getStore = function () {
            return this.store;
        };
        QueryStore.prototype.get = function (queryId) {
            return this.store[queryId];
        };
        QueryStore.prototype.initQuery = function (query) {
            var previousQuery = this.store[query.queryId];
            process.env.NODE_ENV === "production" ? invariant(!previousQuery ||
                previousQuery.document === query.document ||
                equal(previousQuery.document, query.document), 19) : invariant(!previousQuery ||
                previousQuery.document === query.document ||
                equal(previousQuery.document, query.document), 'Internal Error: may not update existing query string in store');
            var isSetVariables = false;
            var previousVariables = null;
            if (query.storePreviousVariables &&
                previousQuery &&
                previousQuery.networkStatus !== NetworkStatus.loading) {
                if (!equal(previousQuery.variables, query.variables)) {
                    isSetVariables = true;
                    previousVariables = previousQuery.variables;
                }
            }
            var networkStatus;
            if (isSetVariables) {
                networkStatus = NetworkStatus.setVariables;
            }
            else if (query.isPoll) {
                networkStatus = NetworkStatus.poll;
            }
            else if (query.isRefetch) {
                networkStatus = NetworkStatus.refetch;
            }
            else {
                networkStatus = NetworkStatus.loading;
            }
            var graphQLErrors = [];
            if (previousQuery && previousQuery.graphQLErrors) {
                graphQLErrors = previousQuery.graphQLErrors;
            }
            this.store[query.queryId] = {
                document: query.document,
                variables: query.variables,
                previousVariables: previousVariables,
                networkError: null,
                graphQLErrors: graphQLErrors,
                networkStatus: networkStatus,
                metadata: query.metadata,
            };
            if (typeof query.fetchMoreForQueryId === 'string' &&
                this.store[query.fetchMoreForQueryId]) {
                this.store[query.fetchMoreForQueryId].networkStatus =
                    NetworkStatus.fetchMore;
            }
        };
        QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {
            if (!this.store || !this.store[queryId])
                return;
            this.store[queryId].networkError = null;
            this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];
            this.store[queryId].previousVariables = null;
            this.store[queryId].networkStatus = NetworkStatus.ready;
            if (typeof fetchMoreForQueryId === 'string' &&
                this.store[fetchMoreForQueryId]) {
                this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;
            }
        };
        QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {
            if (!this.store || !this.store[queryId])
                return;
            this.store[queryId].networkError = error;
            this.store[queryId].networkStatus = NetworkStatus.error;
            if (typeof fetchMoreForQueryId === 'string') {
                this.markQueryResultClient(fetchMoreForQueryId, true);
            }
        };
        QueryStore.prototype.markQueryResultClient = function (queryId, complete) {
            var storeValue = this.store && this.store[queryId];
            if (storeValue) {
                storeValue.networkError = null;
                storeValue.previousVariables = null;
                if (complete) {
                    storeValue.networkStatus = NetworkStatus.ready;
                }
            }
        };
        QueryStore.prototype.stopQuery = function (queryId) {
            delete this.store[queryId];
        };
        QueryStore.prototype.reset = function (observableQueryIds) {
            var _this = this;
            Object.keys(this.store).forEach(function (queryId) {
                if (observableQueryIds.indexOf(queryId) < 0) {
                    _this.stopQuery(queryId);
                }
                else {
                    _this.store[queryId].networkStatus = NetworkStatus.loading;
                }
            });
        };
        return QueryStore;
    }());

    function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    var LocalState = (function () {
        function LocalState(_a) {
            var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
            this.cache = cache;
            if (client) {
                this.client = client;
            }
            if (resolvers) {
                this.addResolvers(resolvers);
            }
            if (fragmentMatcher) {
                this.setFragmentMatcher(fragmentMatcher);
            }
        }
        LocalState.prototype.addResolvers = function (resolvers) {
            var _this = this;
            this.resolvers = this.resolvers || {};
            if (Array.isArray(resolvers)) {
                resolvers.forEach(function (resolverGroup) {
                    _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
                });
            }
            else {
                this.resolvers = mergeDeep(this.resolvers, resolvers);
            }
        };
        LocalState.prototype.setResolvers = function (resolvers) {
            this.resolvers = {};
            this.addResolvers(resolvers);
        };
        LocalState.prototype.getResolvers = function () {
            return this.resolvers || {};
        };
        LocalState.prototype.runResolvers = function (_a) {
            var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_c) {
                    if (document) {
                        return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (__assign({}, remoteResult, { data: localResult.result })); })];
                    }
                    return [2, remoteResult];
                });
            });
        };
        LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {
            this.fragmentMatcher = fragmentMatcher;
        };
        LocalState.prototype.getFragmentMatcher = function () {
            return this.fragmentMatcher;
        };
        LocalState.prototype.clientQuery = function (document) {
            if (hasDirectives(['client'], document)) {
                if (this.resolvers) {
                    return document;
                }
                process.env.NODE_ENV === "production" || invariant.warn('Found @client directives in a query but no ApolloClient resolvers ' +
                    'were specified. This means ApolloClient local resolver handling ' +
                    'has been disabled, and @client directives will be passed through ' +
                    'to your link chain.');
            }
            return null;
        };
        LocalState.prototype.serverQuery = function (document) {
            return this.resolvers ? removeClientSetsFromDocument(document) : document;
        };
        LocalState.prototype.prepareContext = function (context) {
            if (context === void 0) { context = {}; }
            var cache = this.cache;
            var newContext = __assign({}, context, { cache: cache, getCacheKey: function (obj) {
                    if (cache.config) {
                        return cache.config.dataIdFromObject(obj);
                    }
                    else {
                        process.env.NODE_ENV === "production" ? invariant(false, 17) : invariant(false, 'To use context.getCacheKey, you need to use a cache that has ' +
                            'a configurable dataIdFromObject, like apollo-cache-inmemory.');
                    }
                } });
            return newContext;
        };
        LocalState.prototype.addExportedVariables = function (document, variables, context) {
            if (variables === void 0) { variables = {}; }
            if (context === void 0) { context = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (document) {
                        return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (__assign({}, variables, data.exportedVariables)); })];
                    }
                    return [2, __assign({}, variables)];
                });
            });
        };
        LocalState.prototype.shouldForceResolvers = function (document) {
            var forceResolvers = false;
            visit(document, {
                Directive: {
                    enter: function (node) {
                        if (node.name.value === 'client' && node.arguments) {
                            forceResolvers = node.arguments.some(function (arg) {
                                return arg.name.value === 'always' &&
                                    arg.value.kind === 'BooleanValue' &&
                                    arg.value.value === true;
                            });
                            if (forceResolvers) {
                                return BREAK;
                            }
                        }
                    },
                },
            });
            return forceResolvers;
        };
        LocalState.prototype.buildRootValueFromCache = function (document, variables) {
            return this.cache.diff({
                query: buildQueryFromSelectionSet(document),
                variables: variables,
                returnPartialData: true,
                optimistic: false,
            }).result;
        };
        LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
            if (context === void 0) { context = {}; }
            if (variables === void 0) { variables = {}; }
            if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }
            if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }
            return __awaiter(this, void 0, void 0, function () {
                var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;
                return __generator(this, function (_b) {
                    mainDefinition = getMainDefinition(document);
                    fragments = getFragmentDefinitions(document);
                    fragmentMap = createFragmentMap(fragments);
                    definitionOperation = mainDefinition
                        .operation;
                    defaultOperationType = definitionOperation
                        ? capitalizeFirstLetter(definitionOperation)
                        : 'Query';
                    _a = this, cache = _a.cache, client = _a.client;
                    execContext = {
                        fragmentMap: fragmentMap,
                        context: __assign({}, context, { cache: cache,
                            client: client }),
                        variables: variables,
                        fragmentMatcher: fragmentMatcher,
                        defaultOperationType: defaultOperationType,
                        exportedVariables: {},
                        onlyRunForcedResolvers: onlyRunForcedResolvers,
                    };
                    return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) { return ({
                            result: result,
                            exportedVariables: execContext.exportedVariables,
                        }); })];
                });
            });
        };
        LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {
            return __awaiter(this, void 0, void 0, function () {
                var fragmentMap, context, variables, resultsToMerge, execute;
                var _this = this;
                return __generator(this, function (_a) {
                    fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
                    resultsToMerge = [rootValue];
                    execute = function (selection) { return __awaiter(_this, void 0, void 0, function () {
                        var fragment, typeCondition;
                        return __generator(this, function (_a) {
                            if (!shouldInclude(selection, variables)) {
                                return [2];
                            }
                            if (isField(selection)) {
                                return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {
                                        var _a;
                                        if (typeof fieldResult !== 'undefined') {
                                            resultsToMerge.push((_a = {},
                                                _a[resultKeyNameFromField(selection)] = fieldResult,
                                                _a));
                                        }
                                    })];
                            }
                            if (isInlineFragment(selection)) {
                                fragment = selection;
                            }
                            else {
                                fragment = fragmentMap[selection.name.value];
                                process.env.NODE_ENV === "production" ? invariant(fragment, 18) : invariant(fragment, "No fragment named " + selection.name.value);
                            }
                            if (fragment && fragment.typeCondition) {
                                typeCondition = fragment.typeCondition.name.value;
                                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                                    return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {
                                            resultsToMerge.push(fragmentResult);
                                        })];
                                }
                            }
                            return [2];
                        });
                    }); };
                    return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {
                            return mergeDeepArray(resultsToMerge);
                        })];
                });
            });
        };
        LocalState.prototype.resolveField = function (field, rootValue, execContext) {
            return __awaiter(this, void 0, void 0, function () {
                var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
                var _this = this;
                return __generator(this, function (_a) {
                    variables = execContext.variables;
                    fieldName = field.name.value;
                    aliasedFieldName = resultKeyNameFromField(field);
                    aliasUsed = fieldName !== aliasedFieldName;
                    defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
                    resultPromise = Promise.resolve(defaultResult);
                    if (!execContext.onlyRunForcedResolvers ||
                        this.shouldForceResolvers(field)) {
                        resolverType = rootValue.__typename || execContext.defaultOperationType;
                        resolverMap = this.resolvers && this.resolvers[resolverType];
                        if (resolverMap) {
                            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                            if (resolve) {
                                resultPromise = Promise.resolve(resolve(rootValue, argumentsObjectFromField(field, variables), execContext.context, { field: field }));
                            }
                        }
                    }
                    return [2, resultPromise.then(function (result) {
                            if (result === void 0) { result = defaultResult; }
                            if (field.directives) {
                                field.directives.forEach(function (directive) {
                                    if (directive.name.value === 'export' && directive.arguments) {
                                        directive.arguments.forEach(function (arg) {
                                            if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {
                                                execContext.exportedVariables[arg.value.value] = result;
                                            }
                                        });
                                    }
                                });
                            }
                            if (!field.selectionSet) {
                                return result;
                            }
                            if (result == null) {
                                return result;
                            }
                            if (Array.isArray(result)) {
                                return _this.resolveSubSelectedArray(field, result, execContext);
                            }
                            if (field.selectionSet) {
                                return _this.resolveSelectionSet(field.selectionSet, result, execContext);
                            }
                        })];
                });
            });
        };
        LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {
            var _this = this;
            return Promise.all(result.map(function (item) {
                if (item === null) {
                    return null;
                }
                if (Array.isArray(item)) {
                    return _this.resolveSubSelectedArray(field, item, execContext);
                }
                if (field.selectionSet) {
                    return _this.resolveSelectionSet(field.selectionSet, item, execContext);
                }
            }));
        };
        return LocalState;
    }());

    function multiplex(inner) {
        var observers = new Set();
        var sub = null;
        return new Observable$1(function (observer) {
            observers.add(observer);
            sub = sub || inner.subscribe({
                next: function (value) {
                    observers.forEach(function (obs) { return obs.next && obs.next(value); });
                },
                error: function (error) {
                    observers.forEach(function (obs) { return obs.error && obs.error(error); });
                },
                complete: function () {
                    observers.forEach(function (obs) { return obs.complete && obs.complete(); });
                },
            });
            return function () {
                if (observers.delete(observer) && !observers.size && sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
        });
    }
    function asyncMap(observable, mapFn) {
        return new Observable$1(function (observer) {
            var next = observer.next, error = observer.error, complete = observer.complete;
            var activeNextCount = 0;
            var completed = false;
            var handler = {
                next: function (value) {
                    ++activeNextCount;
                    new Promise(function (resolve) {
                        resolve(mapFn(value));
                    }).then(function (result) {
                        --activeNextCount;
                        next && next.call(observer, result);
                        completed && handler.complete();
                    }, function (e) {
                        --activeNextCount;
                        error && error.call(observer, e);
                    });
                },
                error: function (e) {
                    error && error.call(observer, e);
                },
                complete: function () {
                    completed = true;
                    if (!activeNextCount) {
                        complete && complete.call(observer);
                    }
                },
            };
            var sub = observable.subscribe(handler);
            return function () { return sub.unsubscribe(); };
        });
    }

    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var QueryManager = (function () {
        function QueryManager(_a) {
            var link = _a.link, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, store = _a.store, _c = _a.onBroadcast, onBroadcast = _c === void 0 ? function () { return undefined; } : _c, _d = _a.ssrMode, ssrMode = _d === void 0 ? false : _d, _e = _a.clientAwareness, clientAwareness = _e === void 0 ? {} : _e, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;
            this.mutationStore = new MutationStore();
            this.queryStore = new QueryStore();
            this.clientAwareness = {};
            this.idCounter = 1;
            this.queries = new Map();
            this.fetchQueryRejectFns = new Map();
            this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
            this.inFlightLinkObservables = new Map();
            this.pollingInfoByQueryId = new Map();
            this.link = link;
            this.queryDeduplication = queryDeduplication;
            this.dataStore = store;
            this.onBroadcast = onBroadcast;
            this.clientAwareness = clientAwareness;
            this.localState = localState || new LocalState({ cache: store.getCache() });
            this.ssrMode = ssrMode;
            this.assumeImmutableResults = !!assumeImmutableResults;
        }
        QueryManager.prototype.stop = function () {
            var _this = this;
            this.queries.forEach(function (_info, queryId) {
                _this.stopQueryNoBroadcast(queryId);
            });
            this.fetchQueryRejectFns.forEach(function (reject) {
                reject(process.env.NODE_ENV === "production" ? new InvariantError(6) : new InvariantError('QueryManager stopped while query was in flight'));
            });
        };
        QueryManager.prototype.mutate = function (_a) {
            var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueriesByName = _a.updateQueries, _b = _a.refetchQueries, refetchQueries = _b === void 0 ? [] : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, updateWithProxyFn = _a.update, _d = _a.errorPolicy, errorPolicy = _d === void 0 ? 'none' : _d, fetchPolicy = _a.fetchPolicy, _e = _a.context, context = _e === void 0 ? {} : _e;
            return __awaiter(this, void 0, void 0, function () {
                var mutationId, generateUpdateQueriesInfo, self;
                var _this = this;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            process.env.NODE_ENV === "production" ? invariant(mutation, 7) : invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.');
                            process.env.NODE_ENV === "production" ? invariant(!fetchPolicy || fetchPolicy === 'no-cache', 8) : invariant(!fetchPolicy || fetchPolicy === 'no-cache', "fetchPolicy for mutations currently only supports the 'no-cache' policy");
                            mutationId = this.generateQueryId();
                            mutation = this.transform(mutation).document;
                            this.setQuery(mutationId, function () { return ({ document: mutation }); });
                            variables = this.getVariables(mutation, variables);
                            if (!this.transform(mutation).hasClientExports) return [3, 2];
                            return [4, this.localState.addExportedVariables(mutation, variables, context)];
                        case 1:
                            variables = _f.sent();
                            _f.label = 2;
                        case 2:
                            generateUpdateQueriesInfo = function () {
                                var ret = {};
                                if (updateQueriesByName) {
                                    _this.queries.forEach(function (_a, queryId) {
                                        var observableQuery = _a.observableQuery;
                                        if (observableQuery) {
                                            var queryName = observableQuery.queryName;
                                            if (queryName &&
                                                hasOwnProperty$2.call(updateQueriesByName, queryName)) {
                                                ret[queryId] = {
                                                    updater: updateQueriesByName[queryName],
                                                    query: _this.queryStore.get(queryId),
                                                };
                                            }
                                        }
                                    });
                                }
                                return ret;
                            };
                            this.mutationStore.initMutation(mutationId, mutation, variables);
                            this.dataStore.markMutationInit({
                                mutationId: mutationId,
                                document: mutation,
                                variables: variables,
                                updateQueries: generateUpdateQueriesInfo(),
                                update: updateWithProxyFn,
                                optimisticResponse: optimisticResponse,
                            });
                            this.broadcastQueries();
                            self = this;
                            return [2, new Promise(function (resolve, reject) {
                                    var storeResult;
                                    var error;
                                    self.getObservableFromLink(mutation, __assign({}, context, { optimisticResponse: optimisticResponse }), variables, false).subscribe({
                                        next: function (result) {
                                            if (graphQLResultHasError(result) && errorPolicy === 'none') {
                                                error = new ApolloError({
                                                    graphQLErrors: result.errors,
                                                });
                                                return;
                                            }
                                            self.mutationStore.markMutationResult(mutationId);
                                            if (fetchPolicy !== 'no-cache') {
                                                self.dataStore.markMutationResult({
                                                    mutationId: mutationId,
                                                    result: result,
                                                    document: mutation,
                                                    variables: variables,
                                                    updateQueries: generateUpdateQueriesInfo(),
                                                    update: updateWithProxyFn,
                                                });
                                            }
                                            storeResult = result;
                                        },
                                        error: function (err) {
                                            self.mutationStore.markMutationError(mutationId, err);
                                            self.dataStore.markMutationComplete({
                                                mutationId: mutationId,
                                                optimisticResponse: optimisticResponse,
                                            });
                                            self.broadcastQueries();
                                            self.setQuery(mutationId, function () { return ({ document: null }); });
                                            reject(new ApolloError({
                                                networkError: err,
                                            }));
                                        },
                                        complete: function () {
                                            if (error) {
                                                self.mutationStore.markMutationError(mutationId, error);
                                            }
                                            self.dataStore.markMutationComplete({
                                                mutationId: mutationId,
                                                optimisticResponse: optimisticResponse,
                                            });
                                            self.broadcastQueries();
                                            if (error) {
                                                reject(error);
                                                return;
                                            }
                                            if (typeof refetchQueries === 'function') {
                                                refetchQueries = refetchQueries(storeResult);
                                            }
                                            var refetchQueryPromises = [];
                                            if (isNonEmptyArray(refetchQueries)) {
                                                refetchQueries.forEach(function (refetchQuery) {
                                                    if (typeof refetchQuery === 'string') {
                                                        self.queries.forEach(function (_a) {
                                                            var observableQuery = _a.observableQuery;
                                                            if (observableQuery &&
                                                                observableQuery.queryName === refetchQuery) {
                                                                refetchQueryPromises.push(observableQuery.refetch());
                                                            }
                                                        });
                                                    }
                                                    else {
                                                        var queryOptions = {
                                                            query: refetchQuery.query,
                                                            variables: refetchQuery.variables,
                                                            fetchPolicy: 'network-only',
                                                        };
                                                        if (refetchQuery.context) {
                                                            queryOptions.context = refetchQuery.context;
                                                        }
                                                        refetchQueryPromises.push(self.query(queryOptions));
                                                    }
                                                });
                                            }
                                            Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {
                                                self.setQuery(mutationId, function () { return ({ document: null }); });
                                                if (errorPolicy === 'ignore' &&
                                                    storeResult &&
                                                    graphQLResultHasError(storeResult)) {
                                                    delete storeResult.errors;
                                                }
                                                resolve(storeResult);
                                            });
                                        },
                                    });
                                })];
                    }
                });
            });
        };
        QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, metadata, _b, fetchPolicy, _c, context, query, variables, storeResult, isNetworkOnly, needToFetch, _d, complete, result, shouldFetch, requestId, cancel, networkResult;
                var _this = this;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            _a = options.metadata, metadata = _a === void 0 ? null : _a, _b = options.fetchPolicy, fetchPolicy = _b === void 0 ? 'cache-first' : _b, _c = options.context, context = _c === void 0 ? {} : _c;
                            query = this.transform(options.query).document;
                            variables = this.getVariables(query, options.variables);
                            if (!this.transform(query).hasClientExports) return [3, 2];
                            return [4, this.localState.addExportedVariables(query, variables, context)];
                        case 1:
                            variables = _e.sent();
                            _e.label = 2;
                        case 2:
                            options = __assign({}, options, { variables: variables });
                            isNetworkOnly = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';
                            needToFetch = isNetworkOnly;
                            if (!isNetworkOnly) {
                                _d = this.dataStore.getCache().diff({
                                    query: query,
                                    variables: variables,
                                    returnPartialData: true,
                                    optimistic: false,
                                }), complete = _d.complete, result = _d.result;
                                needToFetch = !complete || fetchPolicy === 'cache-and-network';
                                storeResult = result;
                            }
                            shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';
                            if (hasDirectives(['live'], query))
                                shouldFetch = true;
                            requestId = this.idCounter++;
                            cancel = fetchPolicy !== 'no-cache'
                                ? this.updateQueryWatch(queryId, query, options)
                                : undefined;
                            this.setQuery(queryId, function () { return ({
                                document: query,
                                lastRequestId: requestId,
                                invalidated: true,
                                cancel: cancel,
                            }); });
                            this.invalidate(fetchMoreForQueryId);
                            this.queryStore.initQuery({
                                queryId: queryId,
                                document: query,
                                storePreviousVariables: shouldFetch,
                                variables: variables,
                                isPoll: fetchType === FetchType.poll,
                                isRefetch: fetchType === FetchType.refetch,
                                metadata: metadata,
                                fetchMoreForQueryId: fetchMoreForQueryId,
                            });
                            this.broadcastQueries();
                            if (shouldFetch) {
                                networkResult = this.fetchRequest({
                                    requestId: requestId,
                                    queryId: queryId,
                                    document: query,
                                    options: options,
                                    fetchMoreForQueryId: fetchMoreForQueryId,
                                }).catch(function (error) {
                                    if (isApolloError(error)) {
                                        throw error;
                                    }
                                    else {
                                        if (requestId >= _this.getQuery(queryId).lastRequestId) {
                                            _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);
                                            _this.invalidate(queryId);
                                            _this.invalidate(fetchMoreForQueryId);
                                            _this.broadcastQueries();
                                        }
                                        throw new ApolloError({ networkError: error });
                                    }
                                });
                                if (fetchPolicy !== 'cache-and-network') {
                                    return [2, networkResult];
                                }
                                networkResult.catch(function () { });
                            }
                            this.queryStore.markQueryResultClient(queryId, !shouldFetch);
                            this.invalidate(queryId);
                            this.invalidate(fetchMoreForQueryId);
                            if (this.transform(query).hasForcedResolvers) {
                                return [2, this.localState.runResolvers({
                                        document: query,
                                        remoteResult: { data: storeResult },
                                        context: context,
                                        variables: variables,
                                        onlyRunForcedResolvers: true,
                                    }).then(function (result) {
                                        _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);
                                        _this.broadcastQueries();
                                        return result;
                                    })];
                            }
                            this.broadcastQueries();
                            return [2, { data: storeResult }];
                    }
                });
            });
        };
        QueryManager.prototype.markQueryResult = function (queryId, result, _a, fetchMoreForQueryId) {
            var fetchPolicy = _a.fetchPolicy, variables = _a.variables, errorPolicy = _a.errorPolicy;
            if (fetchPolicy === 'no-cache') {
                this.setQuery(queryId, function () { return ({
                    newData: { result: result.data, complete: true },
                }); });
            }
            else {
                this.dataStore.markQueryResult(result, this.getQuery(queryId).document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');
            }
        };
        QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {
            var _this = this;
            function invoke(method, argument) {
                if (observer[method]) {
                    try {
                        observer[method](argument);
                    }
                    catch (e) {
                        process.env.NODE_ENV === "production" || invariant.error(e);
                    }
                }
                else if (method === 'error') {
                    process.env.NODE_ENV === "production" || invariant.error(argument);
                }
            }
            return function (queryStoreValue, newData) {
                _this.invalidate(queryId, false);
                if (!queryStoreValue)
                    return;
                var _a = _this.getQuery(queryId), observableQuery = _a.observableQuery, document = _a.document;
                var fetchPolicy = observableQuery
                    ? observableQuery.options.fetchPolicy
                    : options.fetchPolicy;
                if (fetchPolicy === 'standby')
                    return;
                var loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);
                var lastResult = observableQuery && observableQuery.getLastResult();
                var networkStatusChanged = !!(lastResult &&
                    lastResult.networkStatus !== queryStoreValue.networkStatus);
                var shouldNotifyIfLoading = options.returnPartialData ||
                    (!newData && queryStoreValue.previousVariables) ||
                    (networkStatusChanged && options.notifyOnNetworkStatusChange) ||
                    fetchPolicy === 'cache-only' ||
                    fetchPolicy === 'cache-and-network';
                if (loading && !shouldNotifyIfLoading) {
                    return;
                }
                var hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);
                var errorPolicy = observableQuery
                    && observableQuery.options.errorPolicy
                    || options.errorPolicy
                    || 'none';
                if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {
                    return invoke('error', new ApolloError({
                        graphQLErrors: queryStoreValue.graphQLErrors,
                        networkError: queryStoreValue.networkError,
                    }));
                }
                try {
                    var data = void 0;
                    var isMissing = void 0;
                    if (newData) {
                        if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {
                            _this.setQuery(queryId, function () { return ({ newData: null }); });
                        }
                        data = newData.result;
                        isMissing = !newData.complete;
                    }
                    else {
                        var lastError = observableQuery && observableQuery.getLastError();
                        var errorStatusChanged = errorPolicy !== 'none' &&
                            (lastError && lastError.graphQLErrors) !==
                                queryStoreValue.graphQLErrors;
                        if (lastResult && lastResult.data && !errorStatusChanged) {
                            data = lastResult.data;
                            isMissing = false;
                        }
                        else {
                            var diffResult = _this.dataStore.getCache().diff({
                                query: document,
                                variables: queryStoreValue.previousVariables ||
                                    queryStoreValue.variables,
                                returnPartialData: true,
                                optimistic: true,
                            });
                            data = diffResult.result;
                            isMissing = !diffResult.complete;
                        }
                    }
                    var stale = isMissing && !(options.returnPartialData ||
                        fetchPolicy === 'cache-only');
                    var resultFromStore = {
                        data: stale ? lastResult && lastResult.data : data,
                        loading: loading,
                        networkStatus: queryStoreValue.networkStatus,
                        stale: stale,
                    };
                    if (errorPolicy === 'all' && hasGraphQLErrors) {
                        resultFromStore.errors = queryStoreValue.graphQLErrors;
                    }
                    invoke('next', resultFromStore);
                }
                catch (networkError) {
                    invoke('error', new ApolloError({ networkError: networkError }));
                }
            };
        };
        QueryManager.prototype.transform = function (document) {
            var transformCache = this.transformCache;
            if (!transformCache.has(document)) {
                var cache = this.dataStore.getCache();
                var transformed = cache.transformDocument(document);
                var forLink = removeConnectionDirectiveFromDocument(cache.transformForLink(transformed));
                var clientQuery = this.localState.clientQuery(transformed);
                var serverQuery = this.localState.serverQuery(forLink);
                var cacheEntry_1 = {
                    document: transformed,
                    hasClientExports: hasClientExports(transformed),
                    hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
                    clientQuery: clientQuery,
                    serverQuery: serverQuery,
                    defaultVars: getDefaultValues(getOperationDefinition(transformed)),
                };
                var add = function (doc) {
                    if (doc && !transformCache.has(doc)) {
                        transformCache.set(doc, cacheEntry_1);
                    }
                };
                add(document);
                add(transformed);
                add(clientQuery);
                add(serverQuery);
            }
            return transformCache.get(document);
        };
        QueryManager.prototype.getVariables = function (document, variables) {
            return __assign({}, this.transform(document).defaultVars, variables);
        };
        QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {
            if (shouldSubscribe === void 0) { shouldSubscribe = true; }
            process.env.NODE_ENV === "production" ? invariant(options.fetchPolicy !== 'standby', 9) : invariant(options.fetchPolicy !== 'standby', 'client.watchQuery cannot be called with fetchPolicy set to "standby"');
            options.variables = this.getVariables(options.query, options.variables);
            if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
                options.notifyOnNetworkStatusChange = false;
            }
            var transformedOptions = __assign({}, options);
            return new ObservableQuery({
                queryManager: this,
                options: transformedOptions,
                shouldSubscribe: shouldSubscribe,
            });
        };
        QueryManager.prototype.query = function (options) {
            var _this = this;
            process.env.NODE_ENV === "production" ? invariant(options.query, 10) : invariant(options.query, 'query option is required. You must specify your GraphQL document ' +
                'in the query option.');
            process.env.NODE_ENV === "production" ? invariant(options.query.kind === 'Document', 11) : invariant(options.query.kind === 'Document', 'You must wrap the query string in a "gql" tag.');
            process.env.NODE_ENV === "production" ? invariant(!options.returnPartialData, 12) : invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.');
            process.env.NODE_ENV === "production" ? invariant(!options.pollInterval, 13) : invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.');
            return new Promise(function (resolve, reject) {
                var watchedQuery = _this.watchQuery(options, false);
                _this.fetchQueryRejectFns.set("query:" + watchedQuery.queryId, reject);
                watchedQuery
                    .result()
                    .then(resolve, reject)
                    .then(function () {
                    return _this.fetchQueryRejectFns.delete("query:" + watchedQuery.queryId);
                });
            });
        };
        QueryManager.prototype.generateQueryId = function () {
            return String(this.idCounter++);
        };
        QueryManager.prototype.stopQueryInStore = function (queryId) {
            this.stopQueryInStoreNoBroadcast(queryId);
            this.broadcastQueries();
        };
        QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {
            this.stopPollingQuery(queryId);
            this.queryStore.stopQuery(queryId);
            this.invalidate(queryId);
        };
        QueryManager.prototype.addQueryListener = function (queryId, listener) {
            this.setQuery(queryId, function (_a) {
                var listeners = _a.listeners;
                listeners.add(listener);
                return { invalidated: false };
            });
        };
        QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {
            var _this = this;
            var cancel = this.getQuery(queryId).cancel;
            if (cancel)
                cancel();
            var previousResult = function () {
                var previousResult = null;
                var observableQuery = _this.getQuery(queryId).observableQuery;
                if (observableQuery) {
                    var lastResult = observableQuery.getLastResult();
                    if (lastResult) {
                        previousResult = lastResult.data;
                    }
                }
                return previousResult;
            };
            return this.dataStore.getCache().watch({
                query: document,
                variables: options.variables,
                optimistic: true,
                previousResult: previousResult,
                callback: function (newData) {
                    _this.setQuery(queryId, function () { return ({ invalidated: true, newData: newData }); });
                },
            });
        };
        QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {
            this.setQuery(queryId, function () { return ({ observableQuery: observableQuery }); });
        };
        QueryManager.prototype.removeObservableQuery = function (queryId) {
            var cancel = this.getQuery(queryId).cancel;
            this.setQuery(queryId, function () { return ({ observableQuery: null }); });
            if (cancel)
                cancel();
        };
        QueryManager.prototype.clearStore = function () {
            this.fetchQueryRejectFns.forEach(function (reject) {
                reject(process.env.NODE_ENV === "production" ? new InvariantError(14) : new InvariantError('Store reset while query was in flight (not completed in link chain)'));
            });
            var resetIds = [];
            this.queries.forEach(function (_a, queryId) {
                var observableQuery = _a.observableQuery;
                if (observableQuery)
                    resetIds.push(queryId);
            });
            this.queryStore.reset(resetIds);
            this.mutationStore.reset();
            return this.dataStore.reset();
        };
        QueryManager.prototype.resetStore = function () {
            var _this = this;
            return this.clearStore().then(function () {
                return _this.reFetchObservableQueries();
            });
        };
        QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
            var _this = this;
            if (includeStandby === void 0) { includeStandby = false; }
            var observableQueryPromises = [];
            this.queries.forEach(function (_a, queryId) {
                var observableQuery = _a.observableQuery;
                if (observableQuery) {
                    var fetchPolicy = observableQuery.options.fetchPolicy;
                    observableQuery.resetLastResults();
                    if (fetchPolicy !== 'cache-only' &&
                        (includeStandby || fetchPolicy !== 'standby')) {
                        observableQueryPromises.push(observableQuery.refetch());
                    }
                    _this.setQuery(queryId, function () { return ({ newData: null }); });
                    _this.invalidate(queryId);
                }
            });
            this.broadcastQueries();
            return Promise.all(observableQueryPromises);
        };
        QueryManager.prototype.observeQuery = function (queryId, options, observer) {
            this.addQueryListener(queryId, this.queryListenerForObserver(queryId, options, observer));
            return this.fetchQuery(queryId, options);
        };
        QueryManager.prototype.startQuery = function (queryId, options, listener) {
            process.env.NODE_ENV === "production" || invariant.warn("The QueryManager.startQuery method has been deprecated");
            this.addQueryListener(queryId, listener);
            this.fetchQuery(queryId, options)
                .catch(function () { return undefined; });
            return queryId;
        };
        QueryManager.prototype.startGraphQLSubscription = function (_a) {
            var _this = this;
            var query = _a.query, fetchPolicy = _a.fetchPolicy, variables = _a.variables;
            query = this.transform(query).document;
            variables = this.getVariables(query, variables);
            var makeObservable = function (variables) {
                return _this.getObservableFromLink(query, {}, variables, false).map(function (result) {
                    if (!fetchPolicy || fetchPolicy !== 'no-cache') {
                        _this.dataStore.markSubscriptionResult(result, query, variables);
                        _this.broadcastQueries();
                    }
                    if (graphQLResultHasError(result)) {
                        throw new ApolloError({
                            graphQLErrors: result.errors,
                        });
                    }
                    return result;
                });
            };
            if (this.transform(query).hasClientExports) {
                var observablePromise_1 = this.localState.addExportedVariables(query, variables).then(makeObservable);
                return new Observable$1(function (observer) {
                    var sub = null;
                    observablePromise_1.then(function (observable) { return sub = observable.subscribe(observer); }, observer.error);
                    return function () { return sub && sub.unsubscribe(); };
                });
            }
            return makeObservable(variables);
        };
        QueryManager.prototype.stopQuery = function (queryId) {
            this.stopQueryNoBroadcast(queryId);
            this.broadcastQueries();
        };
        QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {
            this.stopQueryInStoreNoBroadcast(queryId);
            this.removeQuery(queryId);
        };
        QueryManager.prototype.removeQuery = function (queryId) {
            this.fetchQueryRejectFns.delete("query:" + queryId);
            this.fetchQueryRejectFns.delete("fetchRequest:" + queryId);
            this.getQuery(queryId).subscriptions.forEach(function (x) { return x.unsubscribe(); });
            this.queries.delete(queryId);
        };
        QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {
            if (optimistic === void 0) { optimistic = true; }
            var _a = observableQuery.options, variables = _a.variables, query = _a.query, fetchPolicy = _a.fetchPolicy, returnPartialData = _a.returnPartialData;
            var lastResult = observableQuery.getLastResult();
            var newData = this.getQuery(observableQuery.queryId).newData;
            if (newData && newData.complete) {
                return { data: newData.result, partial: false };
            }
            if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {
                return { data: undefined, partial: false };
            }
            var _b = this.dataStore.getCache().diff({
                query: query,
                variables: variables,
                previousResult: lastResult ? lastResult.data : undefined,
                returnPartialData: true,
                optimistic: optimistic,
            }), result = _b.result, complete = _b.complete;
            return {
                data: (complete || returnPartialData) ? result : void 0,
                partial: !complete,
            };
        };
        QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {
            var observableQuery;
            if (typeof queryIdOrObservable === 'string') {
                var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;
                process.env.NODE_ENV === "production" ? invariant(foundObserveableQuery, 15) : invariant(foundObserveableQuery, "ObservableQuery with this id doesn't exist: " + queryIdOrObservable);
                observableQuery = foundObserveableQuery;
            }
            else {
                observableQuery = queryIdOrObservable;
            }
            var _a = observableQuery.options, variables = _a.variables, query = _a.query;
            return {
                previousResult: this.getCurrentQueryResult(observableQuery, false).data,
                variables: variables,
                document: query,
            };
        };
        QueryManager.prototype.broadcastQueries = function () {
            var _this = this;
            this.onBroadcast();
            this.queries.forEach(function (info, id) {
                if (info.invalidated) {
                    info.listeners.forEach(function (listener) {
                        if (listener) {
                            listener(_this.queryStore.get(id), info.newData);
                        }
                    });
                }
            });
        };
        QueryManager.prototype.getLocalState = function () {
            return this.localState;
        };
        QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {
            var _this = this;
            if (deduplication === void 0) { deduplication = this.queryDeduplication; }
            var observable;
            var serverQuery = this.transform(query).serverQuery;
            if (serverQuery) {
                var _a = this, inFlightLinkObservables_1 = _a.inFlightLinkObservables, link = _a.link;
                var operation = {
                    query: serverQuery,
                    variables: variables,
                    operationName: getOperationName(serverQuery) || void 0,
                    context: this.prepareContext(__assign({}, context, { forceFetch: !deduplication })),
                };
                context = operation.context;
                if (deduplication) {
                    var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
                    inFlightLinkObservables_1.set(serverQuery, byVariables_1);
                    var varJson_1 = JSON.stringify(variables);
                    observable = byVariables_1.get(varJson_1);
                    if (!observable) {
                        byVariables_1.set(varJson_1, observable = multiplex(execute(link, operation)));
                        var cleanup = function () {
                            byVariables_1.delete(varJson_1);
                            if (!byVariables_1.size)
                                inFlightLinkObservables_1.delete(serverQuery);
                            cleanupSub_1.unsubscribe();
                        };
                        var cleanupSub_1 = observable.subscribe({
                            next: cleanup,
                            error: cleanup,
                            complete: cleanup,
                        });
                    }
                }
                else {
                    observable = multiplex(execute(link, operation));
                }
            }
            else {
                observable = Observable$1.of({ data: {} });
                context = this.prepareContext(context);
            }
            var clientQuery = this.transform(query).clientQuery;
            if (clientQuery) {
                observable = asyncMap(observable, function (result) {
                    return _this.localState.runResolvers({
                        document: clientQuery,
                        remoteResult: result,
                        context: context,
                        variables: variables,
                    });
                });
            }
            return observable;
        };
        QueryManager.prototype.fetchRequest = function (_a) {
            var _this = this;
            var requestId = _a.requestId, queryId = _a.queryId, document = _a.document, options = _a.options, fetchMoreForQueryId = _a.fetchMoreForQueryId;
            var variables = options.variables, _b = options.errorPolicy, errorPolicy = _b === void 0 ? 'none' : _b, fetchPolicy = options.fetchPolicy;
            var resultFromStore;
            var errorsFromStore;
            return new Promise(function (resolve, reject) {
                var observable = _this.getObservableFromLink(document, options.context, variables);
                var fqrfId = "fetchRequest:" + queryId;
                _this.fetchQueryRejectFns.set(fqrfId, reject);
                var cleanup = function () {
                    _this.fetchQueryRejectFns.delete(fqrfId);
                    _this.setQuery(queryId, function (_a) {
                        var subscriptions = _a.subscriptions;
                        subscriptions.delete(subscription);
                    });
                };
                var subscription = observable.map(function (result) {
                    if (requestId >= _this.getQuery(queryId).lastRequestId) {
                        _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);
                        _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);
                        _this.invalidate(queryId);
                        _this.invalidate(fetchMoreForQueryId);
                        _this.broadcastQueries();
                    }
                    if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {
                        return reject(new ApolloError({
                            graphQLErrors: result.errors,
                        }));
                    }
                    if (errorPolicy === 'all') {
                        errorsFromStore = result.errors;
                    }
                    if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {
                        resultFromStore = result.data;
                    }
                    else {
                        var _a = _this.dataStore.getCache().diff({
                            variables: variables,
                            query: document,
                            optimistic: false,
                            returnPartialData: true,
                        }), result_1 = _a.result, complete = _a.complete;
                        if (complete || options.returnPartialData) {
                            resultFromStore = result_1;
                        }
                    }
                }).subscribe({
                    error: function (error) {
                        cleanup();
                        reject(error);
                    },
                    complete: function () {
                        cleanup();
                        resolve({
                            data: resultFromStore,
                            errors: errorsFromStore,
                            loading: false,
                            networkStatus: NetworkStatus.ready,
                            stale: false,
                        });
                    },
                });
                _this.setQuery(queryId, function (_a) {
                    var subscriptions = _a.subscriptions;
                    subscriptions.add(subscription);
                });
            });
        };
        QueryManager.prototype.getQuery = function (queryId) {
            return (this.queries.get(queryId) || {
                listeners: new Set(),
                invalidated: false,
                document: null,
                newData: null,
                lastRequestId: 1,
                observableQuery: null,
                subscriptions: new Set(),
            });
        };
        QueryManager.prototype.setQuery = function (queryId, updater) {
            var prev = this.getQuery(queryId);
            var newInfo = __assign({}, prev, updater(prev));
            this.queries.set(queryId, newInfo);
        };
        QueryManager.prototype.invalidate = function (queryId, invalidated) {
            if (invalidated === void 0) { invalidated = true; }
            if (queryId) {
                this.setQuery(queryId, function () { return ({ invalidated: invalidated }); });
            }
        };
        QueryManager.prototype.prepareContext = function (context) {
            if (context === void 0) { context = {}; }
            var newContext = this.localState.prepareContext(context);
            return __assign({}, newContext, { clientAwareness: this.clientAwareness });
        };
        QueryManager.prototype.checkInFlight = function (queryId) {
            var query = this.queryStore.get(queryId);
            return (query &&
                query.networkStatus !== NetworkStatus.ready &&
                query.networkStatus !== NetworkStatus.error);
        };
        QueryManager.prototype.startPollingQuery = function (options, queryId, listener) {
            var _this = this;
            var pollInterval = options.pollInterval;
            process.env.NODE_ENV === "production" ? invariant(pollInterval, 16) : invariant(pollInterval, 'Attempted to start a polling query without a polling interval.');
            if (!this.ssrMode) {
                var info = this.pollingInfoByQueryId.get(queryId);
                if (!info) {
                    this.pollingInfoByQueryId.set(queryId, (info = {}));
                }
                info.interval = pollInterval;
                info.options = __assign({}, options, { fetchPolicy: 'network-only' });
                var maybeFetch_1 = function () {
                    var info = _this.pollingInfoByQueryId.get(queryId);
                    if (info) {
                        if (_this.checkInFlight(queryId)) {
                            poll_1();
                        }
                        else {
                            _this.fetchQuery(queryId, info.options, FetchType.poll).then(poll_1, poll_1);
                        }
                    }
                };
                var poll_1 = function () {
                    var info = _this.pollingInfoByQueryId.get(queryId);
                    if (info) {
                        clearTimeout(info.timeout);
                        info.timeout = setTimeout(maybeFetch_1, info.interval);
                    }
                };
                if (listener) {
                    this.addQueryListener(queryId, listener);
                }
                poll_1();
            }
            return queryId;
        };
        QueryManager.prototype.stopPollingQuery = function (queryId) {
            this.pollingInfoByQueryId.delete(queryId);
        };
        return QueryManager;
    }());

    var DataStore = (function () {
        function DataStore(initialCache) {
            this.cache = initialCache;
        }
        DataStore.prototype.getCache = function () {
            return this.cache;
        };
        DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {
            if (ignoreErrors === void 0) { ignoreErrors = false; }
            var writeWithErrors = !graphQLResultHasError(result);
            if (ignoreErrors && graphQLResultHasError(result) && result.data) {
                writeWithErrors = true;
            }
            if (!fetchMoreForQueryId && writeWithErrors) {
                this.cache.write({
                    result: result.data,
                    dataId: 'ROOT_QUERY',
                    query: document,
                    variables: variables,
                });
            }
        };
        DataStore.prototype.markSubscriptionResult = function (result, document, variables) {
            if (!graphQLResultHasError(result)) {
                this.cache.write({
                    result: result.data,
                    dataId: 'ROOT_SUBSCRIPTION',
                    query: document,
                    variables: variables,
                });
            }
        };
        DataStore.prototype.markMutationInit = function (mutation) {
            var _this = this;
            if (mutation.optimisticResponse) {
                var optimistic_1;
                if (typeof mutation.optimisticResponse === 'function') {
                    optimistic_1 = mutation.optimisticResponse(mutation.variables);
                }
                else {
                    optimistic_1 = mutation.optimisticResponse;
                }
                this.cache.recordOptimisticTransaction(function (c) {
                    var orig = _this.cache;
                    _this.cache = c;
                    try {
                        _this.markMutationResult({
                            mutationId: mutation.mutationId,
                            result: { data: optimistic_1 },
                            document: mutation.document,
                            variables: mutation.variables,
                            updateQueries: mutation.updateQueries,
                            update: mutation.update,
                        });
                    }
                    finally {
                        _this.cache = orig;
                    }
                }, mutation.mutationId);
            }
        };
        DataStore.prototype.markMutationResult = function (mutation) {
            var _this = this;
            if (!graphQLResultHasError(mutation.result)) {
                var cacheWrites_1 = [{
                        result: mutation.result.data,
                        dataId: 'ROOT_MUTATION',
                        query: mutation.document,
                        variables: mutation.variables,
                    }];
                var updateQueries_1 = mutation.updateQueries;
                if (updateQueries_1) {
                    Object.keys(updateQueries_1).forEach(function (id) {
                        var _a = updateQueries_1[id], query = _a.query, updater = _a.updater;
                        var _b = _this.cache.diff({
                            query: query.document,
                            variables: query.variables,
                            returnPartialData: true,
                            optimistic: false,
                        }), currentQueryResult = _b.result, complete = _b.complete;
                        if (complete) {
                            var nextQueryResult = tryFunctionOrLogError(function () {
                                return updater(currentQueryResult, {
                                    mutationResult: mutation.result,
                                    queryName: getOperationName(query.document) || undefined,
                                    queryVariables: query.variables,
                                });
                            });
                            if (nextQueryResult) {
                                cacheWrites_1.push({
                                    result: nextQueryResult,
                                    dataId: 'ROOT_QUERY',
                                    query: query.document,
                                    variables: query.variables,
                                });
                            }
                        }
                    });
                }
                this.cache.performTransaction(function (c) {
                    cacheWrites_1.forEach(function (write) { return c.write(write); });
                    var update = mutation.update;
                    if (update) {
                        tryFunctionOrLogError(function () { return update(c, mutation.result); });
                    }
                });
            }
        };
        DataStore.prototype.markMutationComplete = function (_a) {
            var mutationId = _a.mutationId, optimisticResponse = _a.optimisticResponse;
            if (optimisticResponse) {
                this.cache.removeOptimistic(mutationId);
            }
        };
        DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {
            this.cache.write({
                result: newResult,
                dataId: 'ROOT_QUERY',
                variables: variables,
                query: document,
            });
        };
        DataStore.prototype.reset = function () {
            return this.cache.reset();
        };
        return DataStore;
    }());

    var version = "2.6.3";

    var hasSuggestedDevtools = false;
    var ApolloClient = (function () {
        function ApolloClient(options) {
            var _this = this;
            this.defaultOptions = {};
            this.resetStoreCallbacks = [];
            this.clearStoreCallbacks = [];
            var cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions = options.defaultOptions, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? false : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
            var link = options.link;
            if (!link && resolvers) {
                link = ApolloLink.empty();
            }
            if (!link || !cache) {
                throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError("In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\n" +
                    "These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\n" +
                    "For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup");
            }
            this.link = link;
            this.cache = cache;
            this.store = new DataStore(cache);
            this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
            this.queryDeduplication = queryDeduplication;
            this.defaultOptions = defaultOptions || {};
            this.typeDefs = typeDefs;
            if (ssrForceFetchDelay) {
                setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);
            }
            this.watchQuery = this.watchQuery.bind(this);
            this.query = this.query.bind(this);
            this.mutate = this.mutate.bind(this);
            this.resetStore = this.resetStore.bind(this);
            this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
            var defaultConnectToDevTools = process.env.NODE_ENV !== 'production' &&
                typeof window !== 'undefined' &&
                !window.__APOLLO_CLIENT__;
            if (typeof connectToDevTools === 'undefined'
                ? defaultConnectToDevTools
                : connectToDevTools && typeof window !== 'undefined') {
                window.__APOLLO_CLIENT__ = this;
            }
            if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {
                hasSuggestedDevtools = true;
                if (typeof window !== 'undefined' &&
                    window.document &&
                    window.top === window.self) {
                    if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                        if (window.navigator &&
                            window.navigator.userAgent &&
                            window.navigator.userAgent.indexOf('Chrome') > -1) {
                            console.debug('Download the Apollo DevTools ' +
                                'for a better development experience: ' +
                                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');
                        }
                    }
                }
            }
            this.version = version;
            this.localState = new LocalState({
                cache: cache,
                client: this,
                resolvers: resolvers,
                fragmentMatcher: fragmentMatcher,
            });
            this.queryManager = new QueryManager({
                link: this.link,
                store: this.store,
                queryDeduplication: queryDeduplication,
                ssrMode: ssrMode,
                clientAwareness: {
                    name: clientAwarenessName,
                    version: clientAwarenessVersion,
                },
                localState: this.localState,
                assumeImmutableResults: assumeImmutableResults,
                onBroadcast: function () {
                    if (_this.devToolsHookCb) {
                        _this.devToolsHookCb({
                            action: {},
                            state: {
                                queries: _this.queryManager.queryStore.getStore(),
                                mutations: _this.queryManager.mutationStore.getStore(),
                            },
                            dataWithOptimisticResults: _this.cache.extract(true),
                        });
                    }
                },
            });
        }
        ApolloClient.prototype.stop = function () {
            this.queryManager.stop();
        };
        ApolloClient.prototype.watchQuery = function (options) {
            if (this.defaultOptions.watchQuery) {
                options = __assign({}, this.defaultOptions.watchQuery, options);
            }
            if (this.disableNetworkFetches &&
                (options.fetchPolicy === 'network-only' ||
                    options.fetchPolicy === 'cache-and-network')) {
                options = __assign({}, options, { fetchPolicy: 'cache-first' });
            }
            return this.queryManager.watchQuery(options);
        };
        ApolloClient.prototype.query = function (options) {
            if (this.defaultOptions.query) {
                options = __assign({}, this.defaultOptions.query, options);
            }
            process.env.NODE_ENV === "production" ? invariant(options.fetchPolicy !== 'cache-and-network', 2) : invariant(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' +
                'client.query can only return a single result. Please use client.watchQuery ' +
                'to receive multiple results from the cache and the network, or consider ' +
                'using a different fetchPolicy, such as cache-first or network-only.');
            if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
                options = __assign({}, options, { fetchPolicy: 'cache-first' });
            }
            return this.queryManager.query(options);
        };
        ApolloClient.prototype.mutate = function (options) {
            if (this.defaultOptions.mutate) {
                options = __assign({}, this.defaultOptions.mutate, options);
            }
            return this.queryManager.mutate(options);
        };
        ApolloClient.prototype.subscribe = function (options) {
            return this.queryManager.startGraphQLSubscription(options);
        };
        ApolloClient.prototype.readQuery = function (options, optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return this.cache.readQuery(options, optimistic);
        };
        ApolloClient.prototype.readFragment = function (options, optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return this.cache.readFragment(options, optimistic);
        };
        ApolloClient.prototype.writeQuery = function (options) {
            var result = this.cache.writeQuery(options);
            this.queryManager.broadcastQueries();
            return result;
        };
        ApolloClient.prototype.writeFragment = function (options) {
            var result = this.cache.writeFragment(options);
            this.queryManager.broadcastQueries();
            return result;
        };
        ApolloClient.prototype.writeData = function (options) {
            var result = this.cache.writeData(options);
            this.queryManager.broadcastQueries();
            return result;
        };
        ApolloClient.prototype.__actionHookForDevTools = function (cb) {
            this.devToolsHookCb = cb;
        };
        ApolloClient.prototype.__requestRaw = function (payload) {
            return execute(this.link, payload);
        };
        ApolloClient.prototype.initQueryManager = function () {
            process.env.NODE_ENV === "production" || invariant.warn('Calling the initQueryManager method is no longer necessary, ' +
                'and it will be removed from ApolloClient in version 3.0.');
            return this.queryManager;
        };
        ApolloClient.prototype.resetStore = function () {
            var _this = this;
            return Promise.resolve()
                .then(function () { return _this.queryManager.clearStore(); })
                .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })
                .then(function () { return _this.reFetchObservableQueries(); });
        };
        ApolloClient.prototype.clearStore = function () {
            var _this = this;
            return Promise.resolve()
                .then(function () { return _this.queryManager.clearStore(); })
                .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });
        };
        ApolloClient.prototype.onResetStore = function (cb) {
            var _this = this;
            this.resetStoreCallbacks.push(cb);
            return function () {
                _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });
            };
        };
        ApolloClient.prototype.onClearStore = function (cb) {
            var _this = this;
            this.clearStoreCallbacks.push(cb);
            return function () {
                _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });
            };
        };
        ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
            return this.queryManager.reFetchObservableQueries(includeStandby);
        };
        ApolloClient.prototype.extract = function (optimistic) {
            return this.cache.extract(optimistic);
        };
        ApolloClient.prototype.restore = function (serializedState) {
            return this.cache.restore(serializedState);
        };
        ApolloClient.prototype.addResolvers = function (resolvers) {
            this.localState.addResolvers(resolvers);
        };
        ApolloClient.prototype.setResolvers = function (resolvers) {
            this.localState.setResolvers(resolvers);
        };
        ApolloClient.prototype.getResolvers = function () {
            return this.localState.getResolvers();
        };
        ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {
            this.localState.setFragmentMatcher(fragmentMatcher);
        };
        return ApolloClient;
    }());
    //# sourceMappingURL=bundle.esm.js.map

    function queryFromPojo(obj) {
        var op = {
            kind: 'OperationDefinition',
            operation: 'query',
            name: {
                kind: 'Name',
                value: 'GeneratedClientQuery',
            },
            selectionSet: selectionSetFromObj(obj),
        };
        var out = {
            kind: 'Document',
            definitions: [op],
        };
        return out;
    }
    function fragmentFromPojo(obj, typename) {
        var frag = {
            kind: 'FragmentDefinition',
            typeCondition: {
                kind: 'NamedType',
                name: {
                    kind: 'Name',
                    value: typename || '__FakeType',
                },
            },
            name: {
                kind: 'Name',
                value: 'GeneratedClientQuery',
            },
            selectionSet: selectionSetFromObj(obj),
        };
        var out = {
            kind: 'Document',
            definitions: [frag],
        };
        return out;
    }
    function selectionSetFromObj(obj) {
        if (typeof obj === 'number' ||
            typeof obj === 'boolean' ||
            typeof obj === 'string' ||
            typeof obj === 'undefined' ||
            obj === null) {
            return null;
        }
        if (Array.isArray(obj)) {
            return selectionSetFromObj(obj[0]);
        }
        var selections = [];
        Object.keys(obj).forEach(function (key) {
            var nestedSelSet = selectionSetFromObj(obj[key]);
            var field = {
                kind: 'Field',
                name: {
                    kind: 'Name',
                    value: key,
                },
                selectionSet: nestedSelSet || undefined,
            };
            selections.push(field);
        });
        var selectionSet = {
            kind: 'SelectionSet',
            selections: selections,
        };
        return selectionSet;
    }
    var justTypenameQuery = {
        kind: 'Document',
        definitions: [
            {
                kind: 'OperationDefinition',
                operation: 'query',
                name: null,
                variableDefinitions: null,
                directives: [],
                selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                        {
                            kind: 'Field',
                            alias: null,
                            name: {
                                kind: 'Name',
                                value: '__typename',
                            },
                            arguments: [],
                            directives: [],
                            selectionSet: null,
                        },
                    ],
                },
            },
        ],
    };

    var ApolloCache = (function () {
        function ApolloCache() {
        }
        ApolloCache.prototype.transformDocument = function (document) {
            return document;
        };
        ApolloCache.prototype.transformForLink = function (document) {
            return document;
        };
        ApolloCache.prototype.readQuery = function (options, optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return this.read({
                query: options.query,
                variables: options.variables,
                optimistic: optimistic,
            });
        };
        ApolloCache.prototype.readFragment = function (options, optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return this.read({
                query: getFragmentQueryDocument(options.fragment, options.fragmentName),
                variables: options.variables,
                rootId: options.id,
                optimistic: optimistic,
            });
        };
        ApolloCache.prototype.writeQuery = function (options) {
            this.write({
                dataId: 'ROOT_QUERY',
                result: options.data,
                query: options.query,
                variables: options.variables,
            });
        };
        ApolloCache.prototype.writeFragment = function (options) {
            this.write({
                dataId: options.id,
                result: options.data,
                variables: options.variables,
                query: getFragmentQueryDocument(options.fragment, options.fragmentName),
            });
        };
        ApolloCache.prototype.writeData = function (_a) {
            var id = _a.id, data = _a.data;
            if (typeof id !== 'undefined') {
                var typenameResult = null;
                try {
                    typenameResult = this.read({
                        rootId: id,
                        optimistic: false,
                        query: justTypenameQuery,
                    });
                }
                catch (e) {
                }
                var __typename = (typenameResult && typenameResult.__typename) || '__ClientData';
                var dataToWrite = Object.assign({ __typename: __typename }, data);
                this.writeFragment({
                    id: id,
                    fragment: fragmentFromPojo(dataToWrite, __typename),
                    data: dataToWrite,
                });
            }
            else {
                this.writeQuery({ query: queryFromPojo(data), data: data });
            }
        };
        return ApolloCache;
    }());
    //# sourceMappingURL=bundle.esm.js.map

    // This currentContext variable will only be used if the makeSlotClass
    // function is called, which happens only if this is the first copy of the
    // @wry/context package to be imported.
    var currentContext = null;
    // This unique internal object is used to denote the absence of a value
    // for a given Slot, and is never exposed to outside code.
    var MISSING_VALUE = {};
    var idCounter = 1;
    // Although we can't do anything about the cost of duplicated code from
    // accidentally bundling multiple copies of the @wry/context package, we can
    // avoid creating the Slot class more than once using makeSlotClass.
    var makeSlotClass = function () { return /** @class */ (function () {
        function Slot() {
            // If you have a Slot object, you can find out its slot.id, but you cannot
            // guess the slot.id of a Slot you don't have access to, thanks to the
            // randomized suffix.
            this.id = [
                "slot",
                idCounter++,
                Date.now(),
                Math.random().toString(36).slice(2),
            ].join(":");
        }
        Slot.prototype.hasValue = function () {
            for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
                // We use the Slot object iself as a key to its value, which means the
                // value cannot be obtained without a reference to the Slot object.
                if (this.id in context_1.slots) {
                    var value = context_1.slots[this.id];
                    if (value === MISSING_VALUE)
                        break;
                    if (context_1 !== currentContext) {
                        // Cache the value in currentContext.slots so the next lookup will
                        // be faster. This caching is safe because the tree of contexts and
                        // the values of the slots are logically immutable.
                        currentContext.slots[this.id] = value;
                    }
                    return true;
                }
            }
            if (currentContext) {
                // If a value was not found for this Slot, it's never going to be found
                // no matter how many times we look it up, so we might as well cache
                // the absence of the value, too.
                currentContext.slots[this.id] = MISSING_VALUE;
            }
            return false;
        };
        Slot.prototype.getValue = function () {
            if (this.hasValue()) {
                return currentContext.slots[this.id];
            }
        };
        Slot.prototype.withValue = function (value, callback, 
        // Given the prevalence of arrow functions, specifying arguments is likely
        // to be much more common than specifying `this`, hence this ordering:
        args, thisArg) {
            var _a;
            var slots = (_a = {
                    __proto__: null
                },
                _a[this.id] = value,
                _a);
            var parent = currentContext;
            currentContext = { parent: parent, slots: slots };
            try {
                // Function.prototype.apply allows the arguments array argument to be
                // omitted or undefined, so args! is fine here.
                return callback.apply(thisArg, args);
            }
            finally {
                currentContext = parent;
            }
        };
        // Capture the current context and wrap a callback function so that it
        // reestablishes the captured context when called.
        Slot.bind = function (callback) {
            var context = currentContext;
            return function () {
                var saved = currentContext;
                try {
                    currentContext = context;
                    return callback.apply(this, arguments);
                }
                finally {
                    currentContext = saved;
                }
            };
        };
        // Immediately run a callback function without any captured context.
        Slot.noContext = function (callback, 
        // Given the prevalence of arrow functions, specifying arguments is likely
        // to be much more common than specifying `this`, hence this ordering:
        args, thisArg) {
            if (currentContext) {
                var saved = currentContext;
                try {
                    currentContext = null;
                    // Function.prototype.apply allows the arguments array argument to be
                    // omitted or undefined, so args! is fine here.
                    return callback.apply(thisArg, args);
                }
                finally {
                    currentContext = saved;
                }
            }
            else {
                return callback.apply(thisArg, args);
            }
        };
        return Slot;
    }()); };
    // We store a single global implementation of the Slot class as a permanent
    // non-enumerable symbol property of the Array constructor. This obfuscation
    // does nothing to prevent access to the Slot class, but at least it ensures
    // the implementation (i.e. currentContext) cannot be tampered with, and all
    // copies of the @wry/context package (hopefully just one) will share the
    // same Slot implementation. Since the first copy of the @wry/context package
    // to be imported wins, this technique imposes a very high cost for any
    // future breaking changes to the Slot class.
    var globalKey = "@wry/context:Slot";
    var host = Array;
    var Slot = host[globalKey] || function () {
        var Slot = makeSlotClass();
        try {
            Object.defineProperty(host, globalKey, {
                value: host[globalKey] = Slot,
                enumerable: false,
                writable: false,
                configurable: false,
            });
        }
        finally {
            return Slot;
        }
    }();

    var bind = Slot.bind, noContext = Slot.noContext;
    //# sourceMappingURL=context.esm.js.map

    function defaultDispose() { }
    var Cache = /** @class */ (function () {
        function Cache(max, dispose) {
            if (max === void 0) { max = Infinity; }
            if (dispose === void 0) { dispose = defaultDispose; }
            this.max = max;
            this.dispose = dispose;
            this.map = new Map();
            this.newest = null;
            this.oldest = null;
        }
        Cache.prototype.has = function (key) {
            return this.map.has(key);
        };
        Cache.prototype.get = function (key) {
            var entry = this.getEntry(key);
            return entry && entry.value;
        };
        Cache.prototype.getEntry = function (key) {
            var entry = this.map.get(key);
            if (entry && entry !== this.newest) {
                var older = entry.older, newer = entry.newer;
                if (newer) {
                    newer.older = older;
                }
                if (older) {
                    older.newer = newer;
                }
                entry.older = this.newest;
                entry.older.newer = entry;
                entry.newer = null;
                this.newest = entry;
                if (entry === this.oldest) {
                    this.oldest = newer;
                }
            }
            return entry;
        };
        Cache.prototype.set = function (key, value) {
            var entry = this.getEntry(key);
            if (entry) {
                return entry.value = value;
            }
            entry = {
                key: key,
                value: value,
                newer: null,
                older: this.newest
            };
            if (this.newest) {
                this.newest.newer = entry;
            }
            this.newest = entry;
            this.oldest = this.oldest || entry;
            this.map.set(key, entry);
            return entry.value;
        };
        Cache.prototype.clean = function () {
            while (this.oldest && this.map.size > this.max) {
                this.delete(this.oldest.key);
            }
        };
        Cache.prototype.delete = function (key) {
            var entry = this.map.get(key);
            if (entry) {
                if (entry === this.newest) {
                    this.newest = entry.older;
                }
                if (entry === this.oldest) {
                    this.oldest = entry.newer;
                }
                if (entry.newer) {
                    entry.newer.older = entry.older;
                }
                if (entry.older) {
                    entry.older.newer = entry.newer;
                }
                this.map.delete(key);
                this.dispose(entry.value, key);
                return true;
            }
            return false;
        };
        return Cache;
    }());

    var parentEntrySlot = new Slot();

    var UNKNOWN_VALUE = Object.create(null);
    var reusableEmptyArray = [];
    var emptySetPool = [];
    var POOL_TARGET_SIZE = 100;
    // Since this package might be used browsers, we should avoid using the
    // Node built-in assert module.
    function assert(condition, optionalMessage) {
        if (!condition) {
            throw new Error(optionalMessage || "assertion failure");
        }
    }
    var Entry = /** @class */ (function () {
        function Entry(fn, args) {
            this.fn = fn;
            this.args = args;
            this.parents = new Set();
            this.childValues = new Map();
            // When this Entry has children that are dirty, this property becomes
            // a Set containing other Entry objects, borrowed from emptySetPool.
            // When the set becomes empty, it gets recycled back to emptySetPool.
            this.dirtyChildren = null;
            this.dirty = true;
            this.recomputing = false;
            this.value = UNKNOWN_VALUE;
            ++Entry.count;
        }
        Entry.prototype.recompute = function () {
            if (!rememberParent(this) && maybeReportOrphan(this)) {
                // The recipient of the entry.reportOrphan callback decided to dispose
                // of this orphan entry by calling entry.dispose(), so we don't need to
                // (and should not) proceed with the recomputation.
                return void 0;
            }
            return recomputeIfDirty(this);
        };
        Entry.prototype.setDirty = function () {
            if (this.dirty)
                return;
            this.dirty = true;
            this.value = UNKNOWN_VALUE;
            reportDirty(this);
            // We can go ahead and unsubscribe here, since any further dirty
            // notifications we receive will be redundant, and unsubscribing may
            // free up some resources, e.g. file watchers.
            maybeUnsubscribe(this);
        };
        Entry.prototype.dispose = function () {
            var _this = this;
            forgetChildren(this).forEach(maybeReportOrphan);
            maybeUnsubscribe(this);
            // Because this entry has been kicked out of the cache (in index.js),
            // we've lost the ability to find out if/when this entry becomes dirty,
            // whether that happens through a subscription, because of a direct call
            // to entry.setDirty(), or because one of its children becomes dirty.
            // Because of this loss of future information, we have to assume the
            // worst (that this entry might have become dirty very soon), so we must
            // immediately mark this entry's parents as dirty. Normally we could
            // just call entry.setDirty() rather than calling parent.setDirty() for
            // each parent, but that would leave this entry in parent.childValues
            // and parent.dirtyChildren, which would prevent the child from being
            // truly forgotten.
            this.parents.forEach(function (parent) {
                parent.setDirty();
                forgetChild(parent, _this);
            });
        };
        Entry.count = 0;
        return Entry;
    }());
    function rememberParent(child) {
        var parent = parentEntrySlot.getValue();
        if (parent) {
            child.parents.add(parent);
            if (!parent.childValues.has(child)) {
                parent.childValues.set(child, UNKNOWN_VALUE);
            }
            if (mightBeDirty(child)) {
                reportDirtyChild(parent, child);
            }
            else {
                reportCleanChild(parent, child);
            }
            return parent;
        }
    }
    // This is the most important method of the Entry API, because it
    // determines whether the cached entry.value can be returned immediately,
    // or must be recomputed. The overall performance of the caching system
    // depends on the truth of the following observations: (1) this.dirty is
    // usually false, (2) this.dirtyChildren is usually null/empty, and thus
    // (3) this.value is usally returned very quickly, without recomputation.
    function recomputeIfDirty(entry) {
        if (entry.dirty) {
            // If this Entry is explicitly dirty because someone called
            // entry.setDirty(), recompute.
            return reallyRecompute(entry);
        }
        if (mightBeDirty(entry)) {
            // Get fresh values for any dirty children, and if those values
            // disagree with this.childValues, mark this Entry explicitly dirty.
            entry.dirtyChildren.forEach(function (child) {
                assert(entry.childValues.has(child));
                try {
                    recomputeIfDirty(child);
                }
                catch (e) {
                    entry.setDirty();
                }
            });
            if (entry.dirty) {
                // If this Entry has become explicitly dirty after comparing the fresh
                // values of its dirty children against this.childValues, recompute.
                return reallyRecompute(entry);
            }
        }
        assert(entry.value !== UNKNOWN_VALUE);
        return entry.value;
    }
    function reallyRecompute(entry) {
        assert(!entry.recomputing, "already recomputing");
        entry.recomputing = true;
        // Since this recomputation is likely to re-remember some of this
        // entry's children, we forget our children here but do not call
        // maybeReportOrphan until after the recomputation finishes.
        var originalChildren = forgetChildren(entry);
        var threw = true;
        try {
            parentEntrySlot.withValue(entry, function () {
                entry.value = entry.fn.apply(null, entry.args);
            });
            threw = false;
        }
        finally {
            entry.recomputing = false;
            if (threw || !maybeSubscribe(entry)) {
                // Mark this Entry dirty if entry.fn threw or we failed to
                // resubscribe. This is important because, if we have a subscribe
                // function and it failed, then we're going to miss important
                // notifications about the potential dirtiness of entry.value.
                entry.setDirty();
            }
            else {
                // If we successfully recomputed entry.value and did not fail to
                // (re)subscribe, then this Entry is no longer explicitly dirty.
                setClean(entry);
            }
        }
        // Now that we've had a chance to re-remember any children that were
        // involved in the recomputation, we can safely report any orphan
        // children that remain.
        originalChildren.forEach(maybeReportOrphan);
        return entry.value;
    }
    function mightBeDirty(entry) {
        return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
    }
    function setClean(entry) {
        entry.dirty = false;
        if (mightBeDirty(entry)) {
            // This Entry may still have dirty children, in which case we can't
            // let our parents know we're clean just yet.
            return;
        }
        reportClean(entry);
    }
    function reportDirty(child) {
        child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });
    }
    function reportClean(child) {
        child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });
    }
    // Let a parent Entry know that one of its children may be dirty.
    function reportDirtyChild(parent, child) {
        // Must have called rememberParent(child) before calling
        // reportDirtyChild(parent, child).
        assert(parent.childValues.has(child));
        assert(mightBeDirty(child));
        if (!parent.dirtyChildren) {
            parent.dirtyChildren = emptySetPool.pop() || new Set;
        }
        else if (parent.dirtyChildren.has(child)) {
            // If we already know this child is dirty, then we must have already
            // informed our own parents that we are dirty, so we can terminate
            // the recursion early.
            return;
        }
        parent.dirtyChildren.add(child);
        reportDirty(parent);
    }
    // Let a parent Entry know that one of its children is no longer dirty.
    function reportCleanChild(parent, child) {
        // Must have called rememberChild(child) before calling
        // reportCleanChild(parent, child).
        assert(parent.childValues.has(child));
        assert(!mightBeDirty(child));
        var childValue = parent.childValues.get(child);
        if (childValue === UNKNOWN_VALUE) {
            parent.childValues.set(child, child.value);
        }
        else if (childValue !== child.value) {
            parent.setDirty();
        }
        removeDirtyChild(parent, child);
        if (mightBeDirty(parent)) {
            return;
        }
        reportClean(parent);
    }
    function removeDirtyChild(parent, child) {
        var dc = parent.dirtyChildren;
        if (dc) {
            dc.delete(child);
            if (dc.size === 0) {
                if (emptySetPool.length < POOL_TARGET_SIZE) {
                    emptySetPool.push(dc);
                }
                parent.dirtyChildren = null;
            }
        }
    }
    // If the given entry has a reportOrphan method, and no remaining parents,
    // call entry.reportOrphan and return true iff it returns true. The
    // reportOrphan function should return true to indicate entry.dispose()
    // has been called, and the entry has been removed from any other caches
    // (see index.js for the only current example).
    function maybeReportOrphan(entry) {
        return entry.parents.size === 0 &&
            typeof entry.reportOrphan === "function" &&
            entry.reportOrphan() === true;
    }
    // Removes all children from this entry and returns an array of the
    // removed children.
    function forgetChildren(parent) {
        var children = reusableEmptyArray;
        if (parent.childValues.size > 0) {
            children = [];
            parent.childValues.forEach(function (value, child) {
                forgetChild(parent, child);
                children.push(child);
            });
        }
        // After we forget all our children, this.dirtyChildren must be empty
        // and therefore must have been reset to null.
        assert(parent.dirtyChildren === null);
        return children;
    }
    function forgetChild(parent, child) {
        child.parents.delete(parent);
        parent.childValues.delete(child);
        removeDirtyChild(parent, child);
    }
    function maybeSubscribe(entry) {
        if (typeof entry.subscribe === "function") {
            try {
                maybeUnsubscribe(entry); // Prevent double subscriptions.
                entry.unsubscribe = entry.subscribe.apply(null, entry.args);
            }
            catch (e) {
                // If this Entry has a subscribe function and it threw an exception
                // (or an unsubscribe function it previously returned now throws),
                // return false to indicate that we were not able to subscribe (or
                // unsubscribe), and this Entry should remain dirty.
                entry.setDirty();
                return false;
            }
        }
        // Returning true indicates either that there was no entry.subscribe
        // function or that it succeeded.
        return true;
    }
    function maybeUnsubscribe(entry) {
        var unsubscribe = entry.unsubscribe;
        if (typeof unsubscribe === "function") {
            entry.unsubscribe = void 0;
            unsubscribe();
        }
    }

    // A trie data structure that holds object keys weakly, yet can also hold
    // non-object keys, unlike the native `WeakMap`.
    var KeyTrie = /** @class */ (function () {
        function KeyTrie(weakness) {
            this.weakness = weakness;
        }
        KeyTrie.prototype.lookup = function () {
            var array = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                array[_i] = arguments[_i];
            }
            return this.lookupArray(array);
        };
        KeyTrie.prototype.lookupArray = function (array) {
            var node = this;
            array.forEach(function (key) { return node = node.getChildTrie(key); });
            return node.data || (node.data = Object.create(null));
        };
        KeyTrie.prototype.getChildTrie = function (key) {
            var map = this.weakness && isObjRef(key)
                ? this.weak || (this.weak = new WeakMap())
                : this.strong || (this.strong = new Map());
            var child = map.get(key);
            if (!child)
                map.set(key, child = new KeyTrie(this.weakness));
            return child;
        };
        return KeyTrie;
    }());
    function isObjRef(value) {
        switch (typeof value) {
            case "object":
                if (value === null)
                    break;
            // Fall through to return true...
            case "function":
                return true;
        }
        return false;
    }

    // The defaultMakeCacheKey function is remarkably powerful, because it gives
    // a unique object for any shallow-identical list of arguments. If you need
    // to implement a custom makeCacheKey function, you may find it helpful to
    // delegate the final work to defaultMakeCacheKey, which is why we export it
    // here. However, you may want to avoid defaultMakeCacheKey if your runtime
    // does not support WeakMap, or you have the ability to return a string key.
    // In those cases, just write your own custom makeCacheKey functions.
    var keyTrie = new KeyTrie(typeof WeakMap === "function");
    function defaultMakeCacheKey() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return keyTrie.lookupArray(args);
    }
    function wrap(originalFunction, options) {
        if (options === void 0) { options = Object.create(null); }
        var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });
        var disposable = !!options.disposable;
        var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;
        function optimistic() {
            if (disposable && !parentEntrySlot.hasValue()) {
                // If there's no current parent computation, and this wrapped
                // function is disposable (meaning we don't care about entry.value,
                // just dependency tracking), then we can short-cut everything else
                // in this function, because entry.recompute() is going to recycle
                // the entry object without recomputing anything, anyway.
                return void 0;
            }
            var key = makeCacheKey.apply(null, arguments);
            if (!key) {
                return originalFunction.apply(null, arguments);
            }
            var args = Array.prototype.slice.call(arguments);
            var entry = cache.get(key);
            if (entry) {
                entry.args = args;
            }
            else {
                entry = new Entry(originalFunction, args);
                cache.set(key, entry);
                entry.subscribe = options.subscribe;
                if (disposable) {
                    entry.reportOrphan = function () { return cache.delete(key); };
                }
            }
            var value = entry.recompute();
            // Move this entry to the front of the least-recently used queue,
            // since we just finished computing its value.
            cache.set(key, entry);
            // Clean up any excess entries in the cache, but only if there is no
            // active parent entry, meaning we're not in the middle of a larger
            // computation that might be flummoxed by the cleaning.
            if (!parentEntrySlot.hasValue()) {
                cache.clean();
            }
            // If options.disposable is truthy, the caller of wrap is telling us
            // they don't care about the result of entry.recompute(), so we should
            // avoid returning the value, so it won't be accidentally used.
            return disposable ? void 0 : value;
        }
        optimistic.dirty = function () {
            var key = makeCacheKey.apply(null, arguments);
            var child = key && cache.get(key);
            if (child) {
                child.setDirty();
            }
        };
        return optimistic;
    }
    //# sourceMappingURL=bundle.esm.js.map

    var testMap = new Map();
    if (testMap.set(1, 2) !== testMap) {
        var set_1 = testMap.set;
        Map.prototype.set = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            set_1.apply(this, args);
            return this;
        };
    }
    var testSet = new Set();
    if (testSet.add(3) !== testSet) {
        var add_1 = testSet.add;
        Set.prototype.add = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            add_1.apply(this, args);
            return this;
        };
    }
    var frozen = {};
    if (typeof Object.freeze === 'function') {
        Object.freeze(frozen);
    }
    try {
        testMap.set(frozen, frozen).delete(frozen);
    }
    catch (_a) {
        var wrap$1 = function (method) {
            return method && (function (obj) {
                try {
                    testMap.set(obj, obj).delete(obj);
                }
                finally {
                    return method.call(Object, obj);
                }
            });
        };
        Object.freeze = wrap$1(Object.freeze);
        Object.seal = wrap$1(Object.seal);
        Object.preventExtensions = wrap$1(Object.preventExtensions);
    }

    var haveWarned = false;
    function shouldWarn() {
        var answer = !haveWarned;
        if (!isTest()) {
            haveWarned = true;
        }
        return answer;
    }
    var HeuristicFragmentMatcher = (function () {
        function HeuristicFragmentMatcher() {
        }
        HeuristicFragmentMatcher.prototype.ensureReady = function () {
            return Promise.resolve();
        };
        HeuristicFragmentMatcher.prototype.canBypassInit = function () {
            return true;
        };
        HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
            var obj = context.store.get(idValue.id);
            var isRootQuery = idValue.id === 'ROOT_QUERY';
            if (!obj) {
                return isRootQuery;
            }
            var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;
            if (!__typename) {
                if (shouldWarn()) {
                    process.env.NODE_ENV === "production" || invariant.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
                    process.env.NODE_ENV === "production" || invariant.warn('Could not find __typename on Fragment ', typeCondition, obj);
                    process.env.NODE_ENV === "production" || invariant.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior " +
                        "and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
                }
                return 'heuristic';
            }
            if (__typename === typeCondition) {
                return true;
            }
            if (shouldWarn()) {
                process.env.NODE_ENV === "production" || invariant.error('You are using the simple (heuristic) fragment matcher, but your ' +
                    'queries contain union or interface types. Apollo Client will not be ' +
                    'able to accurately map fragments. To make this error go away, use ' +
                    'the `IntrospectionFragmentMatcher` as described in the docs: ' +
                    'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher');
            }
            return 'heuristic';
        };
        return HeuristicFragmentMatcher;
    }());

    var hasOwn = Object.prototype.hasOwnProperty;
    var DepTrackingCache = (function () {
        function DepTrackingCache(data) {
            var _this = this;
            if (data === void 0) { data = Object.create(null); }
            this.data = data;
            this.depend = wrap(function (dataId) { return _this.data[dataId]; }, {
                disposable: true,
                makeCacheKey: function (dataId) {
                    return dataId;
                }
            });
        }
        DepTrackingCache.prototype.toObject = function () {
            return this.data;
        };
        DepTrackingCache.prototype.get = function (dataId) {
            this.depend(dataId);
            return this.data[dataId];
        };
        DepTrackingCache.prototype.set = function (dataId, value) {
            var oldValue = this.data[dataId];
            if (value !== oldValue) {
                this.data[dataId] = value;
                this.depend.dirty(dataId);
            }
        };
        DepTrackingCache.prototype.delete = function (dataId) {
            if (hasOwn.call(this.data, dataId)) {
                delete this.data[dataId];
                this.depend.dirty(dataId);
            }
        };
        DepTrackingCache.prototype.clear = function () {
            this.replace(null);
        };
        DepTrackingCache.prototype.replace = function (newData) {
            var _this = this;
            if (newData) {
                Object.keys(newData).forEach(function (dataId) {
                    _this.set(dataId, newData[dataId]);
                });
                Object.keys(this.data).forEach(function (dataId) {
                    if (!hasOwn.call(newData, dataId)) {
                        _this.delete(dataId);
                    }
                });
            }
            else {
                Object.keys(this.data).forEach(function (dataId) {
                    _this.delete(dataId);
                });
            }
        };
        return DepTrackingCache;
    }());
    function defaultNormalizedCacheFactory(seed) {
        return new DepTrackingCache(seed);
    }

    var StoreReader = (function () {
        function StoreReader(_a) {
            var _this = this;
            var _b = _a === void 0 ? {} : _a, _c = _b.cacheKeyRoot, cacheKeyRoot = _c === void 0 ? new KeyTrie(canUseWeakMap) : _c, _d = _b.freezeResults, freezeResults = _d === void 0 ? false : _d;
            var _e = this, executeStoreQuery = _e.executeStoreQuery, executeSelectionSet = _e.executeSelectionSet, executeSubSelectedArray = _e.executeSubSelectedArray;
            this.freezeResults = freezeResults;
            this.executeStoreQuery = wrap(function (options) {
                return executeStoreQuery.call(_this, options);
            }, {
                makeCacheKey: function (_a) {
                    var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, fragmentMatcher = _a.fragmentMatcher;
                    if (contextValue.store instanceof DepTrackingCache) {
                        return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
                    }
                }
            });
            this.executeSelectionSet = wrap(function (options) {
                return executeSelectionSet.call(_this, options);
            }, {
                makeCacheKey: function (_a) {
                    var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
                    if (execContext.contextValue.store instanceof DepTrackingCache) {
                        return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
                    }
                }
            });
            this.executeSubSelectedArray = wrap(function (options) {
                return executeSubSelectedArray.call(_this, options);
            }, {
                makeCacheKey: function (_a) {
                    var field = _a.field, array = _a.array, execContext = _a.execContext;
                    if (execContext.contextValue.store instanceof DepTrackingCache) {
                        return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));
                    }
                }
            });
        }
        StoreReader.prototype.readQueryFromStore = function (options) {
            var optsPatch = { returnPartialData: false };
            return this.diffQueryAgainstStore(__assign({}, options, optsPatch)).result;
        };
        StoreReader.prototype.diffQueryAgainstStore = function (_a) {
            var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? 'ROOT_QUERY' : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;
            var queryDefinition = getQueryDefinition(query);
            variables = assign$1({}, getDefaultValues(queryDefinition), variables);
            var context = {
                store: store,
                dataIdFromObject: (config && config.dataIdFromObject) || null,
                cacheRedirects: (config && config.cacheRedirects) || {},
            };
            var execResult = this.executeStoreQuery({
                query: query,
                rootValue: {
                    type: 'id',
                    id: rootId,
                    generated: true,
                    typename: 'Query',
                },
                contextValue: context,
                variableValues: variables,
                fragmentMatcher: fragmentMatcherFunction,
            });
            var hasMissingFields = execResult.missing && execResult.missing.length > 0;
            if (hasMissingFields && !returnPartialData) {
                execResult.missing.forEach(function (info) {
                    if (info.tolerable)
                        return;
                    throw process.env.NODE_ENV === "production" ? new InvariantError(2) : new InvariantError("Can't find field " + info.fieldName + " on object " + JSON.stringify(info.object, null, 2) + ".");
                });
            }
            if (previousResult) {
                if (equal(previousResult, execResult.result)) {
                    execResult.result = previousResult;
                }
            }
            return {
                result: execResult.result,
                complete: !hasMissingFields,
            };
        };
        StoreReader.prototype.executeStoreQuery = function (_a) {
            var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
            var mainDefinition = getMainDefinition(query);
            var fragments = getFragmentDefinitions(query);
            var fragmentMap = createFragmentMap(fragments);
            var execContext = {
                query: query,
                fragmentMap: fragmentMap,
                contextValue: contextValue,
                variableValues: variableValues,
                fragmentMatcher: fragmentMatcher,
            };
            return this.executeSelectionSet({
                selectionSet: mainDefinition.selectionSet,
                rootValue: rootValue,
                execContext: execContext,
            });
        };
        StoreReader.prototype.executeSelectionSet = function (_a) {
            var _this = this;
            var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
            var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;
            var finalResult = { result: null };
            var objectsToMerge = [];
            var object = contextValue.store.get(rootValue.id);
            var typename = (object && object.__typename) ||
                (rootValue.id === 'ROOT_QUERY' && 'Query') ||
                void 0;
            function handleMissing(result) {
                var _a;
                if (result.missing) {
                    finalResult.missing = finalResult.missing || [];
                    (_a = finalResult.missing).push.apply(_a, result.missing);
                }
                return result.result;
            }
            selectionSet.selections.forEach(function (selection) {
                var _a;
                if (!shouldInclude(selection, variables)) {
                    return;
                }
                if (isField(selection)) {
                    var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));
                    if (typeof fieldResult !== 'undefined') {
                        objectsToMerge.push((_a = {},
                            _a[resultKeyNameFromField(selection)] = fieldResult,
                            _a));
                    }
                }
                else {
                    var fragment = void 0;
                    if (isInlineFragment(selection)) {
                        fragment = selection;
                    }
                    else {
                        fragment = fragmentMap[selection.name.value];
                        if (!fragment) {
                            throw process.env.NODE_ENV === "production" ? new InvariantError(3) : new InvariantError("No fragment named " + selection.name.value);
                        }
                    }
                    var typeCondition = fragment.typeCondition.name.value;
                    var match = execContext.fragmentMatcher(rootValue, typeCondition, contextValue);
                    if (match) {
                        var fragmentExecResult = _this.executeSelectionSet({
                            selectionSet: fragment.selectionSet,
                            rootValue: rootValue,
                            execContext: execContext,
                        });
                        if (match === 'heuristic' && fragmentExecResult.missing) {
                            fragmentExecResult = __assign({}, fragmentExecResult, { missing: fragmentExecResult.missing.map(function (info) {
                                    return __assign({}, info, { tolerable: true });
                                }) });
                        }
                        objectsToMerge.push(handleMissing(fragmentExecResult));
                    }
                }
            });
            finalResult.result = mergeDeepArray(objectsToMerge);
            if (this.freezeResults && process.env.NODE_ENV !== 'production') {
                Object.freeze(finalResult.result);
            }
            return finalResult;
        };
        StoreReader.prototype.executeField = function (object, typename, field, execContext) {
            var variables = execContext.variableValues, contextValue = execContext.contextValue;
            var fieldName = field.name.value;
            var args = argumentsObjectFromField(field, variables);
            var info = {
                resultKey: resultKeyNameFromField(field),
                directives: getDirectiveInfoFromField(field, variables),
            };
            var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);
            if (Array.isArray(readStoreResult.result)) {
                return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({
                    field: field,
                    array: readStoreResult.result,
                    execContext: execContext,
                }));
            }
            if (!field.selectionSet) {
                assertSelectionSetForIdValue(field, readStoreResult.result);
                if (this.freezeResults && process.env.NODE_ENV !== 'production') {
                    maybeDeepFreeze(readStoreResult);
                }
                return readStoreResult;
            }
            if (readStoreResult.result == null) {
                return readStoreResult;
            }
            return this.combineExecResults(readStoreResult, this.executeSelectionSet({
                selectionSet: field.selectionSet,
                rootValue: readStoreResult.result,
                execContext: execContext,
            }));
        };
        StoreReader.prototype.combineExecResults = function () {
            var execResults = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                execResults[_i] = arguments[_i];
            }
            var missing = null;
            execResults.forEach(function (execResult) {
                if (execResult.missing) {
                    missing = missing || [];
                    missing.push.apply(missing, execResult.missing);
                }
            });
            return {
                result: execResults.pop().result,
                missing: missing,
            };
        };
        StoreReader.prototype.executeSubSelectedArray = function (_a) {
            var _this = this;
            var field = _a.field, array = _a.array, execContext = _a.execContext;
            var missing = null;
            function handleMissing(childResult) {
                if (childResult.missing) {
                    missing = missing || [];
                    missing.push.apply(missing, childResult.missing);
                }
                return childResult.result;
            }
            array = array.map(function (item) {
                if (item === null) {
                    return null;
                }
                if (Array.isArray(item)) {
                    return handleMissing(_this.executeSubSelectedArray({
                        field: field,
                        array: item,
                        execContext: execContext,
                    }));
                }
                if (field.selectionSet) {
                    return handleMissing(_this.executeSelectionSet({
                        selectionSet: field.selectionSet,
                        rootValue: item,
                        execContext: execContext,
                    }));
                }
                assertSelectionSetForIdValue(field, item);
                return item;
            });
            if (this.freezeResults && process.env.NODE_ENV !== 'production') {
                Object.freeze(array);
            }
            return { result: array, missing: missing };
        };
        return StoreReader;
    }());
    function assertSelectionSetForIdValue(field, value) {
        if (!field.selectionSet && isIdValue(value)) {
            throw process.env.NODE_ENV === "production" ? new InvariantError(4) : new InvariantError("Missing selection set for object of type " + value.typename + " returned for query field " + field.name.value);
        }
    }
    function defaultFragmentMatcher() {
        return true;
    }
    function readStoreResolver(object, typename, fieldName, args, context, _a) {
        var resultKey = _a.resultKey, directives = _a.directives;
        var storeKeyName = fieldName;
        if (args || directives) {
            storeKeyName = getStoreKeyName(storeKeyName, args, directives);
        }
        var fieldValue = void 0;
        if (object) {
            fieldValue = object[storeKeyName];
            if (typeof fieldValue === 'undefined' &&
                context.cacheRedirects &&
                typeof typename === 'string') {
                var type = context.cacheRedirects[typename];
                if (type) {
                    var resolver = type[fieldName];
                    if (resolver) {
                        fieldValue = resolver(object, args, {
                            getCacheKey: function (storeObj) {
                                return toIdValue({
                                    id: context.dataIdFromObject(storeObj),
                                    typename: storeObj.__typename,
                                });
                            },
                        });
                    }
                }
            }
        }
        if (typeof fieldValue === 'undefined') {
            return {
                result: fieldValue,
                missing: [{
                        object: object,
                        fieldName: storeKeyName,
                        tolerable: false,
                    }],
            };
        }
        if (isJsonValue(fieldValue)) {
            fieldValue = fieldValue.json;
        }
        return {
            result: fieldValue,
        };
    }

    var ObjectCache = (function () {
        function ObjectCache(data) {
            if (data === void 0) { data = Object.create(null); }
            this.data = data;
        }
        ObjectCache.prototype.toObject = function () {
            return this.data;
        };
        ObjectCache.prototype.get = function (dataId) {
            return this.data[dataId];
        };
        ObjectCache.prototype.set = function (dataId, value) {
            this.data[dataId] = value;
        };
        ObjectCache.prototype.delete = function (dataId) {
            this.data[dataId] = void 0;
        };
        ObjectCache.prototype.clear = function () {
            this.data = Object.create(null);
        };
        ObjectCache.prototype.replace = function (newData) {
            this.data = newData || Object.create(null);
        };
        return ObjectCache;
    }());

    var WriteError = (function (_super) {
        __extends(WriteError, _super);
        function WriteError() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'WriteError';
            return _this;
        }
        return WriteError;
    }(Error));
    function enhanceErrorWithDocument(error, document) {
        var enhancedError = new WriteError("Error writing result to store for query:\n " + JSON.stringify(document));
        enhancedError.message += '\n' + error.message;
        enhancedError.stack = error.stack;
        return enhancedError;
    }
    var StoreWriter = (function () {
        function StoreWriter() {
        }
        StoreWriter.prototype.writeQueryToStore = function (_a) {
            var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
            return this.writeResultToStore({
                dataId: 'ROOT_QUERY',
                result: result,
                document: query,
                store: store,
                variables: variables,
                dataIdFromObject: dataIdFromObject,
                fragmentMatcherFunction: fragmentMatcherFunction,
            });
        };
        StoreWriter.prototype.writeResultToStore = function (_a) {
            var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
            var operationDefinition = getOperationDefinition(document);
            try {
                return this.writeSelectionSetToStore({
                    result: result,
                    dataId: dataId,
                    selectionSet: operationDefinition.selectionSet,
                    context: {
                        store: store,
                        processedData: {},
                        variables: assign$1({}, getDefaultValues(operationDefinition), variables),
                        dataIdFromObject: dataIdFromObject,
                        fragmentMap: createFragmentMap(getFragmentDefinitions(document)),
                        fragmentMatcherFunction: fragmentMatcherFunction,
                    },
                });
            }
            catch (e) {
                throw enhanceErrorWithDocument(e, document);
            }
        };
        StoreWriter.prototype.writeSelectionSetToStore = function (_a) {
            var _this = this;
            var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;
            var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;
            selectionSet.selections.forEach(function (selection) {
                var _a;
                if (!shouldInclude(selection, variables)) {
                    return;
                }
                if (isField(selection)) {
                    var resultFieldKey = resultKeyNameFromField(selection);
                    var value = result[resultFieldKey];
                    if (typeof value !== 'undefined') {
                        _this.writeFieldToStore({
                            dataId: dataId,
                            value: value,
                            field: selection,
                            context: context,
                        });
                    }
                    else {
                        var isDefered = false;
                        var isClient = false;
                        if (selection.directives && selection.directives.length) {
                            isDefered = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });
                            isClient = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'client'; });
                        }
                        if (!isDefered && !isClient && context.fragmentMatcherFunction) {
                            process.env.NODE_ENV === "production" || invariant.warn("Missing field " + resultFieldKey + " in " + JSON.stringify(result, null, 2).substring(0, 100));
                        }
                    }
                }
                else {
                    var fragment = void 0;
                    if (isInlineFragment(selection)) {
                        fragment = selection;
                    }
                    else {
                        fragment = (fragmentMap || {})[selection.name.value];
                        process.env.NODE_ENV === "production" ? invariant(fragment, 6) : invariant(fragment, "No fragment named " + selection.name.value + ".");
                    }
                    var matches = true;
                    if (context.fragmentMatcherFunction && fragment.typeCondition) {
                        var id = dataId || 'self';
                        var idValue = toIdValue({ id: id, typename: undefined });
                        var fakeContext = {
                            store: new ObjectCache((_a = {}, _a[id] = result, _a)),
                            cacheRedirects: {},
                        };
                        var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);
                        if (!isProduction() && match === 'heuristic') {
                            process.env.NODE_ENV === "production" || invariant.error('WARNING: heuristic fragment matching going on!');
                        }
                        matches = !!match;
                    }
                    if (matches) {
                        _this.writeSelectionSetToStore({
                            result: result,
                            selectionSet: fragment.selectionSet,
                            dataId: dataId,
                            context: context,
                        });
                    }
                }
            });
            return store;
        };
        StoreWriter.prototype.writeFieldToStore = function (_a) {
            var _b;
            var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;
            var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;
            var storeValue;
            var storeObject;
            var storeFieldName = storeKeyNameFromField(field, variables);
            if (!field.selectionSet || value === null) {
                storeValue =
                    value != null && typeof value === 'object'
                        ?
                            { type: 'json', json: value }
                        :
                            value;
            }
            else if (Array.isArray(value)) {
                var generatedId = dataId + "." + storeFieldName;
                storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
            }
            else {
                var valueDataId = dataId + "." + storeFieldName;
                var generated = true;
                if (!isGeneratedId(valueDataId)) {
                    valueDataId = '$' + valueDataId;
                }
                if (dataIdFromObject) {
                    var semanticId = dataIdFromObject(value);
                    process.env.NODE_ENV === "production" ? invariant(!semanticId || !isGeneratedId(semanticId), 7) : invariant(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the "$" character.');
                    if (semanticId ||
                        (typeof semanticId === 'number' && semanticId === 0)) {
                        valueDataId = semanticId;
                        generated = false;
                    }
                }
                if (!isDataProcessed(valueDataId, field, context.processedData)) {
                    this.writeSelectionSetToStore({
                        dataId: valueDataId,
                        result: value,
                        selectionSet: field.selectionSet,
                        context: context,
                    });
                }
                var typename = value.__typename;
                storeValue = toIdValue({ id: valueDataId, typename: typename }, generated);
                storeObject = store.get(dataId);
                var escapedId = storeObject && storeObject[storeFieldName];
                if (escapedId !== storeValue && isIdValue(escapedId)) {
                    var hadTypename = escapedId.typename !== undefined;
                    var hasTypename = typename !== undefined;
                    var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;
                    process.env.NODE_ENV === "production" ? invariant(!generated || escapedId.generated || typenameChanged, 8) : invariant(!generated || escapedId.generated || typenameChanged, "Store error: the application attempted to write an object with no provided id but the store already contains an id of " + escapedId.id + " for this object. The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
                    process.env.NODE_ENV === "production" ? invariant(!hadTypename || hasTypename, 9) : invariant(!hadTypename || hasTypename, "Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of " + escapedId.typename + " for the object of id " + escapedId.id + ". The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
                    if (escapedId.generated) {
                        if (typenameChanged) {
                            if (!generated) {
                                store.delete(escapedId.id);
                            }
                        }
                        else {
                            mergeWithGenerated(escapedId.id, storeValue.id, store);
                        }
                    }
                }
            }
            storeObject = store.get(dataId);
            if (!storeObject || !equal(storeValue, storeObject[storeFieldName])) {
                store.set(dataId, __assign({}, storeObject, (_b = {}, _b[storeFieldName] = storeValue, _b)));
            }
        };
        StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {
            var _this = this;
            return value.map(function (item, index) {
                if (item === null) {
                    return null;
                }
                var itemDataId = generatedId + "." + index;
                if (Array.isArray(item)) {
                    return _this.processArrayValue(item, itemDataId, selectionSet, context);
                }
                var generated = true;
                if (context.dataIdFromObject) {
                    var semanticId = context.dataIdFromObject(item);
                    if (semanticId) {
                        itemDataId = semanticId;
                        generated = false;
                    }
                }
                if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
                    _this.writeSelectionSetToStore({
                        dataId: itemDataId,
                        result: item,
                        selectionSet: selectionSet,
                        context: context,
                    });
                }
                return toIdValue({ id: itemDataId, typename: item.__typename }, generated);
            });
        };
        return StoreWriter;
    }());
    function isGeneratedId(id) {
        return id[0] === '$';
    }
    function mergeWithGenerated(generatedKey, realKey, cache) {
        if (generatedKey === realKey) {
            return false;
        }
        var generated = cache.get(generatedKey);
        var real = cache.get(realKey);
        var madeChanges = false;
        Object.keys(generated).forEach(function (key) {
            var value = generated[key];
            var realValue = real[key];
            if (isIdValue(value) &&
                isGeneratedId(value.id) &&
                isIdValue(realValue) &&
                !equal(value, realValue) &&
                mergeWithGenerated(value.id, realValue.id, cache)) {
                madeChanges = true;
            }
        });
        cache.delete(generatedKey);
        var newRealValue = __assign({}, generated, real);
        if (equal(newRealValue, real)) {
            return madeChanges;
        }
        cache.set(realKey, newRealValue);
        return true;
    }
    function isDataProcessed(dataId, field, processedData) {
        if (!processedData) {
            return false;
        }
        if (processedData[dataId]) {
            if (processedData[dataId].indexOf(field) >= 0) {
                return true;
            }
            else {
                processedData[dataId].push(field);
            }
        }
        else {
            processedData[dataId] = [field];
        }
        return false;
    }

    var defaultConfig = {
        fragmentMatcher: new HeuristicFragmentMatcher(),
        dataIdFromObject: defaultDataIdFromObject,
        addTypename: true,
        resultCaching: true,
        freezeResults: false,
    };
    function defaultDataIdFromObject(result) {
        if (result.__typename) {
            if (result.id !== undefined) {
                return result.__typename + ":" + result.id;
            }
            if (result._id !== undefined) {
                return result.__typename + ":" + result._id;
            }
        }
        return null;
    }
    var hasOwn$1 = Object.prototype.hasOwnProperty;
    var OptimisticCacheLayer = (function (_super) {
        __extends(OptimisticCacheLayer, _super);
        function OptimisticCacheLayer(optimisticId, parent, transaction) {
            var _this = _super.call(this, Object.create(null)) || this;
            _this.optimisticId = optimisticId;
            _this.parent = parent;
            _this.transaction = transaction;
            return _this;
        }
        OptimisticCacheLayer.prototype.toObject = function () {
            return __assign({}, this.parent.toObject(), this.data);
        };
        OptimisticCacheLayer.prototype.get = function (dataId) {
            return hasOwn$1.call(this.data, dataId)
                ? this.data[dataId]
                : this.parent.get(dataId);
        };
        return OptimisticCacheLayer;
    }(ObjectCache));
    var InMemoryCache = (function (_super) {
        __extends(InMemoryCache, _super);
        function InMemoryCache(config) {
            if (config === void 0) { config = {}; }
            var _this = _super.call(this) || this;
            _this.watches = new Set();
            _this.typenameDocumentCache = new Map();
            _this.cacheKeyRoot = new KeyTrie(canUseWeakMap);
            _this.silenceBroadcast = false;
            _this.config = __assign({}, defaultConfig, config);
            if (_this.config.customResolvers) {
                process.env.NODE_ENV === "production" || invariant.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');
                _this.config.cacheRedirects = _this.config.customResolvers;
            }
            if (_this.config.cacheResolvers) {
                process.env.NODE_ENV === "production" || invariant.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');
                _this.config.cacheRedirects = _this.config.cacheResolvers;
            }
            _this.addTypename = _this.config.addTypename;
            _this.data = _this.config.resultCaching
                ? new DepTrackingCache()
                : new ObjectCache();
            _this.optimisticData = _this.data;
            _this.storeWriter = new StoreWriter();
            _this.storeReader = new StoreReader({
                cacheKeyRoot: _this.cacheKeyRoot,
                freezeResults: config.freezeResults,
            });
            var cache = _this;
            var maybeBroadcastWatch = cache.maybeBroadcastWatch;
            _this.maybeBroadcastWatch = wrap(function (c) {
                return maybeBroadcastWatch.call(_this, c);
            }, {
                makeCacheKey: function (c) {
                    if (c.optimistic) {
                        return;
                    }
                    if (c.previousResult) {
                        return;
                    }
                    if (cache.data instanceof DepTrackingCache) {
                        return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
                    }
                }
            });
            return _this;
        }
        InMemoryCache.prototype.restore = function (data) {
            if (data)
                this.data.replace(data);
            return this;
        };
        InMemoryCache.prototype.extract = function (optimistic) {
            if (optimistic === void 0) { optimistic = false; }
            return (optimistic ? this.optimisticData : this.data).toObject();
        };
        InMemoryCache.prototype.read = function (options) {
            if (typeof options.rootId === 'string' &&
                typeof this.data.get(options.rootId) === 'undefined') {
                return null;
            }
            return this.storeReader.readQueryFromStore({
                store: options.optimistic ? this.optimisticData : this.data,
                query: this.transformDocument(options.query),
                variables: options.variables,
                rootId: options.rootId,
                fragmentMatcherFunction: this.config.fragmentMatcher.match,
                previousResult: options.previousResult,
                config: this.config,
            });
        };
        InMemoryCache.prototype.write = function (write) {
            this.storeWriter.writeResultToStore({
                dataId: write.dataId,
                result: write.result,
                variables: write.variables,
                document: this.transformDocument(write.query),
                store: this.data,
                dataIdFromObject: this.config.dataIdFromObject,
                fragmentMatcherFunction: this.config.fragmentMatcher.match,
            });
            this.broadcastWatches();
        };
        InMemoryCache.prototype.diff = function (query) {
            return this.storeReader.diffQueryAgainstStore({
                store: query.optimistic ? this.optimisticData : this.data,
                query: this.transformDocument(query.query),
                variables: query.variables,
                returnPartialData: query.returnPartialData,
                previousResult: query.previousResult,
                fragmentMatcherFunction: this.config.fragmentMatcher.match,
                config: this.config,
            });
        };
        InMemoryCache.prototype.watch = function (watch) {
            var _this = this;
            this.watches.add(watch);
            return function () {
                _this.watches.delete(watch);
            };
        };
        InMemoryCache.prototype.evict = function (query) {
            throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError("eviction is not implemented on InMemory Cache");
        };
        InMemoryCache.prototype.reset = function () {
            this.data.clear();
            this.broadcastWatches();
            return Promise.resolve();
        };
        InMemoryCache.prototype.removeOptimistic = function (idToRemove) {
            var toReapply = [];
            var removedCount = 0;
            var layer = this.optimisticData;
            while (layer instanceof OptimisticCacheLayer) {
                if (layer.optimisticId === idToRemove) {
                    ++removedCount;
                }
                else {
                    toReapply.push(layer);
                }
                layer = layer.parent;
            }
            if (removedCount > 0) {
                this.optimisticData = layer;
                while (toReapply.length > 0) {
                    var layer_1 = toReapply.pop();
                    this.performTransaction(layer_1.transaction, layer_1.optimisticId);
                }
                this.broadcastWatches();
            }
        };
        InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {
            var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;
            this.silenceBroadcast = true;
            if (typeof optimisticId === 'string') {
                this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);
            }
            try {
                transaction(this);
            }
            finally {
                this.silenceBroadcast = silenceBroadcast;
                this.data = data;
            }
            this.broadcastWatches();
        };
        InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {
            return this.performTransaction(transaction, id);
        };
        InMemoryCache.prototype.transformDocument = function (document) {
            if (this.addTypename) {
                var result = this.typenameDocumentCache.get(document);
                if (!result) {
                    result = addTypenameToDocument(document);
                    this.typenameDocumentCache.set(document, result);
                    this.typenameDocumentCache.set(result, result);
                }
                return result;
            }
            return document;
        };
        InMemoryCache.prototype.broadcastWatches = function () {
            var _this = this;
            if (!this.silenceBroadcast) {
                this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c); });
            }
        };
        InMemoryCache.prototype.maybeBroadcastWatch = function (c) {
            c.callback(this.diff({
                query: c.query,
                variables: c.variables,
                previousResult: c.previousResult && c.previousResult(),
                optimistic: c.optimistic,
            }));
        };
        return InMemoryCache;
    }(ApolloCache));
    //# sourceMappingURL=bundle.esm.js.map

    /**
     * Produces the value of a block string from its parsed raw value, similar to
     * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
     *
     * This implements the GraphQL spec's BlockStringValue() static algorithm.
     */
    function dedentBlockStringValue(rawString) {
      // Expand a block string's raw value into independent lines.
      var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

      var commonIndent = getBlockStringIndentation(lines);

      if (commonIndent !== 0) {
        for (var i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      } // Remove leading and trailing blank lines.


      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }

      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      } // Return a string of the lines joined with U+000A.


      return lines.join('\n');
    } // @internal

    function getBlockStringIndentation(lines) {
      var commonIndent = null;

      for (var i = 1; i < lines.length; i++) {
        var line = lines[i];
        var indent = leadingWhitespace(line);

        if (indent === line.length) {
          continue; // skip empty lines
        }

        if (commonIndent === null || indent < commonIndent) {
          commonIndent = indent;

          if (commonIndent === 0) {
            break;
          }
        }
      }

      return commonIndent === null ? 0 : commonIndent;
    }

    function leadingWhitespace(str) {
      var i = 0;

      while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
        i++;
      }

      return i;
    }

    function isBlank(str) {
      return leadingWhitespace(str) === str.length;
    }
    /**
     * Print a block string in the indented block form by adding a leading and
     * trailing blank line. However, if a block string starts with whitespace and is
     * a single-line, adding a leading blank line would strip that whitespace.
     */


    function printBlockString(value) {
      var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isSingleLine = value.indexOf('\n') === -1;
      var hasLeadingSpace = value[0] === ' ' || value[0] === '\t';
      var hasTrailingQuote = value[value.length - 1] === '"';
      var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;
      var result = ''; // Format a multi-line block quote to account for leading space.

      if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
        result += '\n' + indentation;
      }

      result += indentation ? value.replace(/\n/g, '\n' + indentation) : value;

      if (printAsMultipleLines) {
        result += '\n';
      }

      return '"""' + result.replace(/"""/g, '\\"""') + '"""';
    }

    /**
     * Converts an AST into a string, using one set of reasonable
     * formatting rules.
     */

    function print(ast) {
      return visit(ast, {
        leave: printDocASTReducer
      });
    } // TODO: provide better type coverage in future

    var printDocASTReducer = {
      Name: function Name(node) {
        return node.value;
      },
      Variable: function Variable(node) {
        return '$' + node.name;
      },
      // Document
      Document: function Document(node) {
        return join(node.definitions, '\n\n') + '\n';
      },
      OperationDefinition: function OperationDefinition(node) {
        var op = node.operation;
        var name = node.name;
        var varDefs = wrap$2('(', join(node.variableDefinitions, ', '), ')');
        var directives = join(node.directives, ' ');
        var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
        // the query short form.

        return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
      },
      VariableDefinition: function VariableDefinition(_ref) {
        var variable = _ref.variable,
            type = _ref.type,
            defaultValue = _ref.defaultValue,
            directives = _ref.directives;
        return variable + ': ' + type + wrap$2(' = ', defaultValue) + wrap$2(' ', join(directives, ' '));
      },
      SelectionSet: function SelectionSet(_ref2) {
        var selections = _ref2.selections;
        return block(selections);
      },
      Field: function Field(_ref3) {
        var alias = _ref3.alias,
            name = _ref3.name,
            args = _ref3.arguments,
            directives = _ref3.directives,
            selectionSet = _ref3.selectionSet;
        return join([wrap$2('', alias, ': ') + name + wrap$2('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
      },
      Argument: function Argument(_ref4) {
        var name = _ref4.name,
            value = _ref4.value;
        return name + ': ' + value;
      },
      // Fragments
      FragmentSpread: function FragmentSpread(_ref5) {
        var name = _ref5.name,
            directives = _ref5.directives;
        return '...' + name + wrap$2(' ', join(directives, ' '));
      },
      InlineFragment: function InlineFragment(_ref6) {
        var typeCondition = _ref6.typeCondition,
            directives = _ref6.directives,
            selectionSet = _ref6.selectionSet;
        return join(['...', wrap$2('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
      },
      FragmentDefinition: function FragmentDefinition(_ref7) {
        var name = _ref7.name,
            typeCondition = _ref7.typeCondition,
            variableDefinitions = _ref7.variableDefinitions,
            directives = _ref7.directives,
            selectionSet = _ref7.selectionSet;
        return (// Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          "fragment ".concat(name).concat(wrap$2('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap$2('', join(directives, ' '), ' ')) + selectionSet
        );
      },
      // Value
      IntValue: function IntValue(_ref8) {
        var value = _ref8.value;
        return value;
      },
      FloatValue: function FloatValue(_ref9) {
        var value = _ref9.value;
        return value;
      },
      StringValue: function StringValue(_ref10, key) {
        var value = _ref10.value,
            isBlockString = _ref10.block;
        return isBlockString ? printBlockString(value, key === 'description' ? '' : '  ') : JSON.stringify(value);
      },
      BooleanValue: function BooleanValue(_ref11) {
        var value = _ref11.value;
        return value ? 'true' : 'false';
      },
      NullValue: function NullValue() {
        return 'null';
      },
      EnumValue: function EnumValue(_ref12) {
        var value = _ref12.value;
        return value;
      },
      ListValue: function ListValue(_ref13) {
        var values = _ref13.values;
        return '[' + join(values, ', ') + ']';
      },
      ObjectValue: function ObjectValue(_ref14) {
        var fields = _ref14.fields;
        return '{' + join(fields, ', ') + '}';
      },
      ObjectField: function ObjectField(_ref15) {
        var name = _ref15.name,
            value = _ref15.value;
        return name + ': ' + value;
      },
      // Directive
      Directive: function Directive(_ref16) {
        var name = _ref16.name,
            args = _ref16.arguments;
        return '@' + name + wrap$2('(', join(args, ', '), ')');
      },
      // Type
      NamedType: function NamedType(_ref17) {
        var name = _ref17.name;
        return name;
      },
      ListType: function ListType(_ref18) {
        var type = _ref18.type;
        return '[' + type + ']';
      },
      NonNullType: function NonNullType(_ref19) {
        var type = _ref19.type;
        return type + '!';
      },
      // Type System Definitions
      SchemaDefinition: function SchemaDefinition(_ref20) {
        var directives = _ref20.directives,
            operationTypes = _ref20.operationTypes;
        return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
      },
      OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
        var operation = _ref21.operation,
            type = _ref21.type;
        return operation + ': ' + type;
      },
      ScalarTypeDefinition: addDescription(function (_ref22) {
        var name = _ref22.name,
            directives = _ref22.directives;
        return join(['scalar', name, join(directives, ' ')], ' ');
      }),
      ObjectTypeDefinition: addDescription(function (_ref23) {
        var name = _ref23.name,
            interfaces = _ref23.interfaces,
            directives = _ref23.directives,
            fields = _ref23.fields;
        return join(['type', name, wrap$2('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
      }),
      FieldDefinition: addDescription(function (_ref24) {
        var name = _ref24.name,
            args = _ref24.arguments,
            type = _ref24.type,
            directives = _ref24.directives;
        return name + (hasMultilineItems(args) ? wrap$2('(\n', indent(join(args, '\n')), '\n)') : wrap$2('(', join(args, ', '), ')')) + ': ' + type + wrap$2(' ', join(directives, ' '));
      }),
      InputValueDefinition: addDescription(function (_ref25) {
        var name = _ref25.name,
            type = _ref25.type,
            defaultValue = _ref25.defaultValue,
            directives = _ref25.directives;
        return join([name + ': ' + type, wrap$2('= ', defaultValue), join(directives, ' ')], ' ');
      }),
      InterfaceTypeDefinition: addDescription(function (_ref26) {
        var name = _ref26.name,
            directives = _ref26.directives,
            fields = _ref26.fields;
        return join(['interface', name, join(directives, ' '), block(fields)], ' ');
      }),
      UnionTypeDefinition: addDescription(function (_ref27) {
        var name = _ref27.name,
            directives = _ref27.directives,
            types = _ref27.types;
        return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
      }),
      EnumTypeDefinition: addDescription(function (_ref28) {
        var name = _ref28.name,
            directives = _ref28.directives,
            values = _ref28.values;
        return join(['enum', name, join(directives, ' '), block(values)], ' ');
      }),
      EnumValueDefinition: addDescription(function (_ref29) {
        var name = _ref29.name,
            directives = _ref29.directives;
        return join([name, join(directives, ' ')], ' ');
      }),
      InputObjectTypeDefinition: addDescription(function (_ref30) {
        var name = _ref30.name,
            directives = _ref30.directives,
            fields = _ref30.fields;
        return join(['input', name, join(directives, ' '), block(fields)], ' ');
      }),
      DirectiveDefinition: addDescription(function (_ref31) {
        var name = _ref31.name,
            args = _ref31.arguments,
            repeatable = _ref31.repeatable,
            locations = _ref31.locations;
        return 'directive @' + name + (hasMultilineItems(args) ? wrap$2('(\n', indent(join(args, '\n')), '\n)') : wrap$2('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');
      }),
      SchemaExtension: function SchemaExtension(_ref32) {
        var directives = _ref32.directives,
            operationTypes = _ref32.operationTypes;
        return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
      },
      ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
        var name = _ref33.name,
            directives = _ref33.directives;
        return join(['extend scalar', name, join(directives, ' ')], ' ');
      },
      ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
        var name = _ref34.name,
            interfaces = _ref34.interfaces,
            directives = _ref34.directives,
            fields = _ref34.fields;
        return join(['extend type', name, wrap$2('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
      },
      InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
        var name = _ref35.name,
            directives = _ref35.directives,
            fields = _ref35.fields;
        return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');
      },
      UnionTypeExtension: function UnionTypeExtension(_ref36) {
        var name = _ref36.name,
            directives = _ref36.directives,
            types = _ref36.types;
        return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
      },
      EnumTypeExtension: function EnumTypeExtension(_ref37) {
        var name = _ref37.name,
            directives = _ref37.directives,
            values = _ref37.values;
        return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
      },
      InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
        var name = _ref38.name,
            directives = _ref38.directives,
            fields = _ref38.fields;
        return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
      }
    };

    function addDescription(cb) {
      return function (node) {
        return join([node.description, cb(node)], '\n');
      };
    }
    /**
     * Given maybeArray, print an empty string if it is null or empty, otherwise
     * print all items together separated by separator if provided
     */


    function join(maybeArray, separator) {
      return maybeArray ? maybeArray.filter(function (x) {
        return x;
      }).join(separator || '') : '';
    }
    /**
     * Given array, print each item on its own line, wrapped in an
     * indented "{ }" block.
     */


    function block(array) {
      return array && array.length !== 0 ? '{\n' + indent(join(array, '\n')) + '\n}' : '';
    }
    /**
     * If maybeString is not null or empty, then wrap with start and end, otherwise
     * print an empty string.
     */


    function wrap$2(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || '') : '';
    }

    function indent(maybeString) {
      return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
    }

    function isMultiline(string) {
      return string.indexOf('\n') !== -1;
    }

    function hasMultilineItems(maybeArray) {
      return maybeArray && maybeArray.some(isMultiline);
    }

    var defaultHttpOptions = {
        includeQuery: true,
        includeExtensions: false,
    };
    var defaultHeaders = {
        accept: '*/*',
        'content-type': 'application/json',
    };
    var defaultOptions = {
        method: 'POST',
    };
    var fallbackHttpConfig = {
        http: defaultHttpOptions,
        headers: defaultHeaders,
        options: defaultOptions,
    };
    var throwServerError = function (response, result, message) {
        var error = new Error(message);
        error.name = 'ServerError';
        error.response = response;
        error.statusCode = response.status;
        error.result = result;
        throw error;
    };
    var parseAndCheckHttpResponse = function (operations) { return function (response) {
        return (response
            .text()
            .then(function (bodyText) {
            try {
                return JSON.parse(bodyText);
            }
            catch (err) {
                var parseError = err;
                parseError.name = 'ServerParseError';
                parseError.response = response;
                parseError.statusCode = response.status;
                parseError.bodyText = bodyText;
                return Promise.reject(parseError);
            }
        })
            .then(function (result) {
            if (response.status >= 300) {
                throwServerError(response, result, "Response not successful: Received status code " + response.status);
            }
            if (!Array.isArray(result) &&
                !result.hasOwnProperty('data') &&
                !result.hasOwnProperty('errors')) {
                throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations)
                    ? operations.map(function (op) { return op.operationName; })
                    : operations.operationName) + "'.");
            }
            return result;
        }));
    }; };
    var checkFetcher = function (fetcher) {
        if (!fetcher && typeof fetch === 'undefined') {
            var library = 'unfetch';
            if (typeof window === 'undefined')
                library = 'node-fetch';
            throw process.env.NODE_ENV === "production" ? new InvariantError(1) : new InvariantError("\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/" + library + ".\n\nFor example:\nimport fetch from '" + library + "';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });");
        }
    };
    var createSignalIfSupported = function () {
        if (typeof AbortController === 'undefined')
            return { controller: false, signal: false };
        var controller = new AbortController();
        var signal = controller.signal;
        return { controller: controller, signal: signal };
    };
    var selectHttpOptionsAndBody = function (operation, fallbackConfig) {
        var configs = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            configs[_i - 2] = arguments[_i];
        }
        var options = __assign({}, fallbackConfig.options, { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });
        var http = fallbackConfig.http;
        configs.forEach(function (config) {
            options = __assign({}, options, config.options, { headers: __assign({}, options.headers, config.headers) });
            if (config.credentials)
                options.credentials = config.credentials;
            http = __assign({}, http, config.http);
        });
        var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
        var body = { operationName: operationName, variables: variables };
        if (http.includeExtensions)
            body.extensions = extensions;
        if (http.includeQuery)
            body.query = print(query);
        return {
            options: options,
            body: body,
        };
    };
    var serializeFetchParameter = function (p, label) {
        var serialized;
        try {
            serialized = JSON.stringify(p);
        }
        catch (e) {
            var parseError = process.env.NODE_ENV === "production" ? new InvariantError(2) : new InvariantError("Network request failed. " + label + " is not serializable: " + e.message);
            parseError.parseError = e;
            throw parseError;
        }
        return serialized;
    };
    var selectURI = function (operation, fallbackURI) {
        var context = operation.getContext();
        var contextURI = context.uri;
        if (contextURI) {
            return contextURI;
        }
        else if (typeof fallbackURI === 'function') {
            return fallbackURI(operation);
        }
        else {
            return fallbackURI || '/graphql';
        }
    };
    //# sourceMappingURL=bundle.esm.js.map

    var createHttpLink = function (linkOptions) {
        if (linkOptions === void 0) { linkOptions = {}; }
        var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, fetcher = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, requestOptions = __rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries"]);
        checkFetcher(fetcher);
        if (!fetcher) {
            fetcher = fetch;
        }
        var linkConfig = {
            http: { includeExtensions: includeExtensions },
            options: requestOptions.fetchOptions,
            credentials: requestOptions.credentials,
            headers: requestOptions.headers,
        };
        return new ApolloLink(function (operation) {
            var chosenURI = selectURI(operation, uri);
            var context = operation.getContext();
            var clientAwarenessHeaders = {};
            if (context.clientAwareness) {
                var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
                if (name_1) {
                    clientAwarenessHeaders['apollographql-client-name'] = name_1;
                }
                if (version) {
                    clientAwarenessHeaders['apollographql-client-version'] = version;
                }
            }
            var contextHeaders = __assign({}, clientAwarenessHeaders, context.headers);
            var contextConfig = {
                http: context.http,
                options: context.fetchOptions,
                credentials: context.credentials,
                headers: contextHeaders,
            };
            var _b = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
            var controller;
            if (!options.signal) {
                var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
                controller = _controller;
                if (controller)
                    options.signal = signal;
            }
            var definitionIsMutation = function (d) {
                return d.kind === 'OperationDefinition' && d.operation === 'mutation';
            };
            if (useGETForQueries &&
                !operation.query.definitions.some(definitionIsMutation)) {
                options.method = 'GET';
            }
            if (options.method === 'GET') {
                var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
                if (parseError) {
                    return fromError(parseError);
                }
                chosenURI = newURI;
            }
            else {
                try {
                    options.body = serializeFetchParameter(body, 'Payload');
                }
                catch (parseError) {
                    return fromError(parseError);
                }
            }
            return new Observable(function (observer) {
                fetcher(chosenURI, options)
                    .then(function (response) {
                    operation.setContext({ response: response });
                    return response;
                })
                    .then(parseAndCheckHttpResponse(operation))
                    .then(function (result) {
                    observer.next(result);
                    observer.complete();
                    return result;
                })
                    .catch(function (err) {
                    if (err.name === 'AbortError')
                        return;
                    if (err.result && err.result.errors && err.result.data) {
                        observer.next(err.result);
                    }
                    observer.error(err);
                });
                return function () {
                    if (controller)
                        controller.abort();
                };
            });
        });
    };
    function rewriteURIForGET(chosenURI, body) {
        var queryParams = [];
        var addQueryParam = function (key, value) {
            queryParams.push(key + "=" + encodeURIComponent(value));
        };
        if ('query' in body) {
            addQueryParam('query', body.query);
        }
        if (body.operationName) {
            addQueryParam('operationName', body.operationName);
        }
        if (body.variables) {
            var serializedVariables = void 0;
            try {
                serializedVariables = serializeFetchParameter(body.variables, 'Variables map');
            }
            catch (parseError) {
                return { parseError: parseError };
            }
            addQueryParam('variables', serializedVariables);
        }
        if (body.extensions) {
            var serializedExtensions = void 0;
            try {
                serializedExtensions = serializeFetchParameter(body.extensions, 'Extensions map');
            }
            catch (parseError) {
                return { parseError: parseError };
            }
            addQueryParam('extensions', serializedExtensions);
        }
        var fragment = '', preFragment = chosenURI;
        var fragmentStart = chosenURI.indexOf('#');
        if (fragmentStart !== -1) {
            fragment = chosenURI.substr(fragmentStart);
            preFragment = chosenURI.substr(0, fragmentStart);
        }
        var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
        var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
        return { newURI: newURI };
    }
    var HttpLink = (function (_super) {
        __extends(HttpLink, _super);
        function HttpLink(opts) {
            return _super.call(this, createHttpLink(opts).request) || this;
        }
        return HttpLink;
    }(ApolloLink));
    //# sourceMappingURL=bundle.esm.js.map

    function onError(errorHandler) {
        return new ApolloLink(function (operation, forward) {
            return new Observable(function (observer) {
                var sub;
                var retriedSub;
                var retriedResult;
                try {
                    sub = forward(operation).subscribe({
                        next: function (result) {
                            if (result.errors) {
                                retriedResult = errorHandler({
                                    graphQLErrors: result.errors,
                                    response: result,
                                    operation: operation,
                                    forward: forward,
                                });
                                if (retriedResult) {
                                    retriedSub = retriedResult.subscribe({
                                        next: observer.next.bind(observer),
                                        error: observer.error.bind(observer),
                                        complete: observer.complete.bind(observer),
                                    });
                                    return;
                                }
                            }
                            observer.next(result);
                        },
                        error: function (networkError) {
                            retriedResult = errorHandler({
                                operation: operation,
                                networkError: networkError,
                                graphQLErrors: networkError &&
                                    networkError.result &&
                                    networkError.result.errors,
                                forward: forward,
                            });
                            if (retriedResult) {
                                retriedSub = retriedResult.subscribe({
                                    next: observer.next.bind(observer),
                                    error: observer.error.bind(observer),
                                    complete: observer.complete.bind(observer),
                                });
                                return;
                            }
                            observer.error(networkError);
                        },
                        complete: function () {
                            if (!retriedResult) {
                                observer.complete.bind(observer)();
                            }
                        },
                    });
                }
                catch (e) {
                    errorHandler({ networkError: e, operation: operation, forward: forward });
                    observer.error(e);
                }
                return function () {
                    if (sub)
                        sub.unsubscribe();
                    if (retriedSub)
                        sub.unsubscribe();
                };
            });
        });
    }
    var ErrorLink = (function (_super) {
        __extends(ErrorLink, _super);
        function ErrorLink(errorHandler) {
            var _this = _super.call(this) || this;
            _this.link = onError(errorHandler);
            return _this;
        }
        ErrorLink.prototype.request = function (operation, forward) {
            return this.link.request(operation, forward);
        };
        return ErrorLink;
    }(ApolloLink));
    //# sourceMappingURL=bundle.esm.js.map

    /**
     * The `defineToJSON()` function defines toJSON() and inspect() prototype
     * methods, if no function provided they become aliases for toString().
     */

    function defineToJSON(classObject) {
      var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;
      classObject.prototype.toJSON = fn;
      classObject.prototype.inspect = fn;

      if (nodejsCustomInspectSymbol) {
        classObject.prototype[nodejsCustomInspectSymbol] = fn;
      }
    }

    function invariant$1(condition, message) {
      var booleanCondition = Boolean(condition);
      /* istanbul ignore else */

      if (!booleanCondition) {
        throw new Error(message);
      }
    }

    /**
     * The `defineToStringTag()` function checks first to see if the runtime
     * supports the `Symbol` class and then if the `Symbol.toStringTag` constant
     * is defined as a `Symbol` instance. If both conditions are met, the
     * Symbol.toStringTag property is defined as a getter that returns the
     * supplied class constructor's name.
     *
     * @method defineToStringTag
     *
     * @param {Class<any>} classObject a class such as Object, String, Number but
     * typically one of your own creation through the class keyword; `class A {}`,
     * for example.
     */
    function defineToStringTag(classObject) {
      if (typeof Symbol === 'function' && Symbol.toStringTag) {
        Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
          get: function get() {
            return this.constructor.name;
          }
        });
      }
    }

    /**
     * A representation of source input to GraphQL.
     * `name` and `locationOffset` are optional. They are useful for clients who
     * store GraphQL documents in source files; for example, if the GraphQL input
     * starts at line 40 in a file named Foo.graphql, it might be useful for name to
     * be "Foo.graphql" and location to be `{ line: 40, column: 0 }`.
     * line and column in locationOffset are 1-indexed
     */
    var Source = function Source(body, name, locationOffset) {
      this.body = body;
      this.name = name || 'GraphQL request';
      this.locationOffset = locationOffset || {
        line: 1,
        column: 1
      };
      !(this.locationOffset.line > 0) ? invariant$1(0, 'line in locationOffset is 1-indexed and must be positive') : void 0;
      !(this.locationOffset.column > 0) ? invariant$1(0, 'column in locationOffset is 1-indexed and must be positive') : void 0;
    }; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

    defineToStringTag(Source);

    function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

    /**
     * Return true if `value` is object-like. A value is object-like if it's not
     * `null` and has a `typeof` result of "object".
     */
    function isObjectLike(value) {
      return _typeof$1(value) == 'object' && value !== null;
    }

    /**
     * Represents a location in a Source.
     */

    /**
     * Takes a Source and a UTF-8 character offset, and returns the corresponding
     * line and column as a SourceLocation.
     */
    function getLocation(source, position) {
      var lineRegexp = /\r\n|[\n\r]/g;
      var line = 1;
      var column = position + 1;
      var match;

      while ((match = lineRegexp.exec(source.body)) && match.index < position) {
        line += 1;
        column = position + 1 - (match.index + match[0].length);
      }

      return {
        line: line,
        column: column
      };
    }

    /**
     * Render a helpful description of the location in the GraphQL Source document.
     */

    function printLocation(location) {
      return printSourceLocation(location.source, getLocation(location.source, location.start));
    }
    /**
     * Render a helpful description of the location in the GraphQL Source document.
     */

    function printSourceLocation(source, sourceLocation) {
      var firstLineColumnOffset = source.locationOffset.column - 1;
      var body = whitespace(firstLineColumnOffset) + source.body;
      var lineIndex = sourceLocation.line - 1;
      var lineOffset = source.locationOffset.line - 1;
      var lineNum = sourceLocation.line + lineOffset;
      var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      var columnNum = sourceLocation.column + columnOffset;
      var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
      var lines = body.split(/\r\n|[\n\r]/g);
      var locationLine = lines[lineIndex]; // Special case for minified documents

      if (locationLine.length > 120) {
        var sublineIndex = Math.floor(columnNum / 80);
        var sublineColumnNum = columnNum % 80;
        var sublines = [];

        for (var i = 0; i < locationLine.length; i += 80) {
          sublines.push(locationLine.slice(i, i + 80));
        }

        return locationStr + printPrefixedLines([["".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {
          return ['', subline];
        }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));
      }

      return locationStr + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
      ["".concat(lineNum - 1), lines[lineIndex - 1]], ["".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1), lines[lineIndex + 1]]]);
    }

    function printPrefixedLines(lines) {
      var existingLines = lines.filter(function (_ref) {
        var _ = _ref[0],
            line = _ref[1];
        return line !== undefined;
      });
      var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {
        var prefix = _ref2[0];
        return prefix.length;
      }));
      return existingLines.map(function (_ref3) {
        var prefix = _ref3[0],
            line = _ref3[1];
        return lpad(padLen, prefix) + ' | ' + line;
      }).join('\n');
    }

    function whitespace(len) {
      return Array(len + 1).join(' ');
    }

    function lpad(len, str) {
      return whitespace(len - str.length) + str;
    }

    /**
     * A GraphQLError describes an Error found during the parse, validate, or
     * execute phases of performing a GraphQL operation. In addition to a message
     * and stack trace, it also includes information about the locations in a
     * GraphQL document and/or execution result that correspond to the Error.
     */

    function GraphQLError( // eslint-disable-line no-redeclare
    message, nodes, source, positions, path, originalError, extensions) {
      // Compute list of blame nodes.
      var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.


      var _source = source;

      if (!_source && _nodes) {
        var node = _nodes[0];
        _source = node && node.loc && node.loc.source;
      }

      var _positions = positions;

      if (!_positions && _nodes) {
        _positions = _nodes.reduce(function (list, node) {
          if (node.loc) {
            list.push(node.loc.start);
          }

          return list;
        }, []);
      }

      if (_positions && _positions.length === 0) {
        _positions = undefined;
      }

      var _locations;

      if (positions && source) {
        _locations = positions.map(function (pos) {
          return getLocation(source, pos);
        });
      } else if (_nodes) {
        _locations = _nodes.reduce(function (list, node) {
          if (node.loc) {
            list.push(getLocation(node.loc.source, node.loc.start));
          }

          return list;
        }, []);
      }

      var _extensions = extensions;

      if (_extensions == null && originalError != null) {
        var originalExtensions = originalError.extensions;

        if (isObjectLike(originalExtensions)) {
          _extensions = originalExtensions;
        }
      }

      Object.defineProperties(this, {
        message: {
          value: message,
          // By being enumerable, JSON.stringify will include `message` in the
          // resulting output. This ensures that the simplest possible GraphQL
          // service adheres to the spec.
          enumerable: true,
          writable: true
        },
        locations: {
          // Coercing falsey values to undefined ensures they will not be included
          // in JSON.stringify() when not provided.
          value: _locations || undefined,
          // By being enumerable, JSON.stringify will include `locations` in the
          // resulting output. This ensures that the simplest possible GraphQL
          // service adheres to the spec.
          enumerable: Boolean(_locations)
        },
        path: {
          // Coercing falsey values to undefined ensures they will not be included
          // in JSON.stringify() when not provided.
          value: path || undefined,
          // By being enumerable, JSON.stringify will include `path` in the
          // resulting output. This ensures that the simplest possible GraphQL
          // service adheres to the spec.
          enumerable: Boolean(path)
        },
        nodes: {
          value: _nodes || undefined
        },
        source: {
          value: _source || undefined
        },
        positions: {
          value: _positions || undefined
        },
        originalError: {
          value: originalError
        },
        extensions: {
          // Coercing falsey values to undefined ensures they will not be included
          // in JSON.stringify() when not provided.
          value: _extensions || undefined,
          // By being enumerable, JSON.stringify will include `path` in the
          // resulting output. This ensures that the simplest possible GraphQL
          // service adheres to the spec.
          enumerable: Boolean(_extensions)
        }
      }); // Include (non-enumerable) stack trace.

      if (originalError && originalError.stack) {
        Object.defineProperty(this, 'stack', {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, GraphQLError);
      } else {
        Object.defineProperty(this, 'stack', {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    GraphQLError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: GraphQLError
      },
      name: {
        value: 'GraphQLError'
      },
      toString: {
        value: function toString() {
          return printError(this);
        }
      }
    });
    /**
     * Prints a GraphQLError to a string, representing useful location information
     * about the error's position in the source.
     */

    function printError(error) {
      var output = error.message;

      if (error.nodes) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = error.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            if (node.loc) {
              output += '\n\n' + printLocation(node.loc);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (error.source && error.locations) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = error.locations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var location = _step2.value;
            output += '\n\n' + printSourceLocation(error.source, location);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return output;
    }

    /**
     * Produces a GraphQLError representing a syntax error, containing useful
     * descriptive information about the syntax error's position in the source.
     */

    function syntaxError(source, position, description) {
      return new GraphQLError("Syntax Error: ".concat(description), undefined, source, [position]);
    }

    /**
     * An exported enum describing the different kinds of tokens that the
     * lexer emits.
     */
    var TokenKind = Object.freeze({
      SOF: '<SOF>',
      EOF: '<EOF>',
      BANG: '!',
      DOLLAR: '$',
      AMP: '&',
      PAREN_L: '(',
      PAREN_R: ')',
      SPREAD: '...',
      COLON: ':',
      EQUALS: '=',
      AT: '@',
      BRACKET_L: '[',
      BRACKET_R: ']',
      BRACE_L: '{',
      PIPE: '|',
      BRACE_R: '}',
      NAME: 'Name',
      INT: 'Int',
      FLOAT: 'Float',
      STRING: 'String',
      BLOCK_STRING: 'BlockString',
      COMMENT: 'Comment'
    });
    /**
     * The enum type representing the token kinds values.
     */

    /**
     * Given a Source object, this returns a Lexer for that source.
     * A Lexer is a stateful stream generator in that every time
     * it is advanced, it returns the next token in the Source. Assuming the
     * source lexes, the final Token emitted by the lexer will be of kind
     * EOF, after which the lexer will repeatedly return the same EOF token
     * whenever called.
     */

    function createLexer(source, options) {
      var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);
      var lexer = {
        source: source,
        options: options,
        lastToken: startOfFileToken,
        token: startOfFileToken,
        line: 1,
        lineStart: 0,
        advance: advanceLexer,
        lookahead: lookahead
      };
      return lexer;
    }

    function advanceLexer() {
      this.lastToken = this.token;
      var token = this.token = this.lookahead();
      return token;
    }

    function lookahead() {
      var token = this.token;

      if (token.kind !== TokenKind.EOF) {
        do {
          // Note: next is only mutable during parsing, so we cast to allow this.
          token = token.next || (token.next = readToken(this, token));
        } while (token.kind === TokenKind.COMMENT);
      }

      return token;
    }
    /**
     * A helper function to describe a token as a string for debugging
     */

    function getTokenDesc(token) {
      var value = token.value;
      return value ? "".concat(token.kind, " \"").concat(value, "\"") : token.kind;
    }
    /**
     * Helper function for constructing the Token object.
     */

    function Tok(kind, start, end, line, column, prev, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = prev;
      this.next = null;
    } // Print a simplified form when appearing in JSON/util.inspect.


    defineToJSON(Tok, function () {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    });

    function printCharCode(code) {
      return (// NaN/undefined represents access beyond the end of the file.
        isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.
        code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.
        "\"\\u".concat(('00' + code.toString(16).toUpperCase()).slice(-4), "\"")
      );
    }
    /**
     * Gets the next token from the source starting at the given position.
     *
     * This skips over whitespace until it finds the next lexable token, then lexes
     * punctuators immediately or calls the appropriate helper function for more
     * complicated tokens.
     */


    function readToken(lexer, prev) {
      var source = lexer.source;
      var body = source.body;
      var bodyLength = body.length;
      var pos = positionAfterWhitespace(body, prev.end, lexer);
      var line = lexer.line;
      var col = 1 + pos - lexer.lineStart;

      if (pos >= bodyLength) {
        return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
      }

      var code = body.charCodeAt(pos); // SourceCharacter

      switch (code) {
        // !
        case 33:
          return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);
        // #

        case 35:
          return readComment(source, pos, line, col, prev);
        // $

        case 36:
          return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);
        // &

        case 38:
          return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);
        // (

        case 40:
          return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);
        // )

        case 41:
          return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);
        // .

        case 46:
          if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
            return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);
          }

          break;
        // :

        case 58:
          return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);
        // =

        case 61:
          return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);
        // @

        case 64:
          return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);
        // [

        case 91:
          return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);
        // ]

        case 93:
          return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);
        // {

        case 123:
          return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);
        // |

        case 124:
          return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);
        // }

        case 125:
          return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);
        // A-Z _ a-z

        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 95:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          return readName(source, pos, line, col, prev);
        // - 0-9

        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return readNumber(source, pos, code, line, col, prev);
        // "

        case 34:
          if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
            return readBlockString(source, pos, line, col, prev, lexer);
          }

          return readString(source, pos, line, col, prev);
      }

      throw syntaxError(source, pos, unexpectedCharacterMessage(code));
    }
    /**
     * Report a message that an unexpected character was encountered.
     */


    function unexpectedCharacterMessage(code) {
      if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
        return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
      }

      if (code === 39) {
        // '
        return 'Unexpected single quote character (\'), did you mean to use a double quote (")?';
      }

      return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
    }
    /**
     * Reads from body starting at startPosition until it finds a non-whitespace
     * character, then returns the position of that character for lexing.
     */


    function positionAfterWhitespace(body, startPosition, lexer) {
      var bodyLength = body.length;
      var position = startPosition;

      while (position < bodyLength) {
        var code = body.charCodeAt(position); // tab | space | comma | BOM

        if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {
          ++position;
        } else if (code === 10) {
          // new line
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
        } else if (code === 13) {
          // carriage return
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }

          ++lexer.line;
          lexer.lineStart = position;
        } else {
          break;
        }
      }

      return position;
    }
    /**
     * Reads a comment token from the source file.
     *
     * #[\u0009\u0020-\uFFFF]*
     */


    function readComment(source, start, line, col, prev) {
      var body = source.body;
      var code;
      var position = start;

      do {
        code = body.charCodeAt(++position);
      } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator
      code > 0x001f || code === 0x0009));

      return new Tok(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
    }
    /**
     * Reads a number token from the source file, either a float
     * or an int depending on whether a decimal point appears.
     *
     * Int:   -?(0|[1-9][0-9]*)
     * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
     */


    function readNumber(source, start, firstCode, line, col, prev) {
      var body = source.body;
      var code = firstCode;
      var position = start;
      var isFloat = false;

      if (code === 45) {
        // -
        code = body.charCodeAt(++position);
      }

      if (code === 48) {
        // 0
        code = body.charCodeAt(++position);

        if (code >= 48 && code <= 57) {
          throw syntaxError(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
        }
      } else {
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }

      if (code === 46) {
        // .
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }

      if (code === 69 || code === 101) {
        // E e
        isFloat = true;
        code = body.charCodeAt(++position);

        if (code === 43 || code === 45) {
          // + -
          code = body.charCodeAt(++position);
        }

        position = readDigits(source, position, code);
      }

      return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
    }
    /**
     * Returns the new position in the source after reading digits.
     */


    function readDigits(source, start, firstCode) {
      var body = source.body;
      var position = start;
      var code = firstCode;

      if (code >= 48 && code <= 57) {
        // 0 - 9
        do {
          code = body.charCodeAt(++position);
        } while (code >= 48 && code <= 57); // 0 - 9


        return position;
      }

      throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
    }
    /**
     * Reads a string token from the source file.
     *
     * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
     */


    function readString(source, start, line, col, prev) {
      var body = source.body;
      var position = start + 1;
      var chunkStart = position;
      var code = 0;
      var value = '';

      while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator
      code !== 0x000a && code !== 0x000d) {
        // Closing Quote (")
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);
        } // SourceCharacter


        if (code < 0x0020 && code !== 0x0009) {
          throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }

        ++position;

        if (code === 92) {
          // \
          value += body.slice(chunkStart, position - 1);
          code = body.charCodeAt(position);

          switch (code) {
            case 34:
              value += '"';
              break;

            case 47:
              value += '/';
              break;

            case 92:
              value += '\\';
              break;

            case 98:
              value += '\b';
              break;

            case 102:
              value += '\f';
              break;

            case 110:
              value += '\n';
              break;

            case 114:
              value += '\r';
              break;

            case 116:
              value += '\t';
              break;

            case 117:
              {
                // uXXXX
                var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));

                if (charCode < 0) {
                  var invalidSequence = body.slice(position + 1, position + 5);
                  throw syntaxError(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
                }

                value += String.fromCharCode(charCode);
                position += 4;
                break;
              }

            default:
              throw syntaxError(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
          }

          ++position;
          chunkStart = position;
        }
      }

      throw syntaxError(source, position, 'Unterminated string.');
    }
    /**
     * Reads a block string token from the source file.
     *
     * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
     */


    function readBlockString(source, start, line, col, prev, lexer) {
      var body = source.body;
      var position = start + 3;
      var chunkStart = position;
      var code = 0;
      var rawValue = '';

      while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
        // Closing Triple-Quote (""")
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          rawValue += body.slice(chunkStart, position);
          return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));
        } // SourceCharacter


        if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
          throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }

        if (code === 10) {
          // new line
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
        } else if (code === 13) {
          // carriage return
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }

          ++lexer.line;
          lexer.lineStart = position;
        } else if ( // Escape Triple-Quote (\""")
        code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          rawValue += body.slice(chunkStart, position) + '"""';
          position += 4;
          chunkStart = position;
        } else {
          ++position;
        }
      }

      throw syntaxError(source, position, 'Unterminated string.');
    }
    /**
     * Converts four hexadecimal chars to the integer that the
     * string represents. For example, uniCharCode('0','0','0','f')
     * will return 15, and uniCharCode('0','0','f','f') returns 255.
     *
     * Returns a negative number on error, if a char was invalid.
     *
     * This is implemented by noting that char2hex() returns -1 on error,
     * which means the result of ORing the char2hex() will also be negative.
     */


    function uniCharCode(a, b, c, d) {
      return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
    }
    /**
     * Converts a hex character to its integer value.
     * '0' becomes 0, '9' becomes 9
     * 'A' becomes 10, 'F' becomes 15
     * 'a' becomes 10, 'f' becomes 15
     *
     * Returns -1 on error.
     */


    function char2hex(a) {
      return a >= 48 && a <= 57 ? a - 48 // 0-9
      : a >= 65 && a <= 70 ? a - 55 // A-F
      : a >= 97 && a <= 102 ? a - 87 // a-f
      : -1;
    }
    /**
     * Reads an alphanumeric + underscore name from the source.
     *
     * [_A-Za-z][_0-9A-Za-z]*
     */


    function readName(source, start, line, col, prev) {
      var body = source.body;
      var bodyLength = body.length;
      var position = start + 1;
      var code = 0;

      while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _
      code >= 48 && code <= 57 || // 0-9
      code >= 65 && code <= 90 || // A-Z
      code >= 97 && code <= 122) // a-z
      ) {
        ++position;
      }

      return new Tok(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
    }

    /**
     * The set of allowed kind values for AST nodes.
     */
    var Kind = Object.freeze({
      // Name
      NAME: 'Name',
      // Document
      DOCUMENT: 'Document',
      OPERATION_DEFINITION: 'OperationDefinition',
      VARIABLE_DEFINITION: 'VariableDefinition',
      SELECTION_SET: 'SelectionSet',
      FIELD: 'Field',
      ARGUMENT: 'Argument',
      // Fragments
      FRAGMENT_SPREAD: 'FragmentSpread',
      INLINE_FRAGMENT: 'InlineFragment',
      FRAGMENT_DEFINITION: 'FragmentDefinition',
      // Values
      VARIABLE: 'Variable',
      INT: 'IntValue',
      FLOAT: 'FloatValue',
      STRING: 'StringValue',
      BOOLEAN: 'BooleanValue',
      NULL: 'NullValue',
      ENUM: 'EnumValue',
      LIST: 'ListValue',
      OBJECT: 'ObjectValue',
      OBJECT_FIELD: 'ObjectField',
      // Directives
      DIRECTIVE: 'Directive',
      // Types
      NAMED_TYPE: 'NamedType',
      LIST_TYPE: 'ListType',
      NON_NULL_TYPE: 'NonNullType',
      // Type System Definitions
      SCHEMA_DEFINITION: 'SchemaDefinition',
      OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
      // Type Definitions
      SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
      OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
      FIELD_DEFINITION: 'FieldDefinition',
      INPUT_VALUE_DEFINITION: 'InputValueDefinition',
      INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
      UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
      ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
      ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
      INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
      // Directive Definitions
      DIRECTIVE_DEFINITION: 'DirectiveDefinition',
      // Type System Extensions
      SCHEMA_EXTENSION: 'SchemaExtension',
      // Type Extensions
      SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
      OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
      INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
      UNION_TYPE_EXTENSION: 'UnionTypeExtension',
      ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
      INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'
    });
    /**
     * The enum type representing the possible kind values of AST nodes.
     */

    /**
     * The set of allowed directive location values.
     */
    var DirectiveLocation = Object.freeze({
      // Request Definitions
      QUERY: 'QUERY',
      MUTATION: 'MUTATION',
      SUBSCRIPTION: 'SUBSCRIPTION',
      FIELD: 'FIELD',
      FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
      FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
      INLINE_FRAGMENT: 'INLINE_FRAGMENT',
      VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
      // Type System Definitions
      SCHEMA: 'SCHEMA',
      SCALAR: 'SCALAR',
      OBJECT: 'OBJECT',
      FIELD_DEFINITION: 'FIELD_DEFINITION',
      ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
      INTERFACE: 'INTERFACE',
      UNION: 'UNION',
      ENUM: 'ENUM',
      ENUM_VALUE: 'ENUM_VALUE',
      INPUT_OBJECT: 'INPUT_OBJECT',
      INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
    });
    /**
     * The enum type representing the directive location values.
     */

    /**
     * Configuration options to control parser behavior
     */

    /**
     * Given a GraphQL source, parses it into a Document.
     * Throws GraphQLError if a syntax error is encountered.
     */
    function parse(source, options) {
      var sourceObj = typeof source === 'string' ? new Source(source) : source;

      if (!(sourceObj instanceof Source)) {
        throw new TypeError("Must provide Source. Received: ".concat(inspect(sourceObj)));
      }

      var lexer = createLexer(sourceObj, options || {});
      return parseDocument(lexer);
    }
    /**
     * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
     * that value.
     * Throws GraphQLError if a syntax error is encountered.
     *
     * This is useful within tools that operate upon GraphQL Values directly and
     * in isolation of complete GraphQL documents.
     *
     * Consider providing the results to the utility function: valueFromAST().
     */

    function parseValue(source, options) {
      var sourceObj = typeof source === 'string' ? new Source(source) : source;
      var lexer = createLexer(sourceObj, options || {});
      expectToken(lexer, TokenKind.SOF);
      var value = parseValueLiteral(lexer, false);
      expectToken(lexer, TokenKind.EOF);
      return value;
    }
    /**
     * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
     * that type.
     * Throws GraphQLError if a syntax error is encountered.
     *
     * This is useful within tools that operate upon GraphQL Types directly and
     * in isolation of complete GraphQL documents.
     *
     * Consider providing the results to the utility function: typeFromAST().
     */

    function parseType(source, options) {
      var sourceObj = typeof source === 'string' ? new Source(source) : source;
      var lexer = createLexer(sourceObj, options || {});
      expectToken(lexer, TokenKind.SOF);
      var type = parseTypeReference(lexer);
      expectToken(lexer, TokenKind.EOF);
      return type;
    }
    /**
     * Converts a name lex token into a name parse node.
     */

    function parseName(lexer) {
      var token = expectToken(lexer, TokenKind.NAME);
      return {
        kind: Kind.NAME,
        value: token.value,
        loc: loc(lexer, token)
      };
    } // Implements the parsing rules in the Document section.

    /**
     * Document : Definition+
     */


    function parseDocument(lexer) {
      var start = lexer.token;
      return {
        kind: Kind.DOCUMENT,
        definitions: many(lexer, TokenKind.SOF, parseDefinition, TokenKind.EOF),
        loc: loc(lexer, start)
      };
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     */


    function parseDefinition(lexer) {
      if (peek(lexer, TokenKind.NAME)) {
        switch (lexer.token.value) {
          case 'query':
          case 'mutation':
          case 'subscription':
          case 'fragment':
            return parseExecutableDefinition(lexer);

          case 'schema':
          case 'scalar':
          case 'type':
          case 'interface':
          case 'union':
          case 'enum':
          case 'input':
          case 'directive':
            return parseTypeSystemDefinition(lexer);

          case 'extend':
            return parseTypeSystemExtension(lexer);
        }
      } else if (peek(lexer, TokenKind.BRACE_L)) {
        return parseExecutableDefinition(lexer);
      } else if (peekDescription(lexer)) {
        return parseTypeSystemDefinition(lexer);
      }

      throw unexpected(lexer);
    }
    /**
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     */


    function parseExecutableDefinition(lexer) {
      if (peek(lexer, TokenKind.NAME)) {
        switch (lexer.token.value) {
          case 'query':
          case 'mutation':
          case 'subscription':
            return parseOperationDefinition(lexer);

          case 'fragment':
            return parseFragmentDefinition(lexer);
        }
      } else if (peek(lexer, TokenKind.BRACE_L)) {
        return parseOperationDefinition(lexer);
      }

      throw unexpected(lexer);
    } // Implements the parsing rules in the Operations section.

    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */


    function parseOperationDefinition(lexer) {
      var start = lexer.token;

      if (peek(lexer, TokenKind.BRACE_L)) {
        return {
          kind: Kind.OPERATION_DEFINITION,
          operation: 'query',
          name: undefined,
          variableDefinitions: [],
          directives: [],
          selectionSet: parseSelectionSet(lexer),
          loc: loc(lexer, start)
        };
      }

      var operation = parseOperationType(lexer);
      var name;

      if (peek(lexer, TokenKind.NAME)) {
        name = parseName(lexer);
      }

      return {
        kind: Kind.OPERATION_DEFINITION,
        operation: operation,
        name: name,
        variableDefinitions: parseVariableDefinitions(lexer),
        directives: parseDirectives(lexer, false),
        selectionSet: parseSelectionSet(lexer),
        loc: loc(lexer, start)
      };
    }
    /**
     * OperationType : one of query mutation subscription
     */


    function parseOperationType(lexer) {
      var operationToken = expectToken(lexer, TokenKind.NAME);

      switch (operationToken.value) {
        case 'query':
          return 'query';

        case 'mutation':
          return 'mutation';

        case 'subscription':
          return 'subscription';
      }

      throw unexpected(lexer, operationToken);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */


    function parseVariableDefinitions(lexer) {
      return peek(lexer, TokenKind.PAREN_L) ? many(lexer, TokenKind.PAREN_L, parseVariableDefinition, TokenKind.PAREN_R) : [];
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */


    function parseVariableDefinition(lexer) {
      var start = lexer.token;
      return {
        kind: Kind.VARIABLE_DEFINITION,
        variable: parseVariable(lexer),
        type: (expectToken(lexer, TokenKind.COLON), parseTypeReference(lexer)),
        defaultValue: expectOptionalToken(lexer, TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined,
        directives: parseDirectives(lexer, true),
        loc: loc(lexer, start)
      };
    }
    /**
     * Variable : $ Name
     */


    function parseVariable(lexer) {
      var start = lexer.token;
      expectToken(lexer, TokenKind.DOLLAR);
      return {
        kind: Kind.VARIABLE,
        name: parseName(lexer),
        loc: loc(lexer, start)
      };
    }
    /**
     * SelectionSet : { Selection+ }
     */


    function parseSelectionSet(lexer) {
      var start = lexer.token;
      return {
        kind: Kind.SELECTION_SET,
        selections: many(lexer, TokenKind.BRACE_L, parseSelection, TokenKind.BRACE_R),
        loc: loc(lexer, start)
      };
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */


    function parseSelection(lexer) {
      return peek(lexer, TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */


    function parseField(lexer) {
      var start = lexer.token;
      var nameOrAlias = parseName(lexer);
      var alias;
      var name;

      if (expectOptionalToken(lexer, TokenKind.COLON)) {
        alias = nameOrAlias;
        name = parseName(lexer);
      } else {
        name = nameOrAlias;
      }

      return {
        kind: Kind.FIELD,
        alias: alias,
        name: name,
        arguments: parseArguments(lexer, false),
        directives: parseDirectives(lexer, false),
        selectionSet: peek(lexer, TokenKind.BRACE_L) ? parseSelectionSet(lexer) : undefined,
        loc: loc(lexer, start)
      };
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */


    function parseArguments(lexer, isConst) {
      var item = isConst ? parseConstArgument : parseArgument;
      return peek(lexer, TokenKind.PAREN_L) ? many(lexer, TokenKind.PAREN_L, item, TokenKind.PAREN_R) : [];
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */


    function parseArgument(lexer) {
      var start = lexer.token;
      var name = parseName(lexer);
      expectToken(lexer, TokenKind.COLON);
      return {
        kind: Kind.ARGUMENT,
        name: name,
        value: parseValueLiteral(lexer, false),
        loc: loc(lexer, start)
      };
    }

    function parseConstArgument(lexer) {
      var start = lexer.token;
      return {
        kind: Kind.ARGUMENT,
        name: parseName(lexer),
        value: (expectToken(lexer, TokenKind.COLON), parseConstValue(lexer)),
        loc: loc(lexer, start)
      };
    } // Implements the parsing rules in the Fragments section.

    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */


    function parseFragment(lexer) {
      var start = lexer.token;
      expectToken(lexer, TokenKind.SPREAD);
      var hasTypeCondition = expectOptionalKeyword(lexer, 'on');

      if (!hasTypeCondition && peek(lexer, TokenKind.NAME)) {
        return {
          kind: Kind.FRAGMENT_SPREAD,
          name: parseFragmentName(lexer),
          directives: parseDirectives(lexer, false),
          loc: loc(lexer, start)
        };
      }

      return {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? parseNamedType(lexer) : undefined,
        directives: parseDirectives(lexer, false),
        selectionSet: parseSelectionSet(lexer),
        loc: loc(lexer, start)
      };
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */


    function parseFragmentDefinition(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'fragment'); // Experimental support for defining variables within fragments changes
      // the grammar of FragmentDefinition:
      //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet

      if (lexer.options.experimentalFragmentVariables) {
        return {
          kind: Kind.FRAGMENT_DEFINITION,
          name: parseFragmentName(lexer),
          variableDefinitions: parseVariableDefinitions(lexer),
          typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),
          directives: parseDirectives(lexer, false),
          selectionSet: parseSelectionSet(lexer),
          loc: loc(lexer, start)
        };
      }

      return {
        kind: Kind.FRAGMENT_DEFINITION,
        name: parseFragmentName(lexer),
        typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),
        directives: parseDirectives(lexer, false),
        selectionSet: parseSelectionSet(lexer),
        loc: loc(lexer, start)
      };
    }
    /**
     * FragmentName : Name but not `on`
     */


    function parseFragmentName(lexer) {
      if (lexer.token.value === 'on') {
        throw unexpected(lexer);
      }

      return parseName(lexer);
    } // Implements the parsing rules in the Values section.

    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */


    function parseValueLiteral(lexer, isConst) {
      var token = lexer.token;

      switch (token.kind) {
        case TokenKind.BRACKET_L:
          return parseList(lexer, isConst);

        case TokenKind.BRACE_L:
          return parseObject(lexer, isConst);

        case TokenKind.INT:
          lexer.advance();
          return {
            kind: Kind.INT,
            value: token.value,
            loc: loc(lexer, token)
          };

        case TokenKind.FLOAT:
          lexer.advance();
          return {
            kind: Kind.FLOAT,
            value: token.value,
            loc: loc(lexer, token)
          };

        case TokenKind.STRING:
        case TokenKind.BLOCK_STRING:
          return parseStringLiteral(lexer);

        case TokenKind.NAME:
          if (token.value === 'true' || token.value === 'false') {
            lexer.advance();
            return {
              kind: Kind.BOOLEAN,
              value: token.value === 'true',
              loc: loc(lexer, token)
            };
          } else if (token.value === 'null') {
            lexer.advance();
            return {
              kind: Kind.NULL,
              loc: loc(lexer, token)
            };
          }

          lexer.advance();
          return {
            kind: Kind.ENUM,
            value: token.value,
            loc: loc(lexer, token)
          };

        case TokenKind.DOLLAR:
          if (!isConst) {
            return parseVariable(lexer);
          }

          break;
      }

      throw unexpected(lexer);
    }

    function parseStringLiteral(lexer) {
      var token = lexer.token;
      lexer.advance();
      return {
        kind: Kind.STRING,
        value: token.value,
        block: token.kind === TokenKind.BLOCK_STRING,
        loc: loc(lexer, token)
      };
    }

    function parseConstValue(lexer) {
      return parseValueLiteral(lexer, true);
    }

    function parseValueValue(lexer) {
      return parseValueLiteral(lexer, false);
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */


    function parseList(lexer, isConst) {
      var start = lexer.token;
      var item = isConst ? parseConstValue : parseValueValue;
      return {
        kind: Kind.LIST,
        values: any(lexer, TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
        loc: loc(lexer, start)
      };
    }
    /**
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     */


    function parseObject(lexer, isConst) {
      var start = lexer.token;

      var item = function item() {
        return parseObjectField(lexer, isConst);
      };

      return {
        kind: Kind.OBJECT,
        fields: any(lexer, TokenKind.BRACE_L, item, TokenKind.BRACE_R),
        loc: loc(lexer, start)
      };
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */


    function parseObjectField(lexer, isConst) {
      var start = lexer.token;
      var name = parseName(lexer);
      expectToken(lexer, TokenKind.COLON);
      return {
        kind: Kind.OBJECT_FIELD,
        name: name,
        value: parseValueLiteral(lexer, isConst),
        loc: loc(lexer, start)
      };
    } // Implements the parsing rules in the Directives section.

    /**
     * Directives[Const] : Directive[?Const]+
     */


    function parseDirectives(lexer, isConst) {
      var directives = [];

      while (peek(lexer, TokenKind.AT)) {
        directives.push(parseDirective(lexer, isConst));
      }

      return directives;
    }
    /**
     * Directive[Const] : @ Name Arguments[?Const]?
     */


    function parseDirective(lexer, isConst) {
      var start = lexer.token;
      expectToken(lexer, TokenKind.AT);
      return {
        kind: Kind.DIRECTIVE,
        name: parseName(lexer),
        arguments: parseArguments(lexer, isConst),
        loc: loc(lexer, start)
      };
    } // Implements the parsing rules in the Types section.

    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */


    function parseTypeReference(lexer) {
      var start = lexer.token;
      var type;

      if (expectOptionalToken(lexer, TokenKind.BRACKET_L)) {
        type = parseTypeReference(lexer);
        expectToken(lexer, TokenKind.BRACKET_R);
        type = {
          kind: Kind.LIST_TYPE,
          type: type,
          loc: loc(lexer, start)
        };
      } else {
        type = parseNamedType(lexer);
      }

      if (expectOptionalToken(lexer, TokenKind.BANG)) {
        return {
          kind: Kind.NON_NULL_TYPE,
          type: type,
          loc: loc(lexer, start)
        };
      }

      return type;
    }
    /**
     * NamedType : Name
     */

    function parseNamedType(lexer) {
      var start = lexer.token;
      return {
        kind: Kind.NAMED_TYPE,
        name: parseName(lexer),
        loc: loc(lexer, start)
      };
    } // Implements the parsing rules in the Type Definition section.

    /**
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */

    function parseTypeSystemDefinition(lexer) {
      // Many definitions begin with a description and require a lookahead.
      var keywordToken = peekDescription(lexer) ? lexer.lookahead() : lexer.token;

      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case 'schema':
            return parseSchemaDefinition(lexer);

          case 'scalar':
            return parseScalarTypeDefinition(lexer);

          case 'type':
            return parseObjectTypeDefinition(lexer);

          case 'interface':
            return parseInterfaceTypeDefinition(lexer);

          case 'union':
            return parseUnionTypeDefinition(lexer);

          case 'enum':
            return parseEnumTypeDefinition(lexer);

          case 'input':
            return parseInputObjectTypeDefinition(lexer);

          case 'directive':
            return parseDirectiveDefinition(lexer);
        }
      }

      throw unexpected(lexer, keywordToken);
    }

    function peekDescription(lexer) {
      return peek(lexer, TokenKind.STRING) || peek(lexer, TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */


    function parseDescription(lexer) {
      if (peekDescription(lexer)) {
        return parseStringLiteral(lexer);
      }
    }
    /**
     * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }
     */


    function parseSchemaDefinition(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'schema');
      var directives = parseDirectives(lexer, true);
      var operationTypes = many(lexer, TokenKind.BRACE_L, parseOperationTypeDefinition, TokenKind.BRACE_R);
      return {
        kind: Kind.SCHEMA_DEFINITION,
        directives: directives,
        operationTypes: operationTypes,
        loc: loc(lexer, start)
      };
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */


    function parseOperationTypeDefinition(lexer) {
      var start = lexer.token;
      var operation = parseOperationType(lexer);
      expectToken(lexer, TokenKind.COLON);
      var type = parseNamedType(lexer);
      return {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation: operation,
        type: type,
        loc: loc(lexer, start)
      };
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */


    function parseScalarTypeDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      expectKeyword(lexer, 'scalar');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      return {
        kind: Kind.SCALAR_TYPE_DEFINITION,
        description: description,
        name: name,
        directives: directives,
        loc: loc(lexer, start)
      };
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */


    function parseObjectTypeDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      expectKeyword(lexer, 'type');
      var name = parseName(lexer);
      var interfaces = parseImplementsInterfaces(lexer);
      var directives = parseDirectives(lexer, true);
      var fields = parseFieldsDefinition(lexer);
      return {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        description: description,
        name: name,
        interfaces: interfaces,
        directives: directives,
        fields: fields,
        loc: loc(lexer, start)
      };
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */


    function parseImplementsInterfaces(lexer) {
      var types = [];

      if (expectOptionalKeyword(lexer, 'implements')) {
        // Optional leading ampersand
        expectOptionalToken(lexer, TokenKind.AMP);

        do {
          types.push(parseNamedType(lexer));
        } while (expectOptionalToken(lexer, TokenKind.AMP) || // Legacy support for the SDL?
        lexer.options.allowLegacySDLImplementsInterfaces && peek(lexer, TokenKind.NAME));
      }

      return types;
    }
    /**
     * FieldsDefinition : { FieldDefinition+ }
     */


    function parseFieldsDefinition(lexer) {
      // Legacy support for the SDL?
      if (lexer.options.allowLegacySDLEmptyFields && peek(lexer, TokenKind.BRACE_L) && lexer.lookahead().kind === TokenKind.BRACE_R) {
        lexer.advance();
        lexer.advance();
        return [];
      }

      return peek(lexer, TokenKind.BRACE_L) ? many(lexer, TokenKind.BRACE_L, parseFieldDefinition, TokenKind.BRACE_R) : [];
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */


    function parseFieldDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      var name = parseName(lexer);
      var args = parseArgumentDefs(lexer);
      expectToken(lexer, TokenKind.COLON);
      var type = parseTypeReference(lexer);
      var directives = parseDirectives(lexer, true);
      return {
        kind: Kind.FIELD_DEFINITION,
        description: description,
        name: name,
        arguments: args,
        type: type,
        directives: directives,
        loc: loc(lexer, start)
      };
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */


    function parseArgumentDefs(lexer) {
      if (!peek(lexer, TokenKind.PAREN_L)) {
        return [];
      }

      return many(lexer, TokenKind.PAREN_L, parseInputValueDef, TokenKind.PAREN_R);
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */


    function parseInputValueDef(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      var name = parseName(lexer);
      expectToken(lexer, TokenKind.COLON);
      var type = parseTypeReference(lexer);
      var defaultValue;

      if (expectOptionalToken(lexer, TokenKind.EQUALS)) {
        defaultValue = parseConstValue(lexer);
      }

      var directives = parseDirectives(lexer, true);
      return {
        kind: Kind.INPUT_VALUE_DEFINITION,
        description: description,
        name: name,
        type: type,
        defaultValue: defaultValue,
        directives: directives,
        loc: loc(lexer, start)
      };
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */


    function parseInterfaceTypeDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      expectKeyword(lexer, 'interface');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      var fields = parseFieldsDefinition(lexer);
      return {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        description: description,
        name: name,
        directives: directives,
        fields: fields,
        loc: loc(lexer, start)
      };
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */


    function parseUnionTypeDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      expectKeyword(lexer, 'union');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      var types = parseUnionMemberTypes(lexer);
      return {
        kind: Kind.UNION_TYPE_DEFINITION,
        description: description,
        name: name,
        directives: directives,
        types: types,
        loc: loc(lexer, start)
      };
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */


    function parseUnionMemberTypes(lexer) {
      var types = [];

      if (expectOptionalToken(lexer, TokenKind.EQUALS)) {
        // Optional leading pipe
        expectOptionalToken(lexer, TokenKind.PIPE);

        do {
          types.push(parseNamedType(lexer));
        } while (expectOptionalToken(lexer, TokenKind.PIPE));
      }

      return types;
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */


    function parseEnumTypeDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      expectKeyword(lexer, 'enum');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      var values = parseEnumValuesDefinition(lexer);
      return {
        kind: Kind.ENUM_TYPE_DEFINITION,
        description: description,
        name: name,
        directives: directives,
        values: values,
        loc: loc(lexer, start)
      };
    }
    /**
     * EnumValuesDefinition : { EnumValueDefinition+ }
     */


    function parseEnumValuesDefinition(lexer) {
      return peek(lexer, TokenKind.BRACE_L) ? many(lexer, TokenKind.BRACE_L, parseEnumValueDefinition, TokenKind.BRACE_R) : [];
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     *
     * EnumValue : Name
     */


    function parseEnumValueDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      return {
        kind: Kind.ENUM_VALUE_DEFINITION,
        description: description,
        name: name,
        directives: directives,
        loc: loc(lexer, start)
      };
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */


    function parseInputObjectTypeDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      expectKeyword(lexer, 'input');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      var fields = parseInputFieldsDefinition(lexer);
      return {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: description,
        name: name,
        directives: directives,
        fields: fields,
        loc: loc(lexer, start)
      };
    }
    /**
     * InputFieldsDefinition : { InputValueDefinition+ }
     */


    function parseInputFieldsDefinition(lexer) {
      return peek(lexer, TokenKind.BRACE_L) ? many(lexer, TokenKind.BRACE_L, parseInputValueDef, TokenKind.BRACE_R) : [];
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */


    function parseTypeSystemExtension(lexer) {
      var keywordToken = lexer.lookahead();

      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case 'schema':
            return parseSchemaExtension(lexer);

          case 'scalar':
            return parseScalarTypeExtension(lexer);

          case 'type':
            return parseObjectTypeExtension(lexer);

          case 'interface':
            return parseInterfaceTypeExtension(lexer);

          case 'union':
            return parseUnionTypeExtension(lexer);

          case 'enum':
            return parseEnumTypeExtension(lexer);

          case 'input':
            return parseInputObjectTypeExtension(lexer);
        }
      }

      throw unexpected(lexer, keywordToken);
    }
    /**
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     */


    function parseSchemaExtension(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'extend');
      expectKeyword(lexer, 'schema');
      var directives = parseDirectives(lexer, true);
      var operationTypes = peek(lexer, TokenKind.BRACE_L) ? many(lexer, TokenKind.BRACE_L, parseOperationTypeDefinition, TokenKind.BRACE_R) : [];

      if (directives.length === 0 && operationTypes.length === 0) {
        throw unexpected(lexer);
      }

      return {
        kind: Kind.SCHEMA_EXTENSION,
        directives: directives,
        operationTypes: operationTypes,
        loc: loc(lexer, start)
      };
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */


    function parseScalarTypeExtension(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'extend');
      expectKeyword(lexer, 'scalar');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);

      if (directives.length === 0) {
        throw unexpected(lexer);
      }

      return {
        kind: Kind.SCALAR_TYPE_EXTENSION,
        name: name,
        directives: directives,
        loc: loc(lexer, start)
      };
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */


    function parseObjectTypeExtension(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'extend');
      expectKeyword(lexer, 'type');
      var name = parseName(lexer);
      var interfaces = parseImplementsInterfaces(lexer);
      var directives = parseDirectives(lexer, true);
      var fields = parseFieldsDefinition(lexer);

      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw unexpected(lexer);
      }

      return {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        name: name,
        interfaces: interfaces,
        directives: directives,
        fields: fields,
        loc: loc(lexer, start)
      };
    }
    /**
     * InterfaceTypeExtension :
     *   - extend interface Name Directives[Const]? FieldsDefinition
     *   - extend interface Name Directives[Const]
     */


    function parseInterfaceTypeExtension(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'extend');
      expectKeyword(lexer, 'interface');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      var fields = parseFieldsDefinition(lexer);

      if (directives.length === 0 && fields.length === 0) {
        throw unexpected(lexer);
      }

      return {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        name: name,
        directives: directives,
        fields: fields,
        loc: loc(lexer, start)
      };
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */


    function parseUnionTypeExtension(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'extend');
      expectKeyword(lexer, 'union');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      var types = parseUnionMemberTypes(lexer);

      if (directives.length === 0 && types.length === 0) {
        throw unexpected(lexer);
      }

      return {
        kind: Kind.UNION_TYPE_EXTENSION,
        name: name,
        directives: directives,
        types: types,
        loc: loc(lexer, start)
      };
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */


    function parseEnumTypeExtension(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'extend');
      expectKeyword(lexer, 'enum');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      var values = parseEnumValuesDefinition(lexer);

      if (directives.length === 0 && values.length === 0) {
        throw unexpected(lexer);
      }

      return {
        kind: Kind.ENUM_TYPE_EXTENSION,
        name: name,
        directives: directives,
        values: values,
        loc: loc(lexer, start)
      };
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */


    function parseInputObjectTypeExtension(lexer) {
      var start = lexer.token;
      expectKeyword(lexer, 'extend');
      expectKeyword(lexer, 'input');
      var name = parseName(lexer);
      var directives = parseDirectives(lexer, true);
      var fields = parseInputFieldsDefinition(lexer);

      if (directives.length === 0 && fields.length === 0) {
        throw unexpected(lexer);
      }

      return {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name: name,
        directives: directives,
        fields: fields,
        loc: loc(lexer, start)
      };
    }
    /**
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     */


    function parseDirectiveDefinition(lexer) {
      var start = lexer.token;
      var description = parseDescription(lexer);
      expectKeyword(lexer, 'directive');
      expectToken(lexer, TokenKind.AT);
      var name = parseName(lexer);
      var args = parseArgumentDefs(lexer);
      var repeatable = expectOptionalKeyword(lexer, 'repeatable');
      expectKeyword(lexer, 'on');
      var locations = parseDirectiveLocations(lexer);
      return {
        kind: Kind.DIRECTIVE_DEFINITION,
        description: description,
        name: name,
        arguments: args,
        repeatable: repeatable,
        locations: locations,
        loc: loc(lexer, start)
      };
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */


    function parseDirectiveLocations(lexer) {
      // Optional leading pipe
      expectOptionalToken(lexer, TokenKind.PIPE);
      var locations = [];

      do {
        locations.push(parseDirectiveLocation(lexer));
      } while (expectOptionalToken(lexer, TokenKind.PIPE));

      return locations;
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */


    function parseDirectiveLocation(lexer) {
      var start = lexer.token;
      var name = parseName(lexer);

      if (DirectiveLocation[name.value] !== undefined) {
        return name;
      }

      throw unexpected(lexer, start);
    } // Core parsing utility functions

    /**
     * Returns a location object, used to identify the place in
     * the source that created a given parsed object.
     */


    function loc(lexer, startToken) {
      if (!lexer.options.noLocation) {
        return new Loc(startToken, lexer.lastToken, lexer.source);
      }
    }

    function Loc(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    } // Print a simplified form when appearing in JSON/util.inspect.


    defineToJSON(Loc, function () {
      return {
        start: this.start,
        end: this.end
      };
    });
    /**
     * Determines if the next token is of a given kind
     */

    function peek(lexer, kind) {
      return lexer.token.kind === kind;
    }
    /**
     * If the next token is of the given kind, return that token after advancing
     * the lexer. Otherwise, do not change the parser state and throw an error.
     */


    function expectToken(lexer, kind) {
      var token = lexer.token;

      if (token.kind === kind) {
        lexer.advance();
        return token;
      }

      throw syntaxError(lexer.source, token.start, "Expected ".concat(kind, ", found ").concat(getTokenDesc(token)));
    }
    /**
     * If the next token is of the given kind, return that token after advancing
     * the lexer. Otherwise, do not change the parser state and return undefined.
     */


    function expectOptionalToken(lexer, kind) {
      var token = lexer.token;

      if (token.kind === kind) {
        lexer.advance();
        return token;
      }

      return undefined;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */


    function expectKeyword(lexer, value) {
      var token = lexer.token;

      if (token.kind === TokenKind.NAME && token.value === value) {
        lexer.advance();
      } else {
        throw syntaxError(lexer.source, token.start, "Expected \"".concat(value, "\", found ").concat(getTokenDesc(token)));
      }
    }
    /**
     * If the next token is a given keyword, return "true" after advancing
     * the lexer. Otherwise, do not change the parser state and return "false".
     */


    function expectOptionalKeyword(lexer, value) {
      var token = lexer.token;

      if (token.kind === TokenKind.NAME && token.value === value) {
        lexer.advance();
        return true;
      }

      return false;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token
     * is encountered.
     */


    function unexpected(lexer, atToken) {
      var token = atToken || lexer.token;
      return syntaxError(lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token)));
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by
     * the parseFn. This list begins with a lex token of openKind
     * and ends with a lex token of closeKind. Advances the parser
     * to the next lex token after the closing token.
     */


    function any(lexer, openKind, parseFn, closeKind) {
      expectToken(lexer, openKind);
      var nodes = [];

      while (!expectOptionalToken(lexer, closeKind)) {
        nodes.push(parseFn(lexer));
      }

      return nodes;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by
     * the parseFn. This list begins with a lex token of openKind
     * and ends with a lex token of closeKind. Advances the parser
     * to the next lex token after the closing token.
     */


    function many(lexer, openKind, parseFn, closeKind) {
      expectToken(lexer, openKind);
      var nodes = [parseFn(lexer)];

      while (!expectOptionalToken(lexer, closeKind)) {
        nodes.push(parseFn(lexer));
      }

      return nodes;
    }

    var parser = /*#__PURE__*/Object.freeze({
        parse: parse,
        parseValue: parseValue,
        parseType: parseType,
        parseConstValue: parseConstValue,
        parseTypeReference: parseTypeReference,
        parseNamedType: parseNamedType
    });

    var parser$1 = getCjsExportFromNamespace(parser);

    var parse$1 = parser$1.parse;

    // Strip insignificant whitespace
    // Note that this could do a lot more, such as reorder fields etc.
    function normalize(string) {
      return string.replace(/[\s,]+/g, ' ').trim();
    }

    // A map docString -> graphql document
    var docCache = {};

    // A map fragmentName -> [normalized source]
    var fragmentSourceMap = {};

    function cacheKeyFromLoc(loc) {
      return normalize(loc.source.body.substring(loc.start, loc.end));
    }

    // For testing.
    function resetCaches() {
      docCache = {};
      fragmentSourceMap = {};
    }

    // Take a unstripped parsed document (query/mutation or even fragment), and
    // check all fragment definitions, checking for name->source uniqueness.
    // We also want to make sure only unique fragments exist in the document.
    var printFragmentWarnings = true;
    function processFragments(ast) {
      var astFragmentMap = {};
      var definitions = [];

      for (var i = 0; i < ast.definitions.length; i++) {
        var fragmentDefinition = ast.definitions[i];

        if (fragmentDefinition.kind === 'FragmentDefinition') {
          var fragmentName = fragmentDefinition.name.value;
          var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);

          // We know something about this fragment
          if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {

            // this is a problem because the app developer is trying to register another fragment with
            // the same name as one previously registered. So, we tell them about it.
            if (printFragmentWarnings) {
              console.warn("Warning: fragment with name " + fragmentName + " already exists.\n"
                + "graphql-tag enforces all fragment names across your application to be unique; read more about\n"
                + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
            }

            fragmentSourceMap[fragmentName][sourceKey] = true;

          } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {
            fragmentSourceMap[fragmentName] = {};
            fragmentSourceMap[fragmentName][sourceKey] = true;
          }

          if (!astFragmentMap[sourceKey]) {
            astFragmentMap[sourceKey] = true;
            definitions.push(fragmentDefinition);
          }
        } else {
          definitions.push(fragmentDefinition);
        }
      }

      ast.definitions = definitions;
      return ast;
    }

    function disableFragmentWarnings() {
      printFragmentWarnings = false;
    }

    function stripLoc(doc, removeLocAtThisLevel) {
      var docType = Object.prototype.toString.call(doc);

      if (docType === '[object Array]') {
        return doc.map(function (d) {
          return stripLoc(d, removeLocAtThisLevel);
        });
      }

      if (docType !== '[object Object]') {
        throw new Error('Unexpected input.');
      }

      // We don't want to remove the root loc field so we can use it
      // for fragment substitution (see below)
      if (removeLocAtThisLevel && doc.loc) {
        delete doc.loc;
      }

      // https://github.com/apollographql/graphql-tag/issues/40
      if (doc.loc) {
        delete doc.loc.startToken;
        delete doc.loc.endToken;
      }

      var keys = Object.keys(doc);
      var key;
      var value;
      var valueType;

      for (key in keys) {
        if (keys.hasOwnProperty(key)) {
          value = doc[keys[key]];
          valueType = Object.prototype.toString.call(value);

          if (valueType === '[object Object]' || valueType === '[object Array]') {
            doc[keys[key]] = stripLoc(value, true);
          }
        }
      }

      return doc;
    }

    var experimentalFragmentVariables = false;
    function parseDocument$1(doc) {
      var cacheKey = normalize(doc);

      if (docCache[cacheKey]) {
        return docCache[cacheKey];
      }

      var parsed = parse$1(doc, { experimentalFragmentVariables: experimentalFragmentVariables });
      if (!parsed || parsed.kind !== 'Document') {
        throw new Error('Not a valid GraphQL document.');
      }

      // check that all "new" fragments inside the documents are consistent with
      // existing fragments of the same name
      parsed = processFragments(parsed);
      parsed = stripLoc(parsed, false);
      docCache[cacheKey] = parsed;

      return parsed;
    }

    function enableExperimentalFragmentVariables() {
      experimentalFragmentVariables = true;
    }

    function disableExperimentalFragmentVariables() {
      experimentalFragmentVariables = false;
    }

    // XXX This should eventually disallow arbitrary string interpolation, like Relay does
    function gql(/* arguments */) {
      var args = Array.prototype.slice.call(arguments);

      var literals = args[0];

      // We always get literals[0] and then matching post literals for each arg given
      var result = (typeof(literals) === "string") ? literals : literals[0];

      for (var i = 1; i < args.length; i++) {
        if (args[i] && args[i].kind && args[i].kind === 'Document') {
          result += args[i].loc.source.body;
        } else {
          result += args[i];
        }

        result += literals[i];
      }

      return parseDocument$1(result);
    }

    // Support typescript, which isn't as nice as Babel about default exports
    gql.default = gql;
    gql.resetCaches = resetCaches;
    gql.disableFragmentWarnings = disableFragmentWarnings;
    gql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
    gql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;

    var src = gql;

    var PRESET_CONFIG_KEYS = [
        'request',
        'uri',
        'credentials',
        'headers',
        'fetch',
        'fetchOptions',
        'clientState',
        'onError',
        'cacheRedirects',
        'cache',
        'name',
        'version',
        'resolvers',
        'typeDefs',
        'fragmentMatcher',
    ];
    var DefaultClient = (function (_super) {
        __extends(DefaultClient, _super);
        function DefaultClient(config) {
            if (config === void 0) { config = {}; }
            var _this = this;
            if (config) {
                var diff = Object.keys(config).filter(function (key) { return PRESET_CONFIG_KEYS.indexOf(key) === -1; });
                if (diff.length > 0) {
                    process.env.NODE_ENV === "production" || invariant.warn('ApolloBoost was initialized with unsupported options: ' +
                        ("" + diff.join(' ')));
                }
            }
            var request = config.request, uri = config.uri, credentials = config.credentials, headers = config.headers, fetch = config.fetch, fetchOptions = config.fetchOptions, clientState = config.clientState, cacheRedirects = config.cacheRedirects, errorCallback = config.onError, name = config.name, version = config.version, resolvers = config.resolvers, typeDefs = config.typeDefs, fragmentMatcher = config.fragmentMatcher;
            var cache = config.cache;
            process.env.NODE_ENV === "production" ? invariant(!cache || !cacheRedirects, 1) : invariant(!cache || !cacheRedirects, 'Incompatible cache configuration. When not providing `cache`, ' +
                'configure the provided instance with `cacheRedirects` instead.');
            if (!cache) {
                cache = cacheRedirects
                    ? new InMemoryCache({ cacheRedirects: cacheRedirects })
                    : new InMemoryCache();
            }
            var errorLink = errorCallback
                ? onError(errorCallback)
                : onError(function (_a) {
                    var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError;
                    if (graphQLErrors) {
                        graphQLErrors.map(function (_a) {
                            var message = _a.message, locations = _a.locations, path = _a.path;
                            return process.env.NODE_ENV === "production" || invariant.warn("[GraphQL error]: Message: " + message + ", Location: " +
                                (locations + ", Path: " + path));
                        });
                    }
                    if (networkError) {
                        process.env.NODE_ENV === "production" || invariant.warn("[Network error]: " + networkError);
                    }
                });
            var requestHandler = request
                ? new ApolloLink(function (operation, forward) {
                    return new Observable(function (observer) {
                        var handle;
                        Promise.resolve(operation)
                            .then(function (oper) { return request(oper); })
                            .then(function () {
                            handle = forward(operation).subscribe({
                                next: observer.next.bind(observer),
                                error: observer.error.bind(observer),
                                complete: observer.complete.bind(observer),
                            });
                        })
                            .catch(observer.error.bind(observer));
                        return function () {
                            if (handle) {
                                handle.unsubscribe();
                            }
                        };
                    });
                })
                : false;
            var httpLink = new HttpLink({
                uri: uri || '/graphql',
                fetch: fetch,
                fetchOptions: fetchOptions || {},
                credentials: credentials || 'same-origin',
                headers: headers || {},
            });
            var link = ApolloLink.from([errorLink, requestHandler, httpLink].filter(function (x) { return !!x; }));
            var activeResolvers = resolvers;
            var activeTypeDefs = typeDefs;
            var activeFragmentMatcher = fragmentMatcher;
            if (clientState) {
                if (clientState.defaults) {
                    cache.writeData({
                        data: clientState.defaults,
                    });
                }
                activeResolvers = clientState.resolvers;
                activeTypeDefs = clientState.typeDefs;
                activeFragmentMatcher = clientState.fragmentMatcher;
            }
            _this = _super.call(this, {
                cache: cache,
                link: link,
                name: name,
                version: version,
                resolvers: activeResolvers,
                typeDefs: activeTypeDefs,
                fragmentMatcher: activeFragmentMatcher,
            }) || this;
            return _this;
        }
        return DefaultClient;
    }(ApolloClient));
    //# sourceMappingURL=bundle.esm.js.map

    const DEFAULT_CONFIG = {
      // minimum relative difference between two compared values,
      // used by all comparison functions
      epsilon: 1e-12,

      // type of default matrix output. Choose 'matrix' (default) or 'array'
      matrix: 'Matrix',

      // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
      number: 'number',

      // number of significant digits in BigNumbers
      precision: 64,

      // predictable output type of functions. When true, output type depends only
      // on the input types. When false (default), output type can vary depending
      // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
      // predictable is false, and returns `NaN` when true.
      predictable: false,

      // random seed for seeded pseudo random number generation
      // null = randomly seed
      randomSeed: null
    };

    // type checks for all known types
    //
    // note that:
    //
    // - check by duck-typing on a property like `isUnit`, instead of checking instanceof.
    //   instanceof cannot be used because that would not allow to pass data from
    //   one instance of math.js to another since each has it's own instance of Unit.
    // - check the `isUnit` property via the constructor, so there will be no
    //   matches for "fake" instances like plain objects with a property `isUnit`.
    //   That is important for security reasons.
    // - It must not be possible to override the type checks used internally,
    //   for security reasons, so these functions are not exposed in the expression
    //   parser.

    function isNumber (x) {
      return typeof x === 'number'
    }

    function isBigNumber (x) {
      return (x && x.constructor.prototype.isBigNumber === true) || false
    }

    function isComplex (x) {
      return (x && typeof x === 'object' && Object.getPrototypeOf(x).isComplex === true) || false
    }

    function isFraction (x) {
      return (x && typeof x === 'object' && Object.getPrototypeOf(x).isFraction === true) || false
    }

    function isUnit (x) {
      return (x && x.constructor.prototype.isUnit === true) || false
    }

    function isString (x) {
      return typeof x === 'string'
    }

    const isArray = Array.isArray;

    function isMatrix (x) {
      return (x && x.constructor.prototype.isMatrix === true) || false
    }

    function isDenseMatrix (x) {
      return (x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true) || false
    }

    function isSparseMatrix (x) {
      return (x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true) || false
    }

    function isRange (x) {
      return (x && x.constructor.prototype.isRange === true) || false
    }

    function isIndex (x) {
      return (x && x.constructor.prototype.isIndex === true) || false
    }

    function isBoolean (x) {
      return typeof x === 'boolean'
    }

    function isResultSet (x) {
      return (x && x.constructor.prototype.isResultSet === true) || false
    }

    function isHelp (x) {
      return (x && x.constructor.prototype.isHelp === true) || false
    }

    function isFunction (x) {
      return typeof x === 'function'
    }

    function isDate (x) {
      return x instanceof Date
    }

    function isRegExp (x) {
      return x instanceof RegExp
    }

    function isObject$1 (x) {
      return !!(x &&
        typeof x === 'object' &&
        x.constructor === Object &&
        !isComplex(x) &&
        !isFraction(x))
    }

    function isNull (x) {
      return x === null
    }

    function isUndefined (x) {
      return x === undefined
    }

    function isAccessorNode (x) {
      return (x && x.isAccessorNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isArrayNode (x) {
      return (x && x.isArrayNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isAssignmentNode (x) {
      return (x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isBlockNode (x) {
      return (x && x.isBlockNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isConditionalNode (x) {
      return (x && x.isConditionalNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isConstantNode (x) {
      return (x && x.isConstantNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isFunctionAssignmentNode (x) {
      return (x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isFunctionNode (x) {
      return (x && x.isFunctionNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isIndexNode (x) {
      return (x && x.isIndexNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isNode$1 (x) {
      return (x && x.isNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isObjectNode (x) {
      return (x && x.isObjectNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isOperatorNode (x) {
      return (x && x.isOperatorNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isParenthesisNode (x) {
      return (x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isRangeNode (x) {
      return (x && x.isRangeNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isSymbolNode (x) {
      return (x && x.isSymbolNode === true && x.constructor.prototype.isNode === true) || false
    }

    function isChain (x) {
      return (x && x.constructor.prototype.isChain === true) || false
    }

    function typeOf (x) {
      const t = typeof x;

      if (t === 'object') {
        // JavaScript types
        if (x === null) return 'null'
        if (Array.isArray(x)) return 'Array'
        if (x instanceof Date) return 'Date'
        if (x instanceof RegExp) return 'RegExp'

        // math.js types
        if (isBigNumber(x)) return 'BigNumber'
        if (isComplex(x)) return 'Complex'
        if (isFraction(x)) return 'Fraction'
        if (isMatrix(x)) return 'Matrix'
        if (isUnit(x)) return 'Unit'
        if (isIndex(x)) return 'Index'
        if (isRange(x)) return 'Range'
        if (isResultSet(x)) return 'ResultSet'
        if (isNode$1(x)) return x.type
        if (isChain(x)) return 'Chain'
        if (isHelp(x)) return 'Help'

        return 'Object'
      }

      if (t === 'function') return 'Function'

      return t // can be 'string', 'number', 'boolean', ...
    }

    /**
     * Clone an object
     *
     *     clone(x)
     *
     * Can clone any primitive type, array, and object.
     * If x has a function clone, this function will be invoked to clone the object.
     *
     * @param {*} x
     * @return {*} clone
     */
    function clone (x) {
      const type = typeof x;

      // immutable primitive types
      if (type === 'number' || type === 'string' || type === 'boolean' ||
          x === null || x === undefined) {
        return x
      }

      // use clone function of the object when available
      if (typeof x.clone === 'function') {
        return x.clone()
      }

      // array
      if (Array.isArray(x)) {
        return x.map(function (value) {
          return clone(value)
        })
      }

      if (x instanceof Date) return new Date(x.valueOf())
      if (isBigNumber(x)) return x // bignumbers are immutable
      if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x) // TODO: clone a RegExp

      // object
      return mapObject(x, clone)
    }

    /**
     * Apply map to all properties of an object
     * @param {Object} object
     * @param {function} callback
     * @return {Object} Returns a copy of the object with mapped properties
     */
    function mapObject (object, callback) {
      const clone = {};

      for (const key in object) {
        if (hasOwnProperty$3(object, key)) {
          clone[key] = callback(object[key]);
        }
      }

      return clone
    }

    /**
     * Deep test equality of all fields in two pairs of arrays or objects.
     * Compares values and functions strictly (ie. 2 is not the same as '2').
     * @param {Array | Object} a
     * @param {Array | Object} b
     * @returns {boolean}
     */
    function deepStrictEqual (a, b) {
      let prop, i, len;
      if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
          return false
        }

        if (a.length !== b.length) {
          return false
        }

        for (i = 0, len = a.length; i < len; i++) {
          if (!deepStrictEqual(a[i], b[i])) {
            return false
          }
        }
        return true
      } else if (typeof a === 'function') {
        return (a === b)
      } else if (a instanceof Object) {
        if (Array.isArray(b) || !(b instanceof Object)) {
          return false
        }

        for (prop in a) {
          // noinspection JSUnfilteredForInLoop
          if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
            return false
          }
        }
        for (prop in b) {
          // noinspection JSUnfilteredForInLoop
          if (!(prop in a) || !deepStrictEqual(a[prop], b[prop])) {
            return false
          }
        }
        return true
      } else {
        return (a === b)
      }
    }

    /**
     * A safe hasOwnProperty
     * @param {Object} object
     * @param {string} property
     */
    function hasOwnProperty$3 (object, property) {
      return object && Object.hasOwnProperty.call(object, property)
    }

    /**
     * Shallow version of pick, creating an object composed of the picked object properties
     * but not for nested properties
     * @param {Object} object
     * @param {string[]} properties
     * @return {Object}
     */
    function pickShallow (object, properties) {
      const copy = {};

      for (let i = 0; i < properties.length; i++) {
        const key = properties[i];
        const value = object[key];
        if (value !== undefined) {
          copy[key] = value;
        }
      }

      return copy
    }

    const MATRIX_OPTIONS = ['Matrix', 'Array']; // valid values for option matrix
    const NUMBER_OPTIONS = ['number', 'BigNumber', 'Fraction']; // valid values for option number

    // create a read-only version of config
    const config = /* #__PURE__ */ function (options) {
      if (options) {
        throw new Error('The global config is readonly. \n' +
          'Please create a mathjs instance if you want to change the default configuration. \n' +
          'Example:\n' +
          '\n' +
          '  import { create, all } from \'mathjs\';\n' +
          '  const mathjs = create(all);\n' +
          '  mathjs.config({ number: \'BigNumber\' });\n')
      }

      return Object.freeze(DEFAULT_CONFIG)
    };
    Object.assign(config, DEFAULT_CONFIG, { MATRIX_OPTIONS, NUMBER_OPTIONS });

    var typedFunction = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // OldNode. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like OldNode.
        module.exports = factory();
      }
    }(commonjsGlobal, function () {

      function ok () {
        return true;
      }

      function notOk () {
        return false;
      }

      function undef () {
        return undefined;
      }

      /**
       * @typedef {{
       *   params: Param[],
       *   fn: function
       * }} Signature
       *
       * @typedef {{
       *   types: Type[],
       *   restParam: boolean
       * }} Param
       *
       * @typedef {{
       *   name: string,
       *   typeIndex: number,
       *   test: function,
       *   conversion?: ConversionDef,
       *   conversionIndex: number,
       * }} Type
       *
       * @typedef {{
       *   from: string,
       *   to: string,
       *   convert: function (*) : *
       * }} ConversionDef
       *
       * @typedef {{
       *   name: string,
       *   test: function(*) : boolean
       * }} TypeDef
       */

      // create a new instance of typed-function
      function create () {
        // data type tests
        var _types = [
          { name: 'number',    test: function (x) { return typeof x === 'number' } },
          { name: 'string',    test: function (x) { return typeof x === 'string' } },
          { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },
          { name: 'Function',  test: function (x) { return typeof x === 'function'} },
          { name: 'Array',     test: Array.isArray },
          { name: 'Date',      test: function (x) { return x instanceof Date } },
          { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },
          { name: 'Object',    test: function (x) {
            return typeof x === 'object' && x.constructor === Object
          }},
          { name: 'null',      test: function (x) { return x === null } },
          { name: 'undefined', test: function (x) { return x === undefined } }
        ];

        var anyType = {
          name: 'any',
          test: ok
        };

        // types which need to be ignored
        var _ignore = [];

        // type conversions
        var _conversions = [];

        // This is a temporary object, will be replaced with a typed function at the end
        var typed = {
          types: _types,
          conversions: _conversions,
          ignore: _ignore
        };

        /**
         * Find the test function for a type
         * @param {String} typeName
         * @return {TypeDef} Returns the type definition when found,
         *                    Throws a TypeError otherwise
         */
        function findTypeByName (typeName) {
          var entry = findInArray(typed.types, function (entry) {
            return entry.name === typeName;
          });

          if (entry) {
            return entry;
          }

          if (typeName === 'any') { // special baked-in case 'any'
            return anyType;
          }

          var hint = findInArray(typed.types, function (entry) {
            return entry.name.toLowerCase() === typeName.toLowerCase();
          });

          throw new TypeError('Unknown type "' + typeName + '"' +
              (hint ? ('. Did you mean "' + hint.name + '"?') : ''));
        }

        /**
         * Find the index of a type definition. Handles special case 'any'
         * @param {TypeDef} type
         * @return {number}
         */
        function findTypeIndex(type) {
          if (type === anyType) {
            return 999;
          }

          return typed.types.indexOf(type);
        }

        /**
         * Find a type that matches a value.
         * @param {*} value
         * @return {string} Returns the name of the first type for which
         *                  the type test matches the value.
         */
        function findTypeName(value) {
          var entry = findInArray(typed.types, function (entry) {
            return entry.test(value);
          });

          if (entry) {
            return entry.name;
          }

          throw new TypeError('Value has unknown type. Value: ' + value);
        }

        /**
         * Find a specific signature from a (composed) typed function, for example:
         *
         *   typed.find(fn, ['number', 'string'])
         *   typed.find(fn, 'number, string')
         *
         * Function find only only works for exact matches.
         *
         * @param {Function} fn                   A typed-function
         * @param {string | string[]} signature   Signature to be found, can be
         *                                        an array or a comma separated string.
         * @return {Function}                     Returns the matching signature, or
         *                                        throws an error when no signature
         *                                        is found.
         */
        function find (fn, signature) {
          if (!fn.signatures) {
            throw new TypeError('Function is no typed-function');
          }

          // normalize input
          var arr;
          if (typeof signature === 'string') {
            arr = signature.split(',');
            for (var i = 0; i < arr.length; i++) {
              arr[i] = arr[i].trim();
            }
          }
          else if (Array.isArray(signature)) {
            arr = signature;
          }
          else {
            throw new TypeError('String array or a comma separated string expected');
          }

          var str = arr.join(',');

          // find an exact match
          var match = fn.signatures[str];
          if (match) {
            return match;
          }

          // TODO: extend find to match non-exact signatures

          throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');
        }

        /**
         * Convert a given value to another data type.
         * @param {*} value
         * @param {string} type
         */
        function convert (value, type) {
          var from = findTypeName(value);

          // check conversion is needed
          if (type === from) {
            return value;
          }

          for (var i = 0; i < typed.conversions.length; i++) {
            var conversion = typed.conversions[i];
            if (conversion.from === from && conversion.to === type) {
              return conversion.convert(value);
            }
          }

          throw new Error('Cannot convert from ' + from + ' to ' + type);
        }
        
        /**
         * Stringify parameters in a normalized way
         * @param {Param[]} params
         * @return {string}
         */
        function stringifyParams (params) {
          return params
              .map(function (param) {
                var typeNames = param.types.map(getTypeName);

                return (param.restParam ? '...' : '') + typeNames.join('|');
              })
              .join(',');
        }

        /**
         * Parse a parameter, like "...number | boolean"
         * @param {string} param
         * @param {ConversionDef[]} conversions
         * @return {Param} param
         */
        function parseParam (param, conversions) {
          var restParam = param.indexOf('...') === 0;
          var types = (!restParam)
              ? param
              : (param.length > 3)
                  ? param.slice(3)
                  : 'any';

          var typeNames = types.split('|').map(trim)
              .filter(notEmpty)
              .filter(notIgnore);

          var matchingConversions = filterConversions(conversions, typeNames);

          var exactTypes = typeNames.map(function (typeName) {
            var type = findTypeByName(typeName);

            return {
              name: typeName,
              typeIndex: findTypeIndex(type),
              test: type.test,
              conversion: null,
              conversionIndex: -1
            };
          });

          var convertibleTypes = matchingConversions.map(function (conversion) {
            var type = findTypeByName(conversion.from);

            return {
              name: conversion.from,
              typeIndex: findTypeIndex(type),
              test: type.test,
              conversion: conversion,
              conversionIndex: conversions.indexOf(conversion)
            };
          });

          return {
            types: exactTypes.concat(convertibleTypes),
            restParam: restParam
          };
        }

        /**
         * Parse a signature with comma separated parameters,
         * like "number | boolean, ...string"
         * @param {string} signature
         * @param {function} fn
         * @param {ConversionDef[]} conversions
         * @return {Signature | null} signature
         */
        function parseSignature (signature, fn, conversions) {
          var params = [];

          if (signature.trim() !== '') {
            params = signature
                .split(',')
                .map(trim)
                .map(function (param, index, array) {
                  var parsedParam = parseParam(param, conversions);

                  if (parsedParam.restParam && (index !== array.length - 1)) {
                    throw new SyntaxError('Unexpected rest parameter "' + param + '": ' +
                        'only allowed for the last parameter');
                  }

                  return parsedParam;
              });
          }

          if (params.some(isInvalidParam)) {
            // invalid signature: at least one parameter has no types
            // (they may have been filtered)
            return null;
          }

          return {
            params: params,
            fn: fn
          };
        }

        /**
         * Test whether a set of params contains a restParam
         * @param {Param[]} params
         * @return {boolean} Returns true when the last parameter is a restParam
         */
        function hasRestParam(params) {
          var param = last(params);
          return param ? param.restParam : false;
        }

        /**
         * Test whether a parameter contains conversions
         * @param {Param} param
         * @return {boolean} Returns true when at least one of the parameters
         *                   contains a conversion.
         */
        function hasConversions(param) {
          return param.types.some(function (type) {
            return type.conversion != null;
          });
        }

        /**
         * Create a type test for a single parameter, which can have one or multiple
         * types.
         * @param {Param} param
         * @return {function(x: *) : boolean} Returns a test function
         */
        function compileTest(param) {
          if (!param || param.types.length === 0) {
            // nothing to do
            return ok;
          }
          else if (param.types.length === 1) {
            return findTypeByName(param.types[0].name).test;
          }
          else if (param.types.length === 2) {
            var test0 = findTypeByName(param.types[0].name).test;
            var test1 = findTypeByName(param.types[1].name).test;
            return function or(x) {
              return test0(x) || test1(x);
            }
          }
          else { // param.types.length > 2
            var tests = param.types.map(function (type) {
              return findTypeByName(type.name).test;
            });
            return function or(x) {
              for (var i = 0; i < tests.length; i++) {
                if (tests[i](x)) {
                  return true;
                }
              }
              return false;
            }
          }
        }

        /**
         * Create a test for all parameters of a signature
         * @param {Param[]} params
         * @return {function(args: Array<*>) : boolean}
         */
        function compileTests(params) {
          var tests, test0, test1;

          if (hasRestParam(params)) {
            // variable arguments like '...number'
            tests = initial(params).map(compileTest);
            var varIndex = tests.length;
            var lastTest = compileTest(last(params));
            var testRestParam = function (args) {
              for (var i = varIndex; i < args.length; i++) {
                if (!lastTest(args[i])) {
                  return false;
                }
              }
              return true;
            };

            return function testArgs(args) {
              for (var i = 0; i < tests.length; i++) {
                if (!tests[i](args[i])) {
                  return false;
                }
              }
              return testRestParam(args) && (args.length >= varIndex + 1);
            };
          }
          else {
            // no variable arguments
            if (params.length === 0) {
              return function testArgs(args) {
                return args.length === 0;
              };
            }
            else if (params.length === 1) {
              test0 = compileTest(params[0]);
              return function testArgs(args) {
                return test0(args[0]) && args.length === 1;
              };
            }
            else if (params.length === 2) {
              test0 = compileTest(params[0]);
              test1 = compileTest(params[1]);
              return function testArgs(args) {
                return test0(args[0]) && test1(args[1]) && args.length === 2;
              };
            }
            else { // arguments.length > 2
              tests = params.map(compileTest);
              return function testArgs(args) {
                for (var i = 0; i < tests.length; i++) {
                  if (!tests[i](args[i])) {
                    return false;
                  }
                }
                return args.length === tests.length;
              };
            }
          }
        }

        /**
         * Find the parameter at a specific index of a signature.
         * Handles rest parameters.
         * @param {Signature} signature
         * @param {number} index
         * @return {Param | null} Returns the matching parameter when found,
         *                        null otherwise.
         */
        function getParamAtIndex(signature, index) {
          return index < signature.params.length
              ? signature.params[index]
              : hasRestParam(signature.params)
                  ? last(signature.params)
                  : null
        }

        /**
         * Get all type names of a parameter
         * @param {Signature} signature
         * @param {number} index
         * @param {boolean} excludeConversions
         * @return {string[]} Returns an array with type names
         */
        function getExpectedTypeNames (signature, index, excludeConversions) {
          var param = getParamAtIndex(signature, index);
          var types = param
              ? excludeConversions
                      ? param.types.filter(isExactType)
                      : param.types
              : [];

          return types.map(getTypeName);
        }

        /**
         * Returns the name of a type
         * @param {Type} type
         * @return {string} Returns the type name
         */
        function getTypeName(type) {
          return type.name;
        }

        /**
         * Test whether a type is an exact type or conversion
         * @param {Type} type
         * @return {boolean} Returns true when
         */
        function isExactType(type) {
          return type.conversion === null || type.conversion === undefined;
        }

        /**
         * Helper function for creating error messages: create an array with
         * all available types on a specific argument index.
         * @param {Signature[]} signatures
         * @param {number} index
         * @return {string[]} Returns an array with available types
         */
        function mergeExpectedParams(signatures, index) {
          var typeNames = uniq(flatMap(signatures, function (signature) {
            return getExpectedTypeNames(signature, index, false);
          }));

          return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;
        }

        /**
         * Create
         * @param {string} name             The name of the function
         * @param {array.<*>} args          The actual arguments passed to the function
         * @param {Signature[]} signatures  A list with available signatures
         * @return {TypeError} Returns a type error with additional data
         *                     attached to it in the property `data`
         */
        function createError(name, args, signatures) {
          var err, expected;
          var _name = name || 'unnamed';

          // test for wrong type at some index
          var matchingSignatures = signatures;
          var index;
          for (index = 0; index < args.length; index++) {
            var nextMatchingDefs = matchingSignatures.filter(function (signature) {
              var test = compileTest(getParamAtIndex(signature, index));
              return (index < signature.params.length || hasRestParam(signature.params)) &&
                  test(args[index]);
            });

            if (nextMatchingDefs.length === 0) {
              // no matching signatures anymore, throw error "wrong type"
              expected = mergeExpectedParams(matchingSignatures, index);
              if (expected.length > 0) {
                var actualType = findTypeName(args[index]);

                err = new TypeError('Unexpected type of argument in function ' + _name +
                    ' (expected: ' + expected.join(' or ') +
                    ', actual: ' + actualType + ', index: ' + index + ')');
                err.data = {
                  category: 'wrongType',
                  fn: _name,
                  index: index,
                  actual: actualType,
                  expected: expected
                };
                return err;
              }
            }
            else {
              matchingSignatures = nextMatchingDefs;
            }
          }

          // test for too few arguments
          var lengths = matchingSignatures.map(function (signature) {
            return hasRestParam(signature.params) ? Infinity : signature.params.length;
          });
          if (args.length < Math.min.apply(null, lengths)) {
            expected = mergeExpectedParams(matchingSignatures, index);
            err = new TypeError('Too few arguments in function ' + _name +
                ' (expected: ' + expected.join(' or ') +
                ', index: ' + args.length + ')');
            err.data = {
              category: 'tooFewArgs',
              fn: _name,
              index: args.length,
              expected: expected
            };
            return err;
          }

          // test for too many arguments
          var maxLength = Math.max.apply(null, lengths);
          if (args.length > maxLength) {
            err = new TypeError('Too many arguments in function ' + _name +
                ' (expected: ' + maxLength + ', actual: ' + args.length + ')');
            err.data = {
              category: 'tooManyArgs',
              fn: _name,
              index: args.length,
              expectedLength: maxLength
            };
            return err;
          }

          err = new TypeError('Arguments of type "' + args.join(', ') +
              '" do not match any of the defined signatures of function ' + _name + '.');
          err.data = {
            category: 'mismatch',
            actual: args.map(findTypeName)
          };
          return err;
        }

        /**
         * Find the lowest index of all exact types of a parameter (no conversions)
         * @param {Param} param
         * @return {number} Returns the index of the lowest type in typed.types
         */
        function getLowestTypeIndex (param) {
          var min = 999;

          for (var i = 0; i < param.types.length; i++) {
            if (isExactType(param.types[i])) {
              min = Math.min(min, param.types[i].typeIndex);
            }
          }

          return min;
        }

        /**
         * Find the lowest index of the conversion of all types of the parameter
         * having a conversion
         * @param {Param} param
         * @return {number} Returns the lowest index of the conversions of this type
         */
        function getLowestConversionIndex (param) {
          var min = 999;

          for (var i = 0; i < param.types.length; i++) {
            if (!isExactType(param.types[i])) {
              min = Math.min(min, param.types[i].conversionIndex);
            }
          }

          return min;
        }

        /**
         * Compare two params
         * @param {Param} param1
         * @param {Param} param2
         * @return {number} returns a negative number when param1 must get a lower
         *                  index than param2, a positive number when the opposite,
         *                  or zero when both are equal
         */
        function compareParams (param1, param2) {
          var c;

          // compare having a rest parameter or not
          c = param1.restParam - param2.restParam;
          if (c !== 0) {
            return c;
          }

          // compare having conversions or not
          c = hasConversions(param1) - hasConversions(param2);
          if (c !== 0) {
            return c;
          }

          // compare the index of the types
          c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
          if (c !== 0) {
            return c;
          }

          // compare the index of any conversion
          return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
        }

        /**
         * Compare two signatures
         * @param {Signature} signature1
         * @param {Signature} signature2
         * @return {number} returns a negative number when param1 must get a lower
         *                  index than param2, a positive number when the opposite,
         *                  or zero when both are equal
         */
        function compareSignatures (signature1, signature2) {
          var len = Math.min(signature1.params.length, signature2.params.length);
          var i;
          var c;

          // compare whether the params have conversions at all or not
          c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
          if (c !== 0) {
            return c;
          }

          // next compare whether the params have conversions one by one
          for (i = 0; i < len; i++) {
            c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);
            if (c !== 0) {
              return c;
            }
          }

          // compare the types of the params one by one
          for (i = 0; i < len; i++) {
            c = compareParams(signature1.params[i], signature2.params[i]);
            if (c !== 0) {
              return c;
            }
          }

          // compare the number of params
          return signature1.params.length - signature2.params.length;
        }

        /**
         * Get params containing all types that can be converted to the defined types.
         *
         * @param {ConversionDef[]} conversions
         * @param {string[]} typeNames
         * @return {ConversionDef[]} Returns the conversions that are available
         *                        for every type (if any)
         */
        function filterConversions(conversions, typeNames) {
          var matches = {};

          conversions.forEach(function (conversion) {
            if (typeNames.indexOf(conversion.from) === -1 &&
                typeNames.indexOf(conversion.to) !== -1 &&
                !matches[conversion.from]) {
              matches[conversion.from] = conversion;
            }
          });

          return Object.keys(matches).map(function (from) {
            return matches[from];
          });
        }

        /**
         * Preprocess arguments before calling the original function:
         * - if needed convert the parameters
         * - in case of rest parameters, move the rest parameters into an Array
         * @param {Param[]} params
         * @param {function} fn
         * @return {function} Returns a wrapped function
         */
        function compileArgsPreprocessing(params, fn) {
          var fnConvert = fn;

          // TODO: can we make this wrapper function smarter/simpler?

          if (params.some(hasConversions)) {
            var restParam = hasRestParam(params);
            var compiledConversions = params.map(compileArgConversion);

            fnConvert = function convertArgs() {
              var args = [];
              var last = restParam ? arguments.length - 1 : arguments.length;
              for (var i = 0; i < last; i++) {
                args[i] = compiledConversions[i](arguments[i]);
              }
              if (restParam) {
                args[last] = arguments[last].map(compiledConversions[last]);
              }

              return fn.apply(null, args);
            };
          }

          var fnPreprocess = fnConvert;
          if (hasRestParam(params)) {
            var offset = params.length - 1;

            fnPreprocess = function preprocessRestParams () {
              return fnConvert.apply(null,
                  slice(arguments, 0, offset).concat([slice(arguments, offset)]));
            };
          }

          return fnPreprocess;
        }

        /**
         * Compile conversion for a parameter to the right type
         * @param {Param} param
         * @return {function} Returns the wrapped function that will convert arguments
         *
         */
        function compileArgConversion(param) {
          var test0, test1, conversion0, conversion1;
          var tests = [];
          var conversions = [];

          param.types.forEach(function (type) {
            if (type.conversion) {
              tests.push(findTypeByName(type.conversion.from).test);
              conversions.push(type.conversion.convert);
            }
          });

          // create optimized conversion functions depending on the number of conversions
          switch (conversions.length) {
            case 0:
              return function convertArg(arg) {
                return arg;
              }

            case 1:
              test0 = tests[0];
              conversion0 = conversions[0];
              return function convertArg(arg) {
                if (test0(arg)) {
                  return conversion0(arg)
                }
                return arg;
              }

            case 2:
              test0 = tests[0];
              test1 = tests[1];
              conversion0 = conversions[0];
              conversion1 = conversions[1];
              return function convertArg(arg) {
                if (test0(arg)) {
                  return conversion0(arg)
                }
                if (test1(arg)) {
                  return conversion1(arg)
                }
                return arg;
              }

            default:
              return function convertArg(arg) {
                for (var i = 0; i < conversions.length; i++) {
                  if (tests[i](arg)) {
                    return conversions[i](arg);
                  }
                }
                return arg;
              }
          }
        }

        /**
         * Convert an array with signatures into a map with signatures,
         * where signatures with union types are split into separate signatures
         *
         * Throws an error when there are conflicting types
         *
         * @param {Signature[]} signatures
         * @return {Object.<string, function>}  Returns a map with signatures
         *                                      as key and the original function
         *                                      of this signature as value.
         */
        function createSignaturesMap(signatures) {
          var signaturesMap = {};
          signatures.forEach(function (signature) {
            if (!signature.params.some(hasConversions)) {
              splitParams(signature.params, true).forEach(function (params) {
                signaturesMap[stringifyParams(params)] = signature.fn;
              });
            }
          });

          return signaturesMap;
        }

        /**
         * Split params with union types in to separate params.
         *
         * For example:
         *
         *     splitParams([['Array', 'Object'], ['string', 'RegExp'])
         *     // returns:
         *     // [
         *     //   ['Array', 'string'],
         *     //   ['Array', 'RegExp'],
         *     //   ['Object', 'string'],
         *     //   ['Object', 'RegExp']
         *     // ]
         *
         * @param {Param[]} params
         * @param {boolean} ignoreConversionTypes
         * @return {Param[]}
         */
        function splitParams(params, ignoreConversionTypes) {
          function _splitParams(params, index, types) {
            if (index < params.length) {
              var param = params[index];
              var filteredTypes = ignoreConversionTypes
                  ? param.types.filter(isExactType)
                  : param.types;
              var typeGroups;

              if (param.restParam) {
                // split the types of a rest parameter in two:
                // one with only exact types, and one with exact types and conversions
                var exactTypes = filteredTypes.filter(isExactType);
                typeGroups = exactTypes.length < filteredTypes.length
                    ? [exactTypes, filteredTypes]
                    : [filteredTypes];

              }
              else {
                // split all the types of a regular parameter into one type per group
                typeGroups = filteredTypes.map(function (type) {
                  return [type]
                });
              }

              // recurse over the groups with types
              return flatMap(typeGroups, function (typeGroup) {
                return _splitParams(params, index + 1, types.concat([typeGroup]));
              });

            }
            else {
              // we've reached the end of the parameters. Now build a new Param
              var splittedParams = types.map(function (type, typeIndex) {
                return {
                  types: type,
                  restParam: (typeIndex === params.length - 1) && hasRestParam(params)
                }
              });

              return [splittedParams];
            }
          }

          return _splitParams(params, 0, []);
        }

        /**
         * Test whether two signatures have a conflicting signature
         * @param {Signature} signature1
         * @param {Signature} signature2
         * @return {boolean} Returns true when the signatures conflict, false otherwise.
         */
        function hasConflictingParams(signature1, signature2) {
          var ii = Math.max(signature1.params.length, signature2.params.length);

          for (var i = 0; i < ii; i++) {
            var typesNames1 = getExpectedTypeNames(signature1, i, true);
            var typesNames2 = getExpectedTypeNames(signature2, i, true);

            if (!hasOverlap(typesNames1, typesNames2)) {
              return false;
            }
          }

          var len1 = signature1.params.length;
          var len2 = signature2.params.length;
          var restParam1 = hasRestParam(signature1.params);
          var restParam2 = hasRestParam(signature2.params);

          return restParam1
              ? restParam2 ? (len1 === len2) : (len2 >= len1)
              : restParam2 ? (len1 >= len2)  : (len1 === len2)
        }

        /**
         * Create a typed function
         * @param {String} name               The name for the typed function
         * @param {Object.<string, function>} signaturesMap
         *                                    An object with one or
         *                                    multiple signatures as key, and the
         *                                    function corresponding to the
         *                                    signature as value.
         * @return {function}  Returns the created typed function.
         */
        function createTypedFunction(name, signaturesMap) {
          if (Object.keys(signaturesMap).length === 0) {
            throw new SyntaxError('No signatures provided');
          }

          // parse the signatures, and check for conflicts
          var parsedSignatures = [];
          Object.keys(signaturesMap)
              .map(function (signature) {
                return parseSignature(signature, signaturesMap[signature], typed.conversions);
              })
              .filter(notNull)
              .forEach(function (parsedSignature) {
                // check whether this parameter conflicts with already parsed signatures
                var conflictingSignature = findInArray(parsedSignatures, function (s) {
                  return hasConflictingParams(s, parsedSignature)
                });
                if (conflictingSignature) {
                  throw new TypeError('Conflicting signatures "' +
                      stringifyParams(conflictingSignature.params) + '" and "' +
                      stringifyParams(parsedSignature.params) + '".');
                }

                parsedSignatures.push(parsedSignature);
              });

          // split and filter the types of the signatures, and then order them
          var signatures = flatMap(parsedSignatures, function (parsedSignature) {
            var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];

            return params.map(function (params) {
              return {
                params: params,
                fn: parsedSignature.fn
              };
            });
          }).filter(notNull);

          signatures.sort(compareSignatures);

          // we create a highly optimized checks for the first couple of signatures with max 2 arguments
          var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
          var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
          var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
          var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
          var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
          var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
          var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;

          // compile the tests
          var tests = signatures.map(function (signature) {
            return compileTests(signature.params);
          });

          var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
          var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
          var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
          var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
          var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
          var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;

          var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
          var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
          var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
          var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
          var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
          var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;

          // compile the functions
          var fns = signatures.map(function(signature) {
            return compileArgsPreprocessing(signature.params, signature.fn)
          });

          var fn0 = ok0 ? fns[0] : undef;
          var fn1 = ok1 ? fns[1] : undef;
          var fn2 = ok2 ? fns[2] : undef;
          var fn3 = ok3 ? fns[3] : undef;
          var fn4 = ok4 ? fns[4] : undef;
          var fn5 = ok5 ? fns[5] : undef;

          var len0 = ok0 ? signatures[0].params.length : -1;
          var len1 = ok1 ? signatures[1].params.length : -1;
          var len2 = ok2 ? signatures[2].params.length : -1;
          var len3 = ok3 ? signatures[3].params.length : -1;
          var len4 = ok4 ? signatures[4].params.length : -1;
          var len5 = ok5 ? signatures[5].params.length : -1;

          // simple and generic, but also slow
          var iStart = allOk ? 6 : 0;
          var iEnd = signatures.length;
          var generic = function generic() {

            for (var i = iStart; i < iEnd; i++) {
              if (tests[i](arguments)) {
                return fns[i].apply(null, arguments);
              }
            }

            throw createError(name, arguments, signatures);
          };

          // create the typed function
          // fast, specialized version. Falls back to the slower, generic one if needed
          var fn = function fn(arg0, arg1) {

            if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(null, arguments); }
            if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(null, arguments); }
            if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(null, arguments); }
            if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(null, arguments); }
            if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(null, arguments); }
            if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(null, arguments); }

            return generic.apply(null, arguments);
          };

          // attach name the typed function
          try {
            Object.defineProperty(fn, 'name', {value: name});
          }
          catch (err) {
            // old browsers do not support Object.defineProperty and some don't support setting the name property
            // the function name is not essential for the functioning, it's mostly useful for debugging,
            // so it's fine to have unnamed functions.
          }

          // attach signatures to the function
          fn.signatures = createSignaturesMap(signatures);

          return fn;
        }

        /**
         * Test whether a type should be NOT be ignored
         * @param {string} typeName
         * @return {boolean}
         */
        function notIgnore(typeName) {
          return typed.ignore.indexOf(typeName) === -1;
        }

        /**
         * trim a string
         * @param {string} str
         * @return {string}
         */
        function trim(str) {
          return str.trim();
        }

        /**
         * Test whether a string is not empty
         * @param {string} str
         * @return {boolean}
         */
        function notEmpty(str) {
          return !!str;
        }

        /**
         * test whether a value is not strict equal to null
         * @param {*} value
         * @return {boolean}
         */
        function notNull(value) {
          return value !== null;
        }

        /**
         * Test whether a parameter has no types defined
         * @param {Param} param
         * @return {boolean}
         */
        function isInvalidParam (param) {
          return param.types.length === 0;
        }

        /**
         * Return all but the last items of an array
         * @param {Array} arr
         * @return {Array}
         */
        function initial(arr) {
          return arr.slice(0, arr.length - 1);
        }

        /**
         * return the last item of an array
         * @param {Array} arr
         * @return {*}
         */
        function last(arr) {
          return arr[arr.length - 1];
        }

        /**
         * Slice an array or function Arguments
         * @param {Array | Arguments | IArguments} arr
         * @param {number} start
         * @param {number} [end]
         * @return {Array}
         */
        function slice(arr, start, end) {
          return Array.prototype.slice.call(arr, start, end);
        }

        /**
         * Test whether an array contains some item
         * @param {Array} array
         * @param {*} item
         * @return {boolean} Returns true if array contains item, false if not.
         */
        function contains(array, item) {
          return array.indexOf(item) !== -1;
        }

        /**
         * Test whether two arrays have overlapping items
         * @param {Array} array1
         * @param {Array} array2
         * @return {boolean} Returns true when at least one item exists in both arrays
         */
        function hasOverlap(array1, array2) {
          for (var i = 0; i < array1.length; i++) {
            if (contains(array2, array1[i])) {
              return true;
            }
          }

          return false;
        }

        /**
         * Return the first item from an array for which test(arr[i]) returns true
         * @param {Array} arr
         * @param {function} test
         * @return {* | undefined} Returns the first matching item
         *                         or undefined when there is no match
         */
        function findInArray(arr, test) {
          for (var i = 0; i < arr.length; i++) {
            if (test(arr[i])) {
              return arr[i];
            }
          }
          return undefined;
        }

        /**
         * Filter unique items of an array with strings
         * @param {string[]} arr
         * @return {string[]}
         */
        function uniq(arr) {
          var entries = {};
          for (var i = 0; i < arr.length; i++) {
            entries[arr[i]] = true;
          }
          return Object.keys(entries);
        }

        /**
         * Flat map the result invoking a callback for every item in an array.
         * https://gist.github.com/samgiles/762ee337dff48623e729
         * @param {Array} arr
         * @param {function} callback
         * @return {Array}
         */
        function flatMap(arr, callback) {
          return Array.prototype.concat.apply([], arr.map(callback));
        }

        /**
         * Retrieve the function name from a set of typed functions,
         * and check whether the name of all functions match (if given)
         * @param {function[]} fns
         */
        function getName (fns) {
          var name = '';

          for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];

            // check whether the names are the same when defined
            if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {
              if (name === '') {
                name = fn.name;
              }
              else if (name !== fn.name) {
                var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');
                err.data = {
                  actual: fn.name,
                  expected: name
                };
                throw err;
              }
            }
          }

          return name;
        }

        // extract and merge all signatures of a list with typed functions
        function extractSignatures(fns) {
          var err;
          var signaturesMap = {};

          function validateUnique(_signature, _fn) {
            if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
              err = new Error('Signature "' + _signature + '" is defined twice');
              err.data = {signature: _signature};
              throw err;
              // else: both signatures point to the same function, that's fine
            }
          }

          for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];

            // test whether this is a typed-function
            if (typeof fn.signatures === 'object') {
              // merge the signatures
              for (var signature in fn.signatures) {
                if (fn.signatures.hasOwnProperty(signature)) {
                  validateUnique(signature, fn.signatures[signature]);
                  signaturesMap[signature] = fn.signatures[signature];
                }
              }
            }
            else if (typeof fn.signature === 'string') {
              validateUnique(fn.signature, fn);
              signaturesMap[fn.signature] = fn;
            }
            else {
              err = new TypeError('Function is no typed-function (index: ' + i + ')');
              err.data = {index: i};
              throw err;
            }
          }

          return signaturesMap;
        }

        typed = createTypedFunction('typed', {
          'string, Object': createTypedFunction,
          'Object': function (signaturesMap) {
            // find existing name
            var fns = [];
            for (var signature in signaturesMap) {
              if (signaturesMap.hasOwnProperty(signature)) {
                fns.push(signaturesMap[signature]);
              }
            }
            var name = getName(fns);
            return createTypedFunction(name, signaturesMap);
          },
          '...Function': function (fns) {
            return createTypedFunction(getName(fns), extractSignatures(fns));
          },
          'string, ...Function': function (name, fns) {
            return createTypedFunction(name, extractSignatures(fns));
          }
        });

        typed.create = create;
        typed.types = _types;
        typed.conversions = _conversions;
        typed.ignore = _ignore;
        typed.convert = convert;
        typed.find = find;

        /**
         * add a type
         * @param {{name: string, test: function}} type
         * @param {boolean} [beforeObjectTest=true]
         *                          If true, the new test will be inserted before
         *                          the test with name 'Object' (if any), since
         *                          tests for Object match Array and classes too.
         */
        typed.addType = function (type, beforeObjectTest) {
          if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {
            throw new TypeError('Object with properties {name: string, test: function} expected');
          }

          if (beforeObjectTest !== false) {
            for (var i = 0; i < typed.types.length; i++) {
              if (typed.types[i].name === 'Object') {
                typed.types.splice(i, 0, type);
                return
              }
            }
          }

          typed.types.push(type);
        };

        // add a conversion
        typed.addConversion = function (conversion) {
          if (!conversion
              || typeof conversion.from !== 'string'
              || typeof conversion.to !== 'string'
              || typeof conversion.convert !== 'function') {
            throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
          }

          typed.conversions.push(conversion);
        };

        return typed;
      }

      return create();
    }));
    });

    /**
     * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue
     */

    /**
     * Check if a number is integer
     * @param {number | boolean} value
     * @return {boolean} isInteger
     */
    function isInteger (value) {
      if (typeof value === 'boolean') {
        return true
      }

      return isFinite(value)
        ? (value === Math.round(value))
        : false
      // Note: we use ==, not ===, as we can have Booleans as well
    }

    /**
     * Convert a number to a formatted string representation.
     *
     * Syntax:
     *
     *    format(value)
     *    format(value, options)
     *    format(value, precision)
     *    format(value, fn)
     *
     * Where:
     *
     *    {number} value   The value to be formatted
     *    {Object} options An object with formatting options. Available options:
     *                     {string} notation
     *                         Number notation. Choose from:
     *                         'fixed'          Always use regular number notation.
     *                                          For example '123.40' and '14000000'
     *                         'exponential'    Always use exponential notation.
     *                                          For example '1.234e+2' and '1.4e+7'
     *                         'engineering'    Always use engineering notation.
     *                                          For example '123.4e+0' and '14.0e+6'
     *                         'auto' (default) Regular number notation for numbers
     *                                          having an absolute value between
     *                                          `lowerExp` and `upperExp` bounds, and
     *                                          uses exponential notation elsewhere.
     *                                          Lower bound is included, upper bound
     *                                          is excluded.
     *                                          For example '123.4' and '1.4e7'.
     *                     {number} precision   A number between 0 and 16 to round
     *                                          the digits of the number.
     *                                          In case of notations 'exponential',
     *                                          'engineering', and 'auto',
     *                                          `precision` defines the total
     *                                          number of significant digits returned.
     *                                          In case of notation 'fixed',
     *                                          `precision` defines the number of
     *                                          significant digits after the decimal
     *                                          point.
     *                                          `precision` is undefined by default,
     *                                          not rounding any digits.
     *                     {number} lowerExp    Exponent determining the lower boundary
     *                                          for formatting a value with an exponent
     *                                          when `notation='auto`.
     *                                          Default value is `-3`.
     *                     {number} upperExp    Exponent determining the upper boundary
     *                                          for formatting a value with an exponent
     *                                          when `notation='auto`.
     *                                          Default value is `5`.
     *    {Function} fn    A custom formatting function. Can be used to override the
     *                     built-in notations. Function `fn` is called with `value` as
     *                     parameter and must return a string. Is useful for example to
     *                     format all values inside a matrix in a particular way.
     *
     * Examples:
     *
     *    format(6.4)                                        // '6.4'
     *    format(1240000)                                    // '1.24e6'
     *    format(1/3)                                        // '0.3333333333333333'
     *    format(1/3, 3)                                     // '0.333'
     *    format(21385, 2)                                   // '21000'
     *    format(12.071, {notation: 'fixed'})                // '12'
     *    format(2.3,    {notation: 'fixed', precision: 2})  // '2.30'
     *    format(52.8,   {notation: 'exponential'})          // '5.28e+1'
     *    format(12345678, {notation: 'engineering'})        // '12.345678e+6'
     *
     * @param {number} value
     * @param {Object | Function | number} [options]
     * @return {string} str The formatted value
     */
    function format (value, options) {
      if (typeof options === 'function') {
        // handle format(value, fn)
        return options(value)
      }

      // handle special cases
      if (value === Infinity) {
        return 'Infinity'
      } else if (value === -Infinity) {
        return '-Infinity'
      } else if (isNaN(value)) {
        return 'NaN'
      }

      // default values for options
      let notation = 'auto';
      let precision;

      if (options) {
        // determine notation from options
        if (options.notation) {
          notation = options.notation;
        }

        // determine precision from options
        if (isNumber(options)) {
          precision = options;
        } else if (isNumber(options.precision)) {
          precision = options.precision;
        }
      }

      // handle the various notations
      switch (notation) {
        case 'fixed':
          return toFixed(value, precision)

        case 'exponential':
          return toExponential(value, precision)

        case 'engineering':
          return toEngineering(value, precision)

        case 'auto':
          // TODO: clean up some day. Deprecated since: 2018-01-24
          // @deprecated upper and lower are replaced with upperExp and lowerExp since v4.0.0
          if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {
            const fixedOptions = mapObject(options, function (x) { return x });
            fixedOptions.exponential = undefined;
            if (options.exponential.lower !== undefined) {
              fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);
            }
            if (options.exponential.upper !== undefined) {
              fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);
            }

            console.warn('Deprecation warning: Formatting options exponential.lower and exponential.upper ' +
                '(minimum and maximum value) ' +
                'are replaced with exponential.lowerExp and exponential.upperExp ' +
                '(minimum and maximum exponent) since version 4.0.0. ' +
                'Replace ' + JSON.stringify(options) + ' with ' + JSON.stringify(fixedOptions));

            return toPrecision(value, precision, fixedOptions)
          }

          // remove trailing zeros after the decimal point
          return toPrecision(value, precision, options && options)
            .replace(/((\.\d*?)(0+))($|e)/, function () {
              const digits = arguments[2];
              const e = arguments[4];
              return (digits !== '.') ? digits + e : e
            })

        default:
          throw new Error('Unknown notation "' + notation + '". ' +
              'Choose "auto", "exponential", or "fixed".')
      }
    }

    /**
     * Split a number into sign, coefficients, and exponent
     * @param {number | string} value
     * @return {SplitValue}
     *              Returns an object containing sign, coefficients, and exponent
     */
    function splitNumber (value) {
      // parse the input value
      const match = String(value).toLowerCase().match(/^0*?(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
      if (!match) {
        throw new SyntaxError('Invalid number ' + value)
      }

      const sign = match[1];
      const digits = match[2];
      let exponent = parseFloat(match[4] || '0');

      const dot = digits.indexOf('.');
      exponent += (dot !== -1) ? (dot - 1) : (digits.length - 1);

      const coefficients = digits
        .replace('.', '') // remove the dot (must be removed before removing leading zeros)
        .replace(/^0*/, function (zeros) {
          // remove leading zeros, add their count to the exponent
          exponent -= zeros.length;
          return ''
        })
        .replace(/0*$/, '') // remove trailing zeros
        .split('')
        .map(function (d) {
          return parseInt(d)
        });

      if (coefficients.length === 0) {
        coefficients.push(0);
        exponent++;
      }

      return {
        sign: sign,
        coefficients: coefficients,
        exponent: exponent
      }
    }

    /**
     * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
     * @param {number | string} value
     * @param {number} [precision]        Optional number of significant figures to return.
     */
    function toEngineering (value, precision) {
      if (isNaN(value) || !isFinite(value)) {
        return String(value)
      }

      const rounded = roundDigits(splitNumber(value), precision);

      const e = rounded.exponent;
      let c = rounded.coefficients;

      // find nearest lower multiple of 3 for exponent
      const newExp = e % 3 === 0 ? e : (e < 0 ? (e - 3) - (e % 3) : e - (e % 3));

      if (isNumber(precision)) {
        // add zeroes to give correct sig figs
        while (precision > c.length || (e - newExp) + 1 > c.length) {
          c.push(0);
        }
      } else {
        // concatenate coefficients with necessary zeros
        const significandsDiff = e >= 0 ? e : Math.abs(newExp);

        // add zeros if necessary (for ex: 1e+8)
        while (c.length - 1 < significandsDiff) {
          c.push(0);
        }
      }

      // find difference in exponents
      let expDiff = Math.abs(e - newExp);

      let decimalIdx = 1;

      // push decimal index over by expDiff times
      while (expDiff > 0) {
        decimalIdx++;
        expDiff--;
      }

      // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.
      // otherwise concat with the rest of the coefficients
      const decimals = c.slice(decimalIdx).join('');
      const decimalVal = ((isNumber(precision) && decimals.length) || decimals.match(/[1-9]/)) ? ('.' + decimals) : '';

      const str = c.slice(0, decimalIdx).join('') +
          decimalVal +
          'e' + (e >= 0 ? '+' : '') + newExp.toString();
      return rounded.sign + str
    }

    /**
     * Format a number with fixed notation.
     * @param {number | string} value
     * @param {number} [precision=undefined]  Optional number of decimals after the
     *                                        decimal point. null by default.
     */
    function toFixed (value, precision) {
      if (isNaN(value) || !isFinite(value)) {
        return String(value)
      }

      const splitValue = splitNumber(value);
      const rounded = (typeof precision === 'number')
        ? roundDigits(splitValue, splitValue.exponent + 1 + precision)
        : splitValue;
      let c = rounded.coefficients;
      let p = rounded.exponent + 1; // exponent may have changed

      // append zeros if needed
      const pp = p + (precision || 0);
      if (c.length < pp) {
        c = c.concat(zeros(pp - c.length));
      }

      // prepend zeros if needed
      if (p < 0) {
        c = zeros(-p + 1).concat(c);
        p = 1;
      }

      // insert a dot if needed
      if (p < c.length) {
        c.splice(p, 0, (p === 0) ? '0.' : '.');
      }

      return rounded.sign + c.join('')
    }

    /**
     * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
     * @param {number | string} value
     * @param {number} [precision]  Number of digits in formatted output.
     *                              If not provided, the maximum available digits
     *                              is used.
     */
    function toExponential (value, precision) {
      if (isNaN(value) || !isFinite(value)) {
        return String(value)
      }

      // round if needed, else create a clone
      const split = splitNumber(value);
      const rounded = precision ? roundDigits(split, precision) : split;
      let c = rounded.coefficients;
      const e = rounded.exponent;

      // append zeros if needed
      if (c.length < precision) {
        c = c.concat(zeros(precision - c.length));
      }

      // format as `C.CCCe+EEE` or `C.CCCe-EEE`
      const first = c.shift();
      return rounded.sign + first + (c.length > 0 ? ('.' + c.join('')) : '') +
          'e' + (e >= 0 ? '+' : '') + e
    }

    /**
     * Format a number with a certain precision
     * @param {number | string} value
     * @param {number} [precision=undefined] Optional number of digits.
     * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]
     *                                       By default:
     *                                         lowerExp = -3 (incl)
     *                                         upper = +5 (excl)
     * @return {string}
     */
    function toPrecision (value, precision, options) {
      if (isNaN(value) || !isFinite(value)) {
        return String(value)
      }

      // determine lower and upper bound for exponential notation.
      const lowerExp = (options && options.lowerExp !== undefined) ? options.lowerExp : -3;
      const upperExp = (options && options.upperExp !== undefined) ? options.upperExp : 5;

      const split = splitNumber(value);
      const rounded = precision ? roundDigits(split, precision) : split;
      if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
        // exponential notation
        return toExponential(value, precision)
      } else {
        let c = rounded.coefficients;
        const e = rounded.exponent;

        // append trailing zeros
        if (c.length < precision) {
          c = c.concat(zeros(precision - c.length));
        }

        // append trailing zeros
        // TODO: simplify the next statement
        c = c.concat(zeros(e - c.length + 1 +
            (c.length < precision ? precision - c.length : 0)));

        // prepend zeros
        c = zeros(-e).concat(c);

        const dot = e > 0 ? e : 0;
        if (dot < c.length - 1) {
          c.splice(dot + 1, 0, '.');
        }

        return rounded.sign + c.join('')
      }
    }

    /**
     * Round the number of digits of a number *
     * @param {SplitValue} split       A value split with .splitNumber(value)
     * @param {number} precision  A positive integer
     * @return {SplitValue}
     *              Returns an object containing sign, coefficients, and exponent
     *              with rounded digits
     */
    function roundDigits (split, precision) {
      // create a clone
      const rounded = {
        sign: split.sign,
        coefficients: split.coefficients,
        exponent: split.exponent
      };
      const c = rounded.coefficients;

      // prepend zeros if needed
      while (precision <= 0) {
        c.unshift(0);
        rounded.exponent++;
        precision++;
      }

      if (c.length > precision) {
        const removed = c.splice(precision, c.length - precision);

        if (removed[0] >= 5) {
          let i = precision - 1;
          c[i]++;
          while (c[i] === 10) {
            c.pop();
            if (i === 0) {
              c.unshift(0);
              rounded.exponent++;
              i++;
            }
            i--;
            c[i]++;
          }
        }
      }

      return rounded
    }

    /**
     * Create an array filled with zeros.
     * @param {number} length
     * @return {Array}
     */
    function zeros (length) {
      const arr = [];
      for (let i = 0; i < length; i++) {
        arr.push(0);
      }
      return arr
    }

    /**
     * Count the number of significant digits of a number.
     *
     * For example:
     *   2.34 returns 3
     *   0.0034 returns 2
     *   120.5e+30 returns 4
     *
     * @param {number} value
     * @return {number} digits   Number of significant digits
     */
    function digits (value) {
      return value
        .toExponential()
        .replace(/e.*$/, '') // remove exponential notation
        .replace(/^0\.?0*|\./, '') // remove decimal point and leading zeros
        .length
    }

    /**
     * Minimum number added to one that makes the result different than one
     */
    const DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;

    /**
     * Compares two floating point numbers.
     * @param {number} x          First value to compare
     * @param {number} y          Second value to compare
     * @param {number} [epsilon]  The maximum relative difference between x and y
     *                            If epsilon is undefined or null, the function will
     *                            test whether x and y are exactly equal.
     * @return {boolean} whether the two numbers are nearly equal
    */
    function nearlyEqual (x, y, epsilon) {
      // if epsilon is null or undefined, test whether x and y are exactly equal
      if (epsilon === null || epsilon === undefined) {
        return x === y
      }

      if (x === y) {
        return true
      }

      // NaN
      if (isNaN(x) || isNaN(y)) {
        return false
      }

      // at this point x and y should be finite
      if (isFinite(x) && isFinite(y)) {
        // check numbers are very close, needed when comparing numbers near zero
        const diff = Math.abs(x - y);
        if (diff < DBL_EPSILON) {
          return true
        } else {
          // use relative error
          return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon
        }
      }

      // Infinite and Number or negative Infinite and positive Infinite cases
      return false
    }

    /**
     * Convert a BigNumber to a formatted string representation.
     *
     * Syntax:
     *
     *    format(value)
     *    format(value, options)
     *    format(value, precision)
     *    format(value, fn)
     *
     * Where:
     *
     *    {number} value   The value to be formatted
     *    {Object} options An object with formatting options. Available options:
     *                     {string} notation
     *                         Number notation. Choose from:
     *                         'fixed'          Always use regular number notation.
     *                                          For example '123.40' and '14000000'
     *                         'exponential'    Always use exponential notation.
     *                                          For example '1.234e+2' and '1.4e+7'
     *                         'auto' (default) Regular number notation for numbers
     *                                          having an absolute value between
     *                                          `lower` and `upper` bounds, and uses
     *                                          exponential notation elsewhere.
     *                                          Lower bound is included, upper bound
     *                                          is excluded.
     *                                          For example '123.4' and '1.4e7'.
     *                     {number} precision   A number between 0 and 16 to round
     *                                          the digits of the number.
     *                                          In case of notations 'exponential',
     *                                          'engineering', and 'auto',
     *                                          `precision` defines the total
     *                                          number of significant digits returned.
     *                                          In case of notation 'fixed',
     *                                          `precision` defines the number of
     *                                          significant digits after the decimal
     *                                          point.
     *                                          `precision` is undefined by default.
     *                     {number} lowerExp    Exponent determining the lower boundary
     *                                          for formatting a value with an exponent
     *                                          when `notation='auto`.
     *                                          Default value is `-3`.
     *                     {number} upperExp    Exponent determining the upper boundary
     *                                          for formatting a value with an exponent
     *                                          when `notation='auto`.
     *                                          Default value is `5`.
     *    {Function} fn    A custom formatting function. Can be used to override the
     *                     built-in notations. Function `fn` is called with `value` as
     *                     parameter and must return a string. Is useful for example to
     *                     format all values inside a matrix in a particular way.
     *
     * Examples:
     *
     *    format(6.4)                                        // '6.4'
     *    format(1240000)                                    // '1.24e6'
     *    format(1/3)                                        // '0.3333333333333333'
     *    format(1/3, 3)                                     // '0.333'
     *    format(21385, 2)                                   // '21000'
     *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'
     *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'
     *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'
     *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'
     *
     * @param {BigNumber} value
     * @param {Object | Function | number} [options]
     * @return {string} str The formatted value
     */
    function format$1 (value, options) {
      if (typeof options === 'function') {
        // handle format(value, fn)
        return options(value)
      }

      // handle special cases
      if (!value.isFinite()) {
        return value.isNaN() ? 'NaN' : (value.gt(0) ? 'Infinity' : '-Infinity')
      }

      // default values for options
      let notation = 'auto';
      let precision;

      if (options !== undefined) {
        // determine notation from options
        if (options.notation) {
          notation = options.notation;
        }

        // determine precision from options
        if (typeof options === 'number') {
          precision = options;
        } else if (options.precision) {
          precision = options.precision;
        }
      }

      // handle the various notations
      switch (notation) {
        case 'fixed':
          return toFixed$1(value, precision)

        case 'exponential':
          return toExponential$1(value, precision)

        case 'engineering':
          return toEngineering$1(value, precision)

        case 'auto':
          // TODO: clean up some day. Deprecated since: 2018-01-24
          // @deprecated upper and lower are replaced with upperExp and lowerExp since v4.0.0
          if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {
            const fixedOptions = mapObject(options, function (x) { return x });
            fixedOptions.exponential = undefined;
            if (options.exponential.lower !== undefined) {
              fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);
            }
            if (options.exponential.upper !== undefined) {
              fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);
            }

            console.warn('Deprecation warning: Formatting options exponential.lower and exponential.upper ' +
                '(minimum and maximum value) ' +
                'are replaced with exponential.lowerExp and exponential.upperExp ' +
                '(minimum and maximum exponent) since version 4.0.0. ' +
                'Replace ' + JSON.stringify(options) + ' with ' + JSON.stringify(fixedOptions));

            return format$1(value, fixedOptions)
          }

          // determine lower and upper bound for exponential notation.
          // TODO: implement support for upper and lower to be BigNumbers themselves
          const lowerExp = (options && options.lowerExp !== undefined) ? options.lowerExp : -3;
          const upperExp = (options && options.upperExp !== undefined) ? options.upperExp : 5;

          // handle special case zero
          if (value.isZero()) return '0'

          // determine whether or not to output exponential notation
          let str;
          const rounded = value.toSignificantDigits(precision);
          const exp = rounded.e;
          if (exp >= lowerExp && exp < upperExp) {
            // normal number notation
            str = rounded.toFixed();
          } else {
            // exponential notation
            str = toExponential$1(value, precision);
          }

          // remove trailing zeros after the decimal point
          return str.replace(/((\.\d*?)(0+))($|e)/, function () {
            const digits = arguments[2];
            const e = arguments[4];
            return (digits !== '.') ? digits + e : e
          })

        default:
          throw new Error('Unknown notation "' + notation + '". ' +
              'Choose "auto", "exponential", or "fixed".')
      }
    }

    /**
     * Format a BigNumber in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
     * @param {BigNumber | string} value
     * @param {number} [precision]        Optional number of significant figures to return.
     */
    function toEngineering$1 (value, precision) {
      // find nearest lower multiple of 3 for exponent
      const e = value.e;
      const newExp = e % 3 === 0 ? e : (e < 0 ? (e - 3) - (e % 3) : e - (e % 3));

      // find difference in exponents, and calculate the value without exponent
      const valueWithoutExp = value.mul(Math.pow(10, -newExp));

      let valueStr = valueWithoutExp.toPrecision(precision);
      if (valueStr.indexOf('e') !== -1) {
        valueStr = valueWithoutExp.toString();
      }

      return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString()
    }

    /**
     * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
     * @param {BigNumber} value
     * @param {number} [precision]  Number of digits in formatted output.
     *                              If not provided, the maximum available digits
     *                              is used.
     * @returns {string} str
     */
    function toExponential$1 (value, precision) {
      if (precision !== undefined) {
        return value.toExponential(precision - 1) // Note the offset of one
      } else {
        return value.toExponential()
      }
    }

    /**
     * Format a number with fixed notation.
     * @param {BigNumber} value
     * @param {number} [precision=undefined] Optional number of decimals after the
     *                                       decimal point. Undefined by default.
     */
    function toFixed$1 (value, precision) {
      return value.toFixed(precision)
    }

    /**
     * Format a value of any type into a string.
     *
     * Usage:
     *     math.format(value)
     *     math.format(value, precision)
     *
     * When value is a function:
     *
     * - When the function has a property `syntax`, it returns this
     *   syntax description.
     * - In other cases, a string `'function'` is returned.
     *
     * When `value` is an Object:
     *
     * - When the object contains a property `format` being a function, this
     *   function is invoked as `value.format(options)` and the result is returned.
     * - When the object has its own `toString` method, this method is invoked
     *   and the result is returned.
     * - In other cases the function will loop over all object properties and
     *   return JSON object notation like '{"a": 2, "b": 3}'.
     *
     * Example usage:
     *     math.format(2/7)                // '0.2857142857142857'
     *     math.format(math.pi, 3)         // '3.14'
     *     math.format(new Complex(2, 3))  // '2 + 3i'
     *     math.format('hello')            // '"hello"'
     *
     * @param {*} value             Value to be stringified
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @return {string} str
     */
    function format$2 (value, options) {
      if (typeof value === 'number') {
        return format(value, options)
      }

      if (isBigNumber(value)) {
        return format$1(value, options)
      }

      // note: we use unsafe duck-typing here to check for Fractions, this is
      // ok here since we're only invoking toString or concatenating its values
      if (looksLikeFraction(value)) {
        if (!options || options.fraction !== 'decimal') {
          // output as ratio, like '1/3'
          return (value.s * value.n) + '/' + value.d
        } else {
          // output as decimal, like '0.(3)'
          return value.toString()
        }
      }

      if (Array.isArray(value)) {
        return formatArray$1(value, options)
      }

      if (isString(value)) {
        return '"' + value + '"'
      }

      if (typeof value === 'function') {
        return value.syntax ? String(value.syntax) : 'function'
      }

      if (value && typeof value === 'object') {
        if (typeof value.format === 'function') {
          return value.format(options)
        } else if (value && value.toString() !== {}.toString()) {
          // this object has a non-native toString method, use that one
          return value.toString()
        } else {
          const entries = [];

          for (const key in value) {
            if (value.hasOwnProperty(key)) {
              entries.push('"' + key + '": ' + format$2(value[key], options));
            }
          }

          return '{' + entries.join(', ') + '}'
        }
      }

      return String(value)
    }

    /**
     * Recursively format an n-dimensional matrix
     * Example output: "[[1, 2], [3, 4]]"
     * @param {Array} array
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */
    function formatArray$1 (array, options) {
      if (Array.isArray(array)) {
        let str = '[';
        const len = array.length;
        for (let i = 0; i < len; i++) {
          if (i !== 0) {
            str += ', ';
          }
          str += formatArray$1(array[i], options);
        }
        str += ']';
        return str
      } else {
        return format$2(array, options)
      }
    }

    /**
     * Check whether a value looks like a Fraction (unsafe duck-type check)
     * @param {*} value
     * @return {boolean}
     */
    function looksLikeFraction (value) {
      return (value &&
          typeof value === 'object' &&
          typeof value.s === 'number' &&
          typeof value.n === 'number' &&
          typeof value.d === 'number') || false
    }

    /**
     * Create a range error with the message:
     *     'Dimension mismatch (<actual size> != <expected size>)'
     * @param {number | number[]} actual        The actual size
     * @param {number | number[]} expected      The expected size
     * @param {string} [relation='!=']          Optional relation between actual
     *                                          and expected size: '!=', '<', etc.
     * @extends RangeError
     */
    function DimensionError (actual, expected, relation) {
      if (!(this instanceof DimensionError)) {
        throw new SyntaxError('Constructor must be called with the new operator')
      }

      this.actual = actual;
      this.expected = expected;
      this.relation = relation;

      this.message = 'Dimension mismatch (' +
          (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +
          ' ' + (this.relation || '!=') + ' ' +
          (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +
          ')';

      this.stack = (new Error()).stack;
    }

    DimensionError.prototype = new RangeError();
    DimensionError.prototype.constructor = RangeError;
    DimensionError.prototype.name = 'DimensionError';
    DimensionError.prototype.isDimensionError = true;

    /**
     * Create a range error with the message:
     *     'Index out of range (index < min)'
     *     'Index out of range (index < max)'
     *
     * @param {number} index     The actual index
     * @param {number} [min=0]   Minimum index (included)
     * @param {number} [max]     Maximum index (excluded)
     * @extends RangeError
     */
    function IndexError (index, min, max) {
      if (!(this instanceof IndexError)) {
        throw new SyntaxError('Constructor must be called with the new operator')
      }

      this.index = index;
      if (arguments.length < 3) {
        this.min = 0;
        this.max = min;
      } else {
        this.min = min;
        this.max = max;
      }

      if (this.min !== undefined && this.index < this.min) {
        this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
      } else if (this.max !== undefined && this.index >= this.max) {
        this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
      } else {
        this.message = 'Index out of range (' + this.index + ')';
      }

      this.stack = (new Error()).stack;
    }

    IndexError.prototype = new RangeError();
    IndexError.prototype.constructor = RangeError;
    IndexError.prototype.name = 'IndexError';
    IndexError.prototype.isIndexError = true;

    /**
     * Calculate the size of a multi dimensional array.
     * This function checks the size of the first entry, it does not validate
     * whether all dimensions match. (use function `validate` for that)
     * @param {Array} x
     * @Return {Number[]} size
     */
    function arraySize (x) {
      let s = [];

      while (Array.isArray(x)) {
        s.push(x.length);
        x = x[0];
      }

      return s
    }

    /**
     * Recursively validate whether each element in a multi dimensional array
     * has a size corresponding to the provided size array.
     * @param {Array} array    Array to be validated
     * @param {number[]} size  Array with the size of each dimension
     * @param {number} dim   Current dimension
     * @throws DimensionError
     * @private
     */
    function _validate (array, size, dim) {
      let i;
      const len = array.length;

      if (len !== size[dim]) {
        throw new DimensionError(len, size[dim])
      }

      if (dim < size.length - 1) {
        // recursively validate each child array
        const dimNext = dim + 1;
        for (i = 0; i < len; i++) {
          const child = array[i];
          if (!Array.isArray(child)) {
            throw new DimensionError(size.length - 1, size.length, '<')
          }
          _validate(array[i], size, dimNext);
        }
      } else {
        // last dimension. none of the childs may be an array
        for (i = 0; i < len; i++) {
          if (Array.isArray(array[i])) {
            throw new DimensionError(size.length + 1, size.length, '>')
          }
        }
      }
    }

    /**
     * Validate whether each element in a multi dimensional array has
     * a size corresponding to the provided size array.
     * @param {Array} array    Array to be validated
     * @param {number[]} size  Array with the size of each dimension
     * @throws DimensionError
     */
    function validate (array, size) {
      const isScalar = (size.length === 0);
      if (isScalar) {
        // scalar
        if (Array.isArray(array)) {
          throw new DimensionError(array.length, 0)
        }
      } else {
        // array
        _validate(array, size, 0);
      }
    }

    /**
     * Test whether index is an integer number with index >= 0 and index < length
     * when length is provided
     * @param {number} index    Zero-based index
     * @param {number} [length] Length of the array
     */
    function validateIndex (index, length) {
      if (!isNumber(index) || !isInteger(index)) {
        throw new TypeError('Index must be an integer (value: ' + index + ')')
      }
      if (index < 0 || (typeof length === 'number' && index >= length)) {
        throw new IndexError(index, length)
      }
    }

    /**
     * Resize a multi dimensional array. The resized array is returned.
     * @param {Array} array         Array to be resized
     * @param {Array.<number>} size Array with the size of each dimension
     * @param {*} [defaultValue=0]  Value to be filled in in new entries,
     *                              zero by default. Specify for example `null`,
     *                              to clearly see entries that are not explicitly
     *                              set.
     * @return {Array} array         The resized array
     */
    function resize (array, size, defaultValue) {
      // TODO: add support for scalars, having size=[] ?

      // check the type of the arguments
      if (!Array.isArray(array) || !Array.isArray(size)) {
        throw new TypeError('Array expected')
      }
      if (size.length === 0) {
        throw new Error('Resizing to scalar is not supported')
      }

      // check whether size contains positive integers
      size.forEach(function (value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError('Invalid size, must contain positive integers ' +
              '(size: ' + format$2(size) + ')')
        }
      });

      // recursively resize the array
      const _defaultValue = (defaultValue !== undefined) ? defaultValue : 0;
      _resize(array, size, 0, _defaultValue);

      return array
    }

    /**
     * Recursively resize a multi dimensional array
     * @param {Array} array         Array to be resized
     * @param {number[]} size       Array with the size of each dimension
     * @param {number} dim          Current dimension
     * @param {*} [defaultValue]    Value to be filled in in new entries,
     *                              undefined by default.
     * @private
     */
    function _resize (array, size, dim, defaultValue) {
      let i;
      let elem;
      const oldLen = array.length;
      const newLen = size[dim];
      const minLen = Math.min(oldLen, newLen);

      // apply new length
      array.length = newLen;

      if (dim < size.length - 1) {
        // non-last dimension
        const dimNext = dim + 1;

        // resize existing child arrays
        for (i = 0; i < minLen; i++) {
          // resize child array
          elem = array[i];
          if (!Array.isArray(elem)) {
            elem = [elem]; // add a dimension
            array[i] = elem;
          }
          _resize(elem, size, dimNext, defaultValue);
        }

        // create new child arrays
        for (i = minLen; i < newLen; i++) {
          // get child array
          elem = [];
          array[i] = elem;

          // resize new child array
          _resize(elem, size, dimNext, defaultValue);
        }
      } else {
        // last dimension

        // remove dimensions of existing values
        for (i = 0; i < minLen; i++) {
          while (Array.isArray(array[i])) {
            array[i] = array[i][0];
          }
        }

        // fill new elements with the default value
        for (i = minLen; i < newLen; i++) {
          array[i] = defaultValue;
        }
      }
    }

    /**
     * Re-shape a multi dimensional array to fit the specified dimensions
     * @param {Array} array           Array to be reshaped
     * @param {Array.<number>} sizes  List of sizes for each dimension
     * @returns {Array}               Array whose data has been formatted to fit the
     *                                specified dimensions
     *
     * @throws {DimensionError}       If the product of the new dimension sizes does
     *                                not equal that of the old ones
     */
    function reshape (array, sizes) {
      const flatArray = flatten(array);
      let newArray;

      function product (arr) {
        return arr.reduce((prev, curr) => prev * curr)
      }

      if (!Array.isArray(array) || !Array.isArray(sizes)) {
        throw new TypeError('Array expected')
      }

      if (sizes.length === 0) {
        throw new DimensionError(0, product(arraySize(array)), '!=')
      }

      let totalSize = 1;
      for (let sizeIndex = 0; sizeIndex < sizes.length; sizeIndex++) {
        totalSize *= sizes[sizeIndex];
      }

      if (flatArray.length !== totalSize) {
        throw new DimensionError(
          product(sizes),
          product(arraySize(array)),
          '!='
        )
      }

      try {
        newArray = _reshape(flatArray, sizes);
      } catch (e) {
        if (e instanceof DimensionError) {
          throw new DimensionError(
            product(sizes),
            product(arraySize(array)),
            '!='
          )
        }
        throw e
      }

      return newArray
    }

    /**
     * Iteratively re-shape a multi dimensional array to fit the specified dimensions
     * @param {Array} array           Array to be reshaped
     * @param {Array.<number>} sizes  List of sizes for each dimension
     * @returns {Array}               Array whose data has been formatted to fit the
     *                                specified dimensions
     */

    function _reshape (array, sizes) {
      // testing if there are enough elements for the requested shape
      let tmpArray = array;
      let tmpArray2;
      // for each dimensions starting by the last one and ignoring the first one
      for (let sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
        const size = sizes[sizeIndex];
        tmpArray2 = [];

        // aggregate the elements of the current tmpArray in elements of the requested size
        const length = tmpArray.length / size;
        for (let i = 0; i < length; i++) {
          tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
        }
        // set it as the new tmpArray for the next loop turn or for return
        tmpArray = tmpArray2;
      }

      return tmpArray
    }

    /**
     * Unsqueeze a multi dimensional array: add dimensions when missing
     *
     * Paramter `size` will be mutated to match the new, unqueezed matrix size.
     *
     * @param {Array} array
     * @param {number} dims       Desired number of dimensions of the array
     * @param {number} [outer]    Number of outer dimensions to be added
     * @param {Array} [size] Current size of array.
     * @returns {Array} returns the array itself
     * @private
     */
    function unsqueeze (array, dims, outer, size) {
      let s = size || arraySize(array);

      // unsqueeze outer dimensions
      if (outer) {
        for (let i = 0; i < outer; i++) {
          array = [array];
          s.unshift(1);
        }
      }

      // unsqueeze inner dimensions
      array = _unsqueeze(array, dims, 0);
      while (s.length < dims) {
        s.push(1);
      }

      return array
    }

    /**
     * Recursively unsqueeze a multi dimensional array
     * @param {Array} array
     * @param {number} dims Required number of dimensions
     * @param {number} dim  Current dimension
     * @returns {Array | *} Returns the squeezed array
     * @private
     */
    function _unsqueeze (array, dims, dim) {
      let i, ii;

      if (Array.isArray(array)) {
        const next = dim + 1;
        for (i = 0, ii = array.length; i < ii; i++) {
          array[i] = _unsqueeze(array[i], dims, next);
        }
      } else {
        for (let d = dim; d < dims; d++) {
          array = [array];
        }
      }

      return array
    }
    /**
     * Flatten a multi dimensional array, put all elements in a one dimensional
     * array
     * @param {Array} array   A multi dimensional array
     * @return {Array}        The flattened array (1 dimensional)
     */
    function flatten (array) {
      if (!Array.isArray(array)) {
        // if not an array, return as is
        return array
      }
      let flat = [];

      array.forEach(function callback (value) {
        if (Array.isArray(value)) {
          value.forEach(callback); // traverse through sub-arrays recursively
        } else {
          flat.push(value);
        }
      });

      return flat
    }

    /**
     * Check the datatype of a given object
     * This is a low level implementation that should only be used by
     * parent Matrix classes such as SparseMatrix or DenseMatrix
     * This method does not validate Array Matrix shape
     * @param {Array} array
     * @param {function} typeOf   Callback function to use to determine the type of a value
     * @return string
     */
    function getArrayDataType (array, typeOf) {
      let type; // to hold type info
      let length = 0; // to hold length value to ensure it has consistent sizes

      for (let i = 0; i < array.length; i++) {
        const item = array[i];
        const isArray = Array.isArray(item);

        // Saving the target matrix row size
        if (i === 0 && isArray) {
          length = item.length;
        }

        // If the current item is an array but the length does not equal the targetVectorSize
        if (isArray && item.length !== length) {
          return undefined
        }

        const itemType = isArray
          ? getArrayDataType(item, typeOf) // recurse into a nested array
          : typeOf(item);

        if (type === undefined) {
          type = itemType; // first item
        } else if (type !== itemType) {
          return 'mixed'
        }
      }

      return type
    }

    /**
     * Create a factory function, which can be used to inject dependencies.
     *
     * The created functions are memoized, a consecutive call of the factory
     * with the exact same inputs will return the same function instance.
     * The memoized cache is exposed on `factory.cache` and can be cleared
     * if needed.
     *
     * Example:
     *
     *     const name = 'log'
     *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']
     *
     *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {
     *       // ... create the function log here and return it
     *     }
     *
     * @param {string} name           Name of the function to be created
     * @param {string[]} dependencies The names of all required dependencies
     * @param {function} create       Callback function called with an object with all dependencies
     * @param {Object} [meta]         Optional object with meta information that will be attached
     *                                to the created factory function as property `meta`.
     * @returns {function}
     */
    function factory (name, dependencies, create, meta) {
      function assertAndCreate (scope) {
        // we only pass the requested dependencies to the factory function
        // to prevent functions to rely on dependencies that are not explicitly
        // requested.
        const deps = pickShallow(scope, dependencies.map(stripOptionalNotation));

        assertDependencies(name, dependencies, scope);

        return create(deps)
      }

      assertAndCreate.isFactory = true;
      assertAndCreate.fn = name;
      assertAndCreate.dependencies = dependencies.slice().sort();
      if (meta) {
        assertAndCreate.meta = meta;
      }

      return assertAndCreate
    }

    /**
     * Assert that all dependencies of a list with dependencies are available in the provided scope.
     *
     * Will throw an exception when there are dependencies missing.
     *
     * @param {string} name   Name for the function to be created. Used to generate a useful error message
     * @param {string[]} dependencies
     * @param {Object} scope
     */
    function assertDependencies (name, dependencies, scope) {
      const allDefined = dependencies
        .filter(dependency => !isOptionalDependency(dependency)) // filter optionals
        .every(dependency => scope[dependency] !== undefined);

      if (!allDefined) {
        const missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);

        // TODO: create a custom error class for this, a MathjsError or something like that
        throw new Error(`Cannot create function "${name}", ` +
          `some dependencies are missing: ${missingDependencies.map(d => `"${d}"`).join(', ')}.`)
      }
    }

    function isOptionalDependency (dependency) {
      return dependency && dependency[0] === '?'
    }

    function stripOptionalNotation (dependency) {
      return dependency && dependency[0] === '?'
        ? dependency.slice(1)
        : dependency
    }

    /**
     * Create a typed-function which checks the types of the arguments and
     * can match them against multiple provided signatures. The typed-function
     * automatically converts inputs in order to find a matching signature.
     * Typed functions throw informative errors in case of wrong input arguments.
     *
     * See the library [typed-function](https://github.com/josdejong/typed-function)
     * for detailed documentation.
     *
     * Syntax:
     *
     *     math.typed(name, signatures) : function
     *     math.typed(signatures) : function
     *
     * Examples:
     *
     *     // create a typed function with multiple types per argument (type union)
     *     const fn2 = typed({
     *       'number | boolean': function (b) {
     *         return 'b is a number or boolean'
     *       },
     *       'string, number | boolean': function (a, b) {
     *         return 'a is a string, b is a number or boolean'
     *       }
     *     })
     *
     *     // create a typed function with an any type argument
     *     const log = typed({
     *       'string, any': function (event, data) {
     *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))
     *       }
     *     })
     *
     * @param {string} [name]                          Optional name for the typed-function
     * @param {Object<string, function>} signatures   Object with one or multiple function signatures
     * @returns {function} The created typed-function.
     */

    // returns a new instance of typed-function
    let _createTyped = function () {
      // initially, return the original instance of typed-function
      // consecutively, return a new instance from typed.create.
      _createTyped = typedFunction.create;
      return typedFunction
    };

    const dependencies = [
      '?BigNumber',
      '?Complex',
      '?DenseMatrix',
      '?Fraction'
    ];

    /**
     * Factory function for creating a new typed instance
     * @param {Object} dependencies   Object with data types like Complex and BigNumber
     * @returns {Function}
     */
    const createTyped = /* #__PURE__ */ factory('typed', dependencies, function createTyped ({ BigNumber, Complex, DenseMatrix, Fraction }) {
      // TODO: typed-function must be able to silently ignore signatures with unknown data types

      // get a new instance of typed-function
      const typed = _createTyped();

      // define all types. The order of the types determines in which order function
      // arguments are type-checked (so for performance it's important to put the
      // most used types first).
      typed.types = [
        { name: 'number', test: isNumber },
        { name: 'Complex', test: isComplex },
        { name: 'BigNumber', test: isBigNumber },
        { name: 'Fraction', test: isFraction },
        { name: 'Unit', test: isUnit },
        { name: 'string', test: isString },
        { name: 'Chain', test: isChain },
        { name: 'Array', test: isArray },
        { name: 'Matrix', test: isMatrix },
        { name: 'DenseMatrix', test: isDenseMatrix },
        { name: 'SparseMatrix', test: isSparseMatrix },
        { name: 'Range', test: isRange },
        { name: 'Index', test: isIndex },
        { name: 'boolean', test: isBoolean },
        { name: 'ResultSet', test: isResultSet },
        { name: 'Help', test: isHelp },
        { name: 'function', test: isFunction },
        { name: 'Date', test: isDate },
        { name: 'RegExp', test: isRegExp },
        { name: 'null', test: isNull },
        { name: 'undefined', test: isUndefined },

        { name: 'AccessorNode', test: isAccessorNode },
        { name: 'ArrayNode', test: isArrayNode },
        { name: 'AssignmentNode', test: isAssignmentNode },
        { name: 'BlockNode', test: isBlockNode },
        { name: 'ConditionalNode', test: isConditionalNode },
        { name: 'ConstantNode', test: isConstantNode },
        { name: 'FunctionNode', test: isFunctionNode },
        { name: 'FunctionAssignmentNode', test: isFunctionAssignmentNode },
        { name: 'IndexNode', test: isIndexNode },
        { name: 'Node', test: isNode$1 },
        { name: 'ObjectNode', test: isObjectNode },
        { name: 'OperatorNode', test: isOperatorNode },
        { name: 'ParenthesisNode', test: isParenthesisNode },
        { name: 'RangeNode', test: isRangeNode },
        { name: 'SymbolNode', test: isSymbolNode },

        { name: 'Object', test: isObject$1 } // order 'Object' last, it matches on other classes too
      ];

      typed.conversions = [
        {
          from: 'number',
          to: 'BigNumber',
          convert: function (x) {
            if (!BigNumber) {
              throwNoBignumber(x);
            }

            // note: conversion from number to BigNumber can fail if x has >15 digits
            if (digits(x) > 15) {
              throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' +
                '(value: ' + x + '). ' +
                'Use function bignumber(x) to convert to BigNumber.')
            }
            return new BigNumber(x)
          }
        }, {
          from: 'number',
          to: 'Complex',
          convert: function (x) {
            if (!Complex) {
              throwNoComplex(x);
            }

            return new Complex(x, 0)
          }
        }, {
          from: 'number',
          to: 'string',
          convert: function (x) {
            return x + ''
          }
        }, {
          from: 'BigNumber',
          to: 'Complex',
          convert: function (x) {
            if (!Complex) {
              throwNoComplex(x);
            }

            return new Complex(x.toNumber(), 0)
          }
        }, {
          from: 'Fraction',
          to: 'BigNumber',
          convert: function (x) {
            throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
              'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.')
          }
        }, {
          from: 'Fraction',
          to: 'Complex',
          convert: function (x) {
            if (!Complex) {
              throwNoComplex(x);
            }

            return new Complex(x.valueOf(), 0)
          }
        }, {
          from: 'number',
          to: 'Fraction',
          convert: function (x) {
            if (!Fraction) {
              throwNoFraction(x);
            }

            const f = new Fraction(x);
            if (f.valueOf() !== x) {
              throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' +
                '(value: ' + x + '). ' +
                'Use function fraction(x) to convert to Fraction.')
            }
            return f
          }
        }, {
          // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
          //  from: 'Fraction',
          //  to: 'number',
          //  convert: function (x) {
          //    return x.valueOf()
          //  }
          // }, {
          from: 'string',
          to: 'number',
          convert: function (x) {
            const n = Number(x);
            if (isNaN(n)) {
              throw new Error('Cannot convert "' + x + '" to a number')
            }
            return n
          }
        }, {
          from: 'string',
          to: 'BigNumber',
          convert: function (x) {
            if (!BigNumber) {
              throwNoBignumber(x);
            }

            try {
              return new BigNumber(x)
            } catch (err) {
              throw new Error('Cannot convert "' + x + '" to BigNumber')
            }
          }
        }, {
          from: 'string',
          to: 'Fraction',
          convert: function (x) {
            if (!Fraction) {
              throwNoFraction(x);
            }

            try {
              return new Fraction(x)
            } catch (err) {
              throw new Error('Cannot convert "' + x + '" to Fraction')
            }
          }
        }, {
          from: 'string',
          to: 'Complex',
          convert: function (x) {
            if (!Complex) {
              throwNoComplex(x);
            }

            try {
              return new Complex(x)
            } catch (err) {
              throw new Error('Cannot convert "' + x + '" to Complex')
            }
          }
        }, {
          from: 'boolean',
          to: 'number',
          convert: function (x) {
            return +x
          }
        }, {
          from: 'boolean',
          to: 'BigNumber',
          convert: function (x) {
            if (!BigNumber) {
              throwNoBignumber(x);
            }

            return new BigNumber(+x)
          }
        }, {
          from: 'boolean',
          to: 'Fraction',
          convert: function (x) {
            if (!Fraction) {
              throwNoFraction(x);
            }

            return new Fraction(+x)
          }
        }, {
          from: 'boolean',
          to: 'string',
          convert: function (x) {
            return String(x)
          }
        }, {
          from: 'Array',
          to: 'Matrix',
          convert: function (array) {
            if (!DenseMatrix) {
              throwNoMatrix();
            }

            return new DenseMatrix(array)
          }
        }, {
          from: 'Matrix',
          to: 'Array',
          convert: function (matrix) {
            return matrix.valueOf()
          }
        }
      ];

      return typed
    });

    function throwNoBignumber (x) {
      throw new Error(`Cannot convert value ${x} into a BigNumber: no class 'BigNumber' provided`)
    }

    function throwNoComplex (x) {
      throw new Error(`Cannot convert value ${x} into a Complex number: no class 'Complex' provided`)
    }

    function throwNoMatrix () {
      throw new Error(`Cannot convert array into a Matrix: no class 'DenseMatrix' provided`)
    }

    function throwNoFraction (x) {
      throw new Error(`Cannot convert value ${x} into a Fraction, no class 'Fraction' provided.`)
    }

    var decimal = createCommonjsModule(function (module) {
    (function (globalScope) {


      /*
       *  decimal.js v10.2.0
       *  An arbitrary-precision Decimal type for JavaScript.
       *  https://github.com/MikeMcl/decimal.js
       *  Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
       *  MIT Licence
       */


      // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


        // The maximum exponent magnitude.
        // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
      var EXP_LIMIT = 9e15,                      // 0 to 9e15

        // The limit on the value of `precision`, and on the value of the first argument to
        // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
        MAX_DIGITS = 1e9,                        // 0 to 1e9

        // Base conversion alphabet.
        NUMERALS = '0123456789abcdef',

        // The natural logarithm of 10 (1025 digits).
        LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

        // Pi (1025 digits).
        PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


        // The initial configuration properties of the Decimal constructor.
        DEFAULTS = {

          // These values must be integers within the stated ranges (inclusive).
          // Most of these values can be changed at run-time using the `Decimal.config` method.

          // The maximum number of significant digits of the result of a calculation or base conversion.
          // E.g. `Decimal.config({ precision: 20 });`
          precision: 20,                         // 1 to MAX_DIGITS

          // The rounding mode used when rounding to `precision`.
          //
          // ROUND_UP         0 Away from zero.
          // ROUND_DOWN       1 Towards zero.
          // ROUND_CEIL       2 Towards +Infinity.
          // ROUND_FLOOR      3 Towards -Infinity.
          // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
          // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
          // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
          // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
          // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
          //
          // E.g.
          // `Decimal.rounding = 4;`
          // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
          rounding: 4,                           // 0 to 8

          // The modulo mode used when calculating the modulus: a mod n.
          // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
          // The remainder (r) is calculated as: r = a - n * q.
          //
          // UP         0 The remainder is positive if the dividend is negative, else is negative.
          // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
          // FLOOR      3 The remainder has the same sign as the divisor (Python %).
          // HALF_EVEN  6 The IEEE 754 remainder function.
          // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
          //
          // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
          // division (9) are commonly used for the modulus operation. The other rounding modes can also
          // be used, but they may not give useful results.
          modulo: 1,                             // 0 to 9

          // The exponent value at and beneath which `toString` returns exponential notation.
          // JavaScript numbers: -7
          toExpNeg: -7,                          // 0 to -EXP_LIMIT

          // The exponent value at and above which `toString` returns exponential notation.
          // JavaScript numbers: 21
          toExpPos:  21,                         // 0 to EXP_LIMIT

          // The minimum exponent value, beneath which underflow to zero occurs.
          // JavaScript numbers: -324  (5e-324)
          minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

          // The maximum exponent value, above which overflow to Infinity occurs.
          // JavaScript numbers: 308  (1.7976931348623157e+308)
          maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

          // Whether to use cryptographically-secure random number generation, if available.
          crypto: false                          // true/false
        },


      // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


        Decimal, inexact, noConflict, quadrant,
        external = true,

        decimalError = '[DecimalError] ',
        invalidArgument = decimalError + 'Invalid argument: ',
        precisionLimitExceeded = decimalError + 'Precision limit exceeded',
        cryptoUnavailable = decimalError + 'crypto unavailable',

        mathfloor = Math.floor,
        mathpow = Math.pow,

        isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
        isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
        isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
        isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

        BASE = 1e7,
        LOG_BASE = 7,
        MAX_SAFE_INTEGER = 9007199254740991,

        LN10_PRECISION = LN10.length - 1,
        PI_PRECISION = PI.length - 1,

        // Decimal.prototype object
        P = { name: '[object Decimal]' };


      // Decimal prototype methods


      /*
       *  absoluteValue             abs
       *  ceil
       *  comparedTo                cmp
       *  cosine                    cos
       *  cubeRoot                  cbrt
       *  decimalPlaces             dp
       *  dividedBy                 div
       *  dividedToIntegerBy        divToInt
       *  equals                    eq
       *  floor
       *  greaterThan               gt
       *  greaterThanOrEqualTo      gte
       *  hyperbolicCosine          cosh
       *  hyperbolicSine            sinh
       *  hyperbolicTangent         tanh
       *  inverseCosine             acos
       *  inverseHyperbolicCosine   acosh
       *  inverseHyperbolicSine     asinh
       *  inverseHyperbolicTangent  atanh
       *  inverseSine               asin
       *  inverseTangent            atan
       *  isFinite
       *  isInteger                 isInt
       *  isNaN
       *  isNegative                isNeg
       *  isPositive                isPos
       *  isZero
       *  lessThan                  lt
       *  lessThanOrEqualTo         lte
       *  logarithm                 log
       *  [maximum]                 [max]
       *  [minimum]                 [min]
       *  minus                     sub
       *  modulo                    mod
       *  naturalExponential        exp
       *  naturalLogarithm          ln
       *  negated                   neg
       *  plus                      add
       *  precision                 sd
       *  round
       *  sine                      sin
       *  squareRoot                sqrt
       *  tangent                   tan
       *  times                     mul
       *  toBinary
       *  toDecimalPlaces           toDP
       *  toExponential
       *  toFixed
       *  toFraction
       *  toHexadecimal             toHex
       *  toNearest
       *  toNumber
       *  toOctal
       *  toPower                   pow
       *  toPrecision
       *  toSignificantDigits       toSD
       *  toString
       *  truncated                 trunc
       *  valueOf                   toJSON
       */


      /*
       * Return a new Decimal whose value is the absolute value of this Decimal.
       *
       */
      P.absoluteValue = P.abs = function () {
        var x = new this.constructor(this);
        if (x.s < 0) x.s = 1;
        return finalise(x);
      };


      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
       * direction of positive Infinity.
       *
       */
      P.ceil = function () {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };


      /*
       * Return
       *   1    if the value of this Decimal is greater than the value of `y`,
       *  -1    if the value of this Decimal is less than the value of `y`,
       *   0    if they have the same value,
       *   NaN  if the value of either Decimal is NaN.
       *
       */
      P.comparedTo = P.cmp = function (y) {
        var i, j, xdL, ydL,
          x = this,
          xd = x.d,
          yd = (y = new x.constructor(y)).d,
          xs = x.s,
          ys = y.s;

        // Either NaN or Infinity?
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }

        // Either zero?
        if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

        // Signs differ?
        if (xs !== ys) return xs;

        // Compare exponents.
        if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

        xdL = xd.length;
        ydL = yd.length;

        // Compare digit by digit.
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        }

        // Compare lengths.
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };


      /*
       * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-1, 1]
       *
       * cos(0)         = 1
       * cos(-0)        = 1
       * cos(Infinity)  = NaN
       * cos(-Infinity) = NaN
       * cos(NaN)       = NaN
       *
       */
      P.cosine = P.cos = function () {
        var pr, rm,
          x = this,
          Ctor = x.constructor;

        if (!x.d) return new Ctor(NaN);

        // cos(0) = cos(-0) = 1
        if (!x.d[0]) return new Ctor(1);

        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;

        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

        Ctor.precision = pr;
        Ctor.rounding = rm;

        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
      };


      /*
       *
       * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       *  cbrt(0)  =  0
       *  cbrt(-0) = -0
       *  cbrt(1)  =  1
       *  cbrt(-1) = -1
       *  cbrt(N)  =  N
       *  cbrt(-I) = -I
       *  cbrt(I)  =  I
       *
       * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
       *
       */
      P.cubeRoot = P.cbrt = function () {
        var e, m, n, r, rep, s, sd, t, t3, t3plusx,
          x = this,
          Ctor = x.constructor;

        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        external = false;

        // Initial estimate.
        s = x.s * mathpow(x.s * x, 1 / 3);

         // Math.cbrt underflow/overflow?
         // Pass x to Math.pow as integer, then adjust the exponent of the result.
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString(x.d);
          e = x.e;

          // Adjust n exponent so it is a multiple of 3 away from x exponent.
          if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
          s = mathpow(n, 1 / 3);

          // Rarely, e may be one less than the result exponent value.
          e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

          if (s == 1 / 0) {
            n = '5e' + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf('e') + 1) + e;
          }

          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }

        sd = (e = Ctor.precision) + 3;

        // Halley's method.
        // TODO? Compare Newton's method.
        for (;;) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

          // TODO? Replace with for-loop and checkRoundingDigits.
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
            // , i.e. approaching a rounding boundary, continue the iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the exact result as the
              // nines may infinitely repeat.
              if (!rep) {
                finalise(t, e + 1, 0);

                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              sd += 4;
              rep = 1;
            } else {

              // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
              // If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                finalise(r, e + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }

              break;
            }
          }
        }

        external = true;

        return finalise(r, e, Ctor.rounding, m);
      };


      /*
       * Return the number of decimal places of the value of this Decimal.
       *
       */
      P.decimalPlaces = P.dp = function () {
        var w,
          d = this.d,
          n = NaN;

        if (d) {
          w = d.length - 1;
          n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

          // Subtract the number of trailing zeros of the last word.
          w = d[w];
          if (w) for (; w % 10 == 0; w /= 10) n--;
          if (n < 0) n = 0;
        }

        return n;
      };


      /*
       *  n / 0 = I
       *  n / N = N
       *  n / I = 0
       *  0 / n = 0
       *  0 / 0 = N
       *  0 / N = N
       *  0 / I = 0
       *  N / n = N
       *  N / 0 = N
       *  N / N = N
       *  N / I = N
       *  I / n = I
       *  I / 0 = I
       *  I / N = N
       *  I / I = N
       *
       * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       */
      P.dividedBy = P.div = function (y) {
        return divide(this, new this.constructor(y));
      };


      /*
       * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
       * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
       *
       */
      P.dividedToIntegerBy = P.divToInt = function (y) {
        var x = this,
          Ctor = x.constructor;
        return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };


      /*
       * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
       *
       */
      P.equals = P.eq = function (y) {
        return this.cmp(y) === 0;
      };


      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
       * direction of negative Infinity.
       *
       */
      P.floor = function () {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };


      /*
       * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
       * false.
       *
       */
      P.greaterThan = P.gt = function (y) {
        return this.cmp(y) > 0;
      };


      /*
       * Return true if the value of this Decimal is greater than or equal to the value of `y`,
       * otherwise return false.
       *
       */
      P.greaterThanOrEqualTo = P.gte = function (y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };


      /*
       * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
       * Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [1, Infinity]
       *
       * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
       *
       * cosh(0)         = 1
       * cosh(-0)        = 1
       * cosh(Infinity)  = Infinity
       * cosh(-Infinity) = Infinity
       * cosh(NaN)       = NaN
       *
       *  x        time taken (ms)   result
       * 1000      9                 9.8503555700852349694e+433
       * 10000     25                4.4034091128314607936e+4342
       * 100000    171               1.4033316802130615897e+43429
       * 1000000   3817              1.5166076984010437725e+434294
       * 10000000  abandoned after 2 minute wait
       *
       * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
       *
       */
      P.hyperbolicCosine = P.cosh = function () {
        var k, n, pr, rm, len,
          x = this,
          Ctor = x.constructor,
          one = new Ctor(1);

        if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero()) return one;

        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;

        // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
        // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

        // Estimate the optimum number of times to use the argument reduction.
        // TODO? Estimation reused from cosine() and may not be optimal here.
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          n = '2.3283064365386962890625e-10';
        }

        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

        // Reverse argument reduction
        var cosh2_x,
          i = k,
          d8 = new Ctor(8);
        for (; i--;) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }

        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };


      /*
       * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
       * Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-Infinity, Infinity]
       *
       * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
       *
       * sinh(0)         = 0
       * sinh(-0)        = -0
       * sinh(Infinity)  = Infinity
       * sinh(-Infinity) = -Infinity
       * sinh(NaN)       = NaN
       *
       * x        time taken (ms)
       * 10       2 ms
       * 100      5 ms
       * 1000     14 ms
       * 10000    82 ms
       * 100000   886 ms            1.4033316802130615897e+43429
       * 200000   2613 ms
       * 300000   5407 ms
       * 400000   8824 ms
       * 500000   13026 ms          8.7080643612718084129e+217146
       * 1000000  48543 ms
       *
       * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
       *
       */
      P.hyperbolicSine = P.sinh = function () {
        var k, pr, rm, len,
          x = this,
          Ctor = x.constructor;

        if (!x.isFinite() || x.isZero()) return new Ctor(x);

        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;

        if (len < 3) {
          x = taylorSeries(Ctor, 2, x, x, true);
        } else {

          // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
          // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
          // 3 multiplications and 1 addition

          // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
          // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
          // 4 multiplications and 2 additions

          // Estimate the optimum number of times to use the argument reduction.
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;

          x = x.times(1 / tinyPow(5, k));
          x = taylorSeries(Ctor, 2, x, x, true);

          // Reverse argument reduction
          var sinh2_x,
            d5 = new Ctor(5),
            d16 = new Ctor(16),
            d20 = new Ctor(20);
          for (; k--;) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }

        Ctor.precision = pr;
        Ctor.rounding = rm;

        return finalise(x, pr, rm, true);
      };


      /*
       * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
       * Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-1, 1]
       *
       * tanh(x) = sinh(x) / cosh(x)
       *
       * tanh(0)         = 0
       * tanh(-0)        = -0
       * tanh(Infinity)  = 1
       * tanh(-Infinity) = -1
       * tanh(NaN)       = NaN
       *
       */
      P.hyperbolicTangent = P.tanh = function () {
        var pr, rm,
          x = this,
          Ctor = x.constructor;

        if (!x.isFinite()) return new Ctor(x.s);
        if (x.isZero()) return new Ctor(x);

        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;

        return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };


      /*
       * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
       * this Decimal.
       *
       * Domain: [-1, 1]
       * Range: [0, pi]
       *
       * acos(x) = pi/2 - asin(x)
       *
       * acos(0)       = pi/2
       * acos(-0)      = pi/2
       * acos(1)       = 0
       * acos(-1)      = pi
       * acos(1/2)     = pi/3
       * acos(-1/2)    = 2*pi/3
       * acos(|x| > 1) = NaN
       * acos(NaN)     = NaN
       *
       */
      P.inverseCosine = P.acos = function () {
        var halfPi,
          x = this,
          Ctor = x.constructor,
          k = x.abs().cmp(1),
          pr = Ctor.precision,
          rm = Ctor.rounding;

        if (k !== -1) {
          return k === 0
            // |x| is 1
            ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
            // |x| > 1 or x is NaN
            : new Ctor(NaN);
        }

        if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

        // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

        Ctor.precision = pr + 6;
        Ctor.rounding = 1;

        x = x.asin();
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

        Ctor.precision = pr;
        Ctor.rounding = rm;

        return halfPi.minus(x);
      };


      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
       * value of this Decimal.
       *
       * Domain: [1, Infinity]
       * Range: [0, Infinity]
       *
       * acosh(x) = ln(x + sqrt(x^2 - 1))
       *
       * acosh(x < 1)     = NaN
       * acosh(NaN)       = NaN
       * acosh(Infinity)  = Infinity
       * acosh(-Infinity) = NaN
       * acosh(0)         = NaN
       * acosh(-0)        = NaN
       * acosh(1)         = 0
       * acosh(-1)        = NaN
       *
       */
      P.inverseHyperbolicCosine = P.acosh = function () {
        var pr, rm,
          x = this,
          Ctor = x.constructor;

        if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite()) return new Ctor(x);

        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external = false;

        x = x.times(x).minus(1).sqrt().plus(x);

        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;

        return x.ln();
      };


      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
       * of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-Infinity, Infinity]
       *
       * asinh(x) = ln(x + sqrt(x^2 + 1))
       *
       * asinh(NaN)       = NaN
       * asinh(Infinity)  = Infinity
       * asinh(-Infinity) = -Infinity
       * asinh(0)         = 0
       * asinh(-0)        = -0
       *
       */
      P.inverseHyperbolicSine = P.asinh = function () {
        var pr, rm,
          x = this,
          Ctor = x.constructor;

        if (!x.isFinite() || x.isZero()) return new Ctor(x);

        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external = false;

        x = x.times(x).plus(1).sqrt().plus(x);

        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;

        return x.ln();
      };


      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
       * value of this Decimal.
       *
       * Domain: [-1, 1]
       * Range: [-Infinity, Infinity]
       *
       * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
       *
       * atanh(|x| > 1)   = NaN
       * atanh(NaN)       = NaN
       * atanh(Infinity)  = NaN
       * atanh(-Infinity) = NaN
       * atanh(0)         = 0
       * atanh(-0)        = -0
       * atanh(1)         = Infinity
       * atanh(-1)        = -Infinity
       *
       */
      P.inverseHyperbolicTangent = P.atanh = function () {
        var pr, rm, wpr, xsd,
          x = this,
          Ctor = x.constructor;

        if (!x.isFinite()) return new Ctor(NaN);
        if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();

        if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

        Ctor.precision = wpr = xsd - x.e;

        x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

        Ctor.precision = pr + 4;
        Ctor.rounding = 1;

        x = x.ln();

        Ctor.precision = pr;
        Ctor.rounding = rm;

        return x.times(0.5);
      };


      /*
       * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
       * Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-pi/2, pi/2]
       *
       * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
       *
       * asin(0)       = 0
       * asin(-0)      = -0
       * asin(1/2)     = pi/6
       * asin(-1/2)    = -pi/6
       * asin(1)       = pi/2
       * asin(-1)      = -pi/2
       * asin(|x| > 1) = NaN
       * asin(NaN)     = NaN
       *
       * TODO? Compare performance of Taylor series.
       *
       */
      P.inverseSine = P.asin = function () {
        var halfPi, k,
          pr, rm,
          x = this,
          Ctor = x.constructor;

        if (x.isZero()) return new Ctor(x);

        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;

        if (k !== -1) {

          // |x| is 1
          if (k === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }

          // |x| > 1 or x is NaN
          return new Ctor(NaN);
        }

        // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

        Ctor.precision = pr + 6;
        Ctor.rounding = 1;

        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

        Ctor.precision = pr;
        Ctor.rounding = rm;

        return x.times(2);
      };


      /*
       * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
       * of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-pi/2, pi/2]
       *
       * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
       *
       * atan(0)         = 0
       * atan(-0)        = -0
       * atan(1)         = pi/4
       * atan(-1)        = -pi/4
       * atan(Infinity)  = pi/2
       * atan(-Infinity) = -pi/2
       * atan(NaN)       = NaN
       *
       */
      P.inverseTangent = P.atan = function () {
        var i, j, k, n, px, t, r, wpr, x2,
          x = this,
          Ctor = x.constructor,
          pr = Ctor.precision,
          rm = Ctor.rounding;

        if (!x.isFinite()) {
          if (!x.s) return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }

        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;

        // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

        // Argument reduction
        // Ensure |x| < 0.42
        // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

        k = Math.min(28, wpr / LOG_BASE + 2 | 0);

        for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

        external = false;

        j = Math.ceil(wpr / LOG_BASE);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;

        // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
        for (; i !== -1;) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));

          px = px.times(x2);
          r = t.plus(px.div(n += 2));

          if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
        }

        if (k) r = r.times(2 << (k - 1));

        external = true;

        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };


      /*
       * Return true if the value of this Decimal is a finite number, otherwise return false.
       *
       */
      P.isFinite = function () {
        return !!this.d;
      };


      /*
       * Return true if the value of this Decimal is an integer, otherwise return false.
       *
       */
      P.isInteger = P.isInt = function () {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };


      /*
       * Return true if the value of this Decimal is NaN, otherwise return false.
       *
       */
      P.isNaN = function () {
        return !this.s;
      };


      /*
       * Return true if the value of this Decimal is negative, otherwise return false.
       *
       */
      P.isNegative = P.isNeg = function () {
        return this.s < 0;
      };


      /*
       * Return true if the value of this Decimal is positive, otherwise return false.
       *
       */
      P.isPositive = P.isPos = function () {
        return this.s > 0;
      };


      /*
       * Return true if the value of this Decimal is 0 or -0, otherwise return false.
       *
       */
      P.isZero = function () {
        return !!this.d && this.d[0] === 0;
      };


      /*
       * Return true if the value of this Decimal is less than `y`, otherwise return false.
       *
       */
      P.lessThan = P.lt = function (y) {
        return this.cmp(y) < 0;
      };


      /*
       * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
       *
       */
      P.lessThanOrEqualTo = P.lte = function (y) {
        return this.cmp(y) < 1;
      };


      /*
       * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * If no base is specified, return log[10](arg).
       *
       * log[base](arg) = ln(arg) / ln(base)
       *
       * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
       * otherwise:
       *
       * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
       * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
       * between the result and the correctly rounded result will be one ulp (unit in the last place).
       *
       * log[-b](a)       = NaN
       * log[0](a)        = NaN
       * log[1](a)        = NaN
       * log[NaN](a)      = NaN
       * log[Infinity](a) = NaN
       * log[b](0)        = -Infinity
       * log[b](-0)       = -Infinity
       * log[b](-a)       = NaN
       * log[b](1)        = 0
       * log[b](Infinity) = Infinity
       * log[b](NaN)      = NaN
       *
       * [base] {number|string|Decimal} The base of the logarithm.
       *
       */
      P.logarithm = P.log = function (base) {
        var isBase10, d, denominator, k, inf, num, sd, r,
          arg = this,
          Ctor = arg.constructor,
          pr = Ctor.precision,
          rm = Ctor.rounding,
          guard = 5;

        // Default base is 10.
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;

          // Return NaN if base is negative, or non-finite, or is 0 or 1.
          if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

          isBase10 = base.eq(10);
        }

        d = arg.d;

        // Is arg negative, non-finite, 0 or 1?
        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        }

        // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
        // integer power of 10.
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0;) k /= 10;
            inf = k !== 1;
          }
        }

        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

        // The result will have 5 rounding digits.
        r = divide(num, denominator, sd, 1);

        // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
        // calculate 10 further digits.
        //
        // If the result is known to have an infinite decimal expansion, repeat this until it is clear
        // that the result is above or below the boundary. Otherwise, if after calculating the 10
        // further digits, the last 14 are nines, round up and assume the result is exact.
        // Also assume the result is exact if the last 14 are zero.
        //
        // Example of a result that will be incorrectly rounded:
        // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
        // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
        // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
        // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
        // place is still 2.6.
        if (checkRoundingDigits(r.d, k = pr, rm)) {

          do {
            sd += 10;
            num = naturalLogarithm(arg, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r = divide(num, denominator, sd, 1);

            if (!inf) {

              // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
              if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }

              break;
            }
          } while (checkRoundingDigits(r.d, k += 10, rm));
        }

        external = true;

        return finalise(r, pr, rm);
      };


      /*
       * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
       *
       * arguments {number|string|Decimal}
       *
      P.max = function () {
        Array.prototype.push.call(arguments, this);
        return maxOrMin(this.constructor, arguments, 'lt');
      };
       */


      /*
       * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
       *
       * arguments {number|string|Decimal}
       *
      P.min = function () {
        Array.prototype.push.call(arguments, this);
        return maxOrMin(this.constructor, arguments, 'gt');
      };
       */


      /*
       *  n - 0 = n
       *  n - N = N
       *  n - I = -I
       *  0 - n = -n
       *  0 - 0 = 0
       *  0 - N = N
       *  0 - I = -I
       *  N - n = N
       *  N - 0 = N
       *  N - N = N
       *  N - I = N
       *  I - n = I
       *  I - 0 = I
       *  I - N = N
       *  I - I = N
       *
       * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       */
      P.minus = P.sub = function (y) {
        var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
          x = this,
          Ctor = x.constructor;

        y = new Ctor(y);

        // If either is not finite...
        if (!x.d || !y.d) {

          // Return NaN if either is NaN.
          if (!x.s || !y.s) y = new Ctor(NaN);

          // Return y negated if x is finite and y is Infinity.
          else if (x.d) y.s = -y.s;

          // Return x if y is finite and x is Infinity.
          // Return x if both are Infinity with different signs.
          // Return NaN if both are Infinity with the same sign.
          else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

          return y;
        }

        // If signs differ...
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }

        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;

        // If either is zero...
        if (!xd[0] || !yd[0]) {

          // Return y negated if x is zero and y is non-zero.
          if (yd[0]) y.s = -y.s;

          // Return x if y is zero and x is non-zero.
          else if (xd[0]) y = new Ctor(x);

          // Return zero if both are zero.
          // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
          else return new Ctor(rm === 3 ? -0 : 0);

          return external ? finalise(y, pr, rm) : y;
        }

        // x and y are finite, non-zero numbers with the same sign.

        // Calculate base 1e7 exponents.
        e = mathfloor(y.e / LOG_BASE);
        xe = mathfloor(x.e / LOG_BASE);

        xd = xd.slice();
        k = xe - e;

        // If base 1e7 exponents differ...
        if (k) {
          xLTy = k < 0;

          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }

          // Numbers with massively different exponents would result in a very high number of
          // zeros needing to be prepended, but this can be avoided while still ensuring correct
          // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
          i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

          if (k > i) {
            k = i;
            d.length = 1;
          }

          // Prepend zeros to equalise exponents.
          d.reverse();
          for (i = k; i--;) d.push(0);
          d.reverse();

        // Base 1e7 exponents equal.
        } else {

          // Check digits to determine which is the bigger number.

          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy) len = i;

          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }

          k = 0;
        }

        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }

        len = xd.length;

        // Append zeros to `xd` if shorter.
        // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
        for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

        // Subtract yd from xd.
        for (i = yd.length; i > k;) {

          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
            --xd[j];
            xd[i] += BASE;
          }

          xd[i] -= yd[i];
        }

        // Remove trailing zeros.
        for (; xd[--len] === 0;) xd.pop();

        // Remove leading zeros and adjust exponent accordingly.
        for (; xd[0] === 0; xd.shift()) --e;

        // Zero?
        if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

        y.d = xd;
        y.e = getBase10Exponent(xd, e);

        return external ? finalise(y, pr, rm) : y;
      };


      /*
       *   n % 0 =  N
       *   n % N =  N
       *   n % I =  n
       *   0 % n =  0
       *  -0 % n = -0
       *   0 % 0 =  N
       *   0 % N =  N
       *   0 % I =  0
       *   N % n =  N
       *   N % 0 =  N
       *   N % N =  N
       *   N % I =  N
       *   I % n =  N
       *   I % 0 =  N
       *   I % N =  N
       *   I % I =  N
       *
       * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       * The result depends on the modulo mode.
       *
       */
      P.modulo = P.mod = function (y) {
        var q,
          x = this,
          Ctor = x.constructor;

        y = new Ctor(y);

        // Return NaN if x is Infinity or NaN, or y is NaN or 0.
        if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

        // Return x if y is Infinity or x is 0.
        if (!y.d || x.d && !x.d[0]) {
          return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
        }

        // Prevent rounding of intermediate calculations.
        external = false;

        if (Ctor.modulo == 9) {

          // Euclidian division: q = sign(y) * floor(x / abs(y))
          // result = x - q * y    where  0 <= result < abs(y)
          q = divide(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide(x, y, 0, Ctor.modulo, 1);
        }

        q = q.times(y);

        external = true;

        return x.minus(q);
      };


      /*
       * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
       * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       */
      P.naturalExponential = P.exp = function () {
        return naturalExponential(this);
      };


      /*
       * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
       * rounded to `precision` significant digits using rounding mode `rounding`.
       *
       */
      P.naturalLogarithm = P.ln = function () {
        return naturalLogarithm(this);
      };


      /*
       * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
       * -1.
       *
       */
      P.negated = P.neg = function () {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise(x);
      };


      /*
       *  n + 0 = n
       *  n + N = N
       *  n + I = I
       *  0 + n = n
       *  0 + 0 = 0
       *  0 + N = N
       *  0 + I = I
       *  N + n = N
       *  N + 0 = N
       *  N + N = N
       *  N + I = N
       *  I + n = I
       *  I + 0 = I
       *  I + N = N
       *  I + I = I
       *
       * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       */
      P.plus = P.add = function (y) {
        var carry, d, e, i, k, len, pr, rm, xd, yd,
          x = this,
          Ctor = x.constructor;

        y = new Ctor(y);

        // If either is not finite...
        if (!x.d || !y.d) {

          // Return NaN if either is NaN.
          if (!x.s || !y.s) y = new Ctor(NaN);

          // Return x if y is finite and x is Infinity.
          // Return x if both are Infinity with the same sign.
          // Return NaN if both are Infinity with different signs.
          // Return y if x is finite and y is Infinity.
          else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

          return y;
        }

         // If signs differ...
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }

        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;

        // If either is zero...
        if (!xd[0] || !yd[0]) {

          // Return x if y is zero.
          // Return y if y is non-zero.
          if (!yd[0]) y = new Ctor(x);

          return external ? finalise(y, pr, rm) : y;
        }

        // x and y are finite, non-zero numbers with the same sign.

        // Calculate base 1e7 exponents.
        k = mathfloor(x.e / LOG_BASE);
        e = mathfloor(y.e / LOG_BASE);

        xd = xd.slice();
        i = k - e;

        // If base 1e7 exponents differ...
        if (i) {

          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }

          // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;

          if (i > len) {
            i = len;
            d.length = 1;
          }

          // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
          d.reverse();
          for (; i--;) d.push(0);
          d.reverse();
        }

        len = xd.length;
        i = yd.length;

        // If yd is longer than xd, swap xd and yd so xd points to the longer array.
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }

        // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
        for (carry = 0; i;) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
          xd[i] %= BASE;
        }

        if (carry) {
          xd.unshift(carry);
          ++e;
        }

        // Remove trailing zeros.
        // No need to check for zero, as +x + +y != 0 && -x + -y != 0
        for (len = xd.length; xd[--len] == 0;) xd.pop();

        y.d = xd;
        y.e = getBase10Exponent(xd, e);

        return external ? finalise(y, pr, rm) : y;
      };


      /*
       * Return the number of significant digits of the value of this Decimal.
       *
       * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
       *
       */
      P.precision = P.sd = function (z) {
        var k,
          x = this;

        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

        if (x.d) {
          k = getPrecision(x.d);
          if (z && x.e + 1 > k) k = x.e + 1;
        } else {
          k = NaN;
        }

        return k;
      };


      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
       * rounding mode `rounding`.
       *
       */
      P.round = function () {
        var x = this,
          Ctor = x.constructor;

        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
      };


      /*
       * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-1, 1]
       *
       * sin(x) = x - x^3/3! + x^5/5! - ...
       *
       * sin(0)         = 0
       * sin(-0)        = -0
       * sin(Infinity)  = NaN
       * sin(-Infinity) = NaN
       * sin(NaN)       = NaN
       *
       */
      P.sine = P.sin = function () {
        var pr, rm,
          x = this,
          Ctor = x.constructor;

        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);

        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;

        x = sine(Ctor, toLessThanHalfPi(Ctor, x));

        Ctor.precision = pr;
        Ctor.rounding = rm;

        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
      };


      /*
       * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       *  sqrt(-n) =  N
       *  sqrt(N)  =  N
       *  sqrt(-I) =  N
       *  sqrt(I)  =  I
       *  sqrt(0)  =  0
       *  sqrt(-0) = -0
       *
       */
      P.squareRoot = P.sqrt = function () {
        var m, n, sd, r, rep, t,
          x = this,
          d = x.d,
          e = x.e,
          s = x.s,
          Ctor = x.constructor;

        // Negative/NaN/Infinity/zero?
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }

        external = false;

        // Initial estimate.
        s = Math.sqrt(+x);

        // Math.sqrt underflow/overflow?
        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
        if (s == 0 || s == 1 / 0) {
          n = digitsToString(d);

          if ((n.length + e) % 2 == 0) n += '0';
          s = Math.sqrt(n);
          e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

          if (s == 1 / 0) {
            n = '1e' + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf('e') + 1) + e;
          }

          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }

        sd = (e = Ctor.precision) + 3;

        // Newton-Raphson iteration.
        for (;;) {
          t = r;
          r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

          // TODO? Replace with for-loop and checkRoundingDigits.
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
            // 4999, i.e. approaching a rounding boundary, continue the iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the exact result as the
              // nines may infinitely repeat.
              if (!rep) {
                finalise(t, e + 1, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              sd += 4;
              rep = 1;
            } else {

              // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
              // If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                finalise(r, e + 1, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }

        external = true;

        return finalise(r, e, Ctor.rounding, m);
      };


      /*
       * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-Infinity, Infinity]
       *
       * tan(0)         = 0
       * tan(-0)        = -0
       * tan(Infinity)  = NaN
       * tan(-Infinity) = NaN
       * tan(NaN)       = NaN
       *
       */
      P.tangent = P.tan = function () {
        var pr, rm,
          x = this,
          Ctor = x.constructor;

        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);

        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;

        x = x.sin();
        x.s = 1;
        x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

        Ctor.precision = pr;
        Ctor.rounding = rm;

        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
      };


      /*
       *  n * 0 = 0
       *  n * N = N
       *  n * I = I
       *  0 * n = 0
       *  0 * 0 = 0
       *  0 * N = N
       *  0 * I = N
       *  N * n = N
       *  N * 0 = N
       *  N * N = N
       *  N * I = N
       *  I * n = I
       *  I * 0 = N
       *  I * N = N
       *  I * I = I
       *
       * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       */
      P.times = P.mul = function (y) {
        var carry, e, i, k, r, rL, t, xdL, ydL,
          x = this,
          Ctor = x.constructor,
          xd = x.d,
          yd = (y = new Ctor(y)).d;

        y.s *= x.s;

         // If either is NaN, Infinity or 0...
        if (!xd || !xd[0] || !yd || !yd[0]) {

          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

            // Return NaN if either is NaN.
            // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.
            ? NaN

            // Return Infinity if either is Infinity.
            // Return 0 if either is 0.
            : !xd || !yd ? y.s / 0 : y.s * 0);
        }

        e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length;

        // Ensure xd points to the longer array.
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }

        // Initialise the result array with zeros.
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--;) r.push(0);

        // Multiply!
        for (i = ydL; --i >= 0;) {
          carry = 0;
          for (k = xdL + i; k > i;) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }

          r[k] = (r[k] + carry) % BASE | 0;
        }

        // Remove trailing zeros.
        for (; !r[--rL];) r.pop();

        if (carry) ++e;
        else r.shift();

        y.d = r;
        y.e = getBase10Exponent(r, e);

        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
      };


      /*
       * Return a string representing the value of this Decimal in base 2, round to `sd` significant
       * digits using rounding mode `rm`.
       *
       * If the optional `sd` argument is present then return binary exponential notation.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */
      P.toBinary = function (sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };


      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
       * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
       *
       * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
       *
       * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */
      P.toDecimalPlaces = P.toDP = function (dp, rm) {
        var x = this,
          Ctor = x.constructor;

        x = new Ctor(x);
        if (dp === void 0) return x;

        checkInt32(dp, 0, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        return finalise(x, dp + x.e + 1, rm);
      };


      /*
       * Return a string representing the value of this Decimal in exponential notation rounded to
       * `dp` fixed decimal places using rounding mode `rounding`.
       *
       * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */
      P.toExponential = function (dp, rm) {
        var str,
          x = this,
          Ctor = x.constructor;

        if (dp === void 0) {
          str = finiteToString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);

          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);

          x = finalise(new Ctor(x), dp + 1, rm);
          str = finiteToString(x, true, dp + 1);
        }

        return x.isNeg() && !x.isZero() ? '-' + str : str;
      };


      /*
       * Return a string representing the value of this Decimal in normal (fixed-point) notation to
       * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
       * omitted.
       *
       * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
       *
       * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
       * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
       * (-0).toFixed(3) is '0.000'.
       * (-0.5).toFixed(0) is '-0'.
       *
       */
      P.toFixed = function (dp, rm) {
        var str, y,
          x = this,
          Ctor = x.constructor;

        if (dp === void 0) {
          str = finiteToString(x);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);

          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);

          y = finalise(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString(y, false, dp + y.e + 1);
        }

        // To determine whether to add the minus sign look at the value before it was rounded,
        // i.e. look at `x` rather than `y`.
        return x.isNeg() && !x.isZero() ? '-' + str : str;
      };


      /*
       * Return an array representing the value of this Decimal as a simple fraction with an integer
       * numerator and an integer denominator.
       *
       * The denominator will be a positive non-zero value less than or equal to the specified maximum
       * denominator. If a maximum denominator is not specified, the denominator will be the lowest
       * value necessary to represent the number exactly.
       *
       * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
       *
       */
      P.toFraction = function (maxD) {
        var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
          x = this,
          xd = x.d,
          Ctor = x.constructor;

        if (!xd) return new Ctor(x);

        n1 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);

        d = new Ctor(d1);
        e = d.e = getPrecision(xd) - x.e - 1;
        k = e % LOG_BASE;
        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

        if (maxD == null) {

          // d is 10**e, the minimum max-denominator needed.
          maxD = e > 0 ? d : n1;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
          maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
        }

        external = false;
        n = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e = xd.length * LOG_BASE * 2;

        for (;;)  {
          q = divide(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1) break;
          d0 = d1;
          d1 = d2;
          d2 = n1;
          n1 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }

        d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;

        // Determine which fraction is closer to x, n0/d0 or n1/d1?
        r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1
            ? [n1, d1] : [n0, d0];

        Ctor.precision = pr;
        external = true;

        return r;
      };


      /*
       * Return a string representing the value of this Decimal in base 16, round to `sd` significant
       * digits using rounding mode `rm`.
       *
       * If the optional `sd` argument is present then return binary exponential notation.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */
      P.toHexadecimal = P.toHex = function (sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };


      /*
       * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
       * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
       *
       * The return value will always have the same sign as this Decimal, unless either this Decimal
       * or `y` is NaN, in which case the return value will be also be NaN.
       *
       * The return value is not affected by the value of `precision`.
       *
       * y {number|string|Decimal} The magnitude to round to a multiple of.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       * 'toNearest() rounding mode not an integer: {rm}'
       * 'toNearest() rounding mode out of range: {rm}'
       *
       */
      P.toNearest = function (y, rm) {
        var x = this,
          Ctor = x.constructor;

        x = new Ctor(x);

        if (y == null) {

          // If x is not finite, return x.
          if (!x.d) return x;

          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          }

          // If x is not finite, return x if y is not NaN, else NaN.
          if (!x.d) return y.s ? x : y;

          // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
          if (!y.d) {
            if (y.s) y.s = x.s;
            return y;
          }
        }

        // If y is not zero, calculate the nearest multiple of y to x.
        if (y.d[0]) {
          external = false;
          x = divide(x, y, 0, rm, 1).times(y);
          external = true;
          finalise(x);

        // If y is zero, return zero with the sign of x.
        } else {
          y.s = x.s;
          x = y;
        }

        return x;
      };


      /*
       * Return the value of this Decimal converted to a number primitive.
       * Zero keeps its sign.
       *
       */
      P.toNumber = function () {
        return +this;
      };


      /*
       * Return a string representing the value of this Decimal in base 8, round to `sd` significant
       * digits using rounding mode `rm`.
       *
       * If the optional `sd` argument is present then return binary exponential notation.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */
      P.toOctal = function (sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };


      /*
       * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
       * to `precision` significant digits using rounding mode `rounding`.
       *
       * ECMAScript compliant.
       *
       *   pow(x, NaN)                           = NaN
       *   pow(x, 0)                            = 1

       *   pow(NaN, non-zero)                    = NaN
       *   pow(abs(x) > 1, +Infinity)            = +Infinity
       *   pow(abs(x) > 1, -Infinity)            = +0
       *   pow(abs(x) == 1, Infinity)           = NaN
       *   pow(abs(x) < 1, +Infinity)            = +0
       *   pow(abs(x) < 1, -Infinity)            = +Infinity
       *   pow(+Infinity, y > 0)                 = +Infinity
       *   pow(+Infinity, y < 0)                 = +0
       *   pow(-Infinity, odd integer > 0)       = -Infinity
       *   pow(-Infinity, even integer > 0)      = +Infinity
       *   pow(-Infinity, odd integer < 0)       = -0
       *   pow(-Infinity, even integer < 0)      = +0
       *   pow(+0, y > 0)                        = +0
       *   pow(+0, y < 0)                        = +Infinity
       *   pow(-0, odd integer > 0)              = -0
       *   pow(-0, even integer > 0)             = +0
       *   pow(-0, odd integer < 0)              = -Infinity
       *   pow(-0, even integer < 0)             = +Infinity
       *   pow(finite x < 0, finite non-integer) = NaN
       *
       * For non-integer or very large exponents pow(x, y) is calculated using
       *
       *   x^y = exp(y*ln(x))
       *
       * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
       * probability of an incorrectly rounded result
       * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
       * i.e. 1 in 250,000,000,000,000
       *
       * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
       *
       * y {number|string|Decimal} The power to which to raise this Decimal.
       *
       */
      P.toPower = P.pow = function (y) {
        var e, k, pr, r, rm, s,
          x = this,
          Ctor = x.constructor,
          yn = +(y = new Ctor(y));

        // Either Infinity, NaN or 0?
        if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

        x = new Ctor(x);

        if (x.eq(1)) return x;

        pr = Ctor.precision;
        rm = Ctor.rounding;

        if (y.eq(1)) return finalise(x, pr, rm);

        // y exponent
        e = mathfloor(y.e / LOG_BASE);

        // If y is a small integer use the 'exponentiation by squaring' algorithm.
        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = intPow(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
        }

        s = x.s;

        // if x is negative
        if (s < 0) {

          // if y is not an integer
          if (e < y.d.length - 1) return new Ctor(NaN);

          // Result is positive if x is negative and the last digit of integer y is even.
          if ((y.d[e] & 1) == 0) s = 1;

          // if x.eq(-1)
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }

        // Estimate result exponent.
        // x^y = 10^e,  where e = y * log10(x)
        // log10(x) = log10(x_significand) + x_exponent
        // log10(x_significand) = ln(x_significand) / ln(10)
        k = mathpow(+x, yn);
        e = k == 0 || !isFinite(k)
          ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
          : new Ctor(k + '').e;

        // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

        // Overflow/underflow?
        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

        external = false;
        Ctor.rounding = x.s = 1;

        // Estimate the extra guard digits needed to ensure five correct rounding digits from
        // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
        // new Decimal(2.32456).pow('2087987436534566.46411')
        // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
        k = Math.min(12, (e + '').length);

        // r = x^y = exp(y*ln(x))
        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

        // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
        if (r.d) {

          // Truncate to the required precision plus five rounding digits.
          r = finalise(r, pr + 5, 1);

          // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
          // the result.
          if (checkRoundingDigits(r.d, pr, rm)) {
            e = pr + 10;

            // Truncate to the increased precision plus five rounding digits.
            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

            // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
          }
        }

        r.s = s;
        external = true;
        Ctor.rounding = rm;

        return finalise(r, pr, rm);
      };


      /*
       * Return a string representing the value of this Decimal rounded to `sd` significant digits
       * using rounding mode `rounding`.
       *
       * Return exponential notation if `sd` is less than the number of digits necessary to represent
       * the integer part of the value in normal notation.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */
      P.toPrecision = function (sd, rm) {
        var str,
          x = this,
          Ctor = x.constructor;

        if (sd === void 0) {
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);

          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);

          x = finalise(new Ctor(x), sd, rm);
          str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }

        return x.isNeg() && !x.isZero() ? '-' + str : str;
      };


      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
       * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
       * omitted.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       * 'toSD() digits out of range: {sd}'
       * 'toSD() digits not an integer: {sd}'
       * 'toSD() rounding mode not an integer: {rm}'
       * 'toSD() rounding mode out of range: {rm}'
       *
       */
      P.toSignificantDigits = P.toSD = function (sd, rm) {
        var x = this,
          Ctor = x.constructor;

        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);

          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        }

        return finalise(new Ctor(x), sd, rm);
      };


      /*
       * Return a string representing the value of this Decimal.
       *
       * Return exponential notation if this Decimal has a positive exponent equal to or greater than
       * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
       *
       */
      P.toString = function () {
        var x = this,
          Ctor = x.constructor,
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

        return x.isNeg() && !x.isZero() ? '-' + str : str;
      };


      /*
       * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
       *
       */
      P.truncated = P.trunc = function () {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };


      /*
       * Return a string representing the value of this Decimal.
       * Unlike `toString`, negative zero will include the minus sign.
       *
       */
      P.valueOf = P.toJSON = function () {
        var x = this,
          Ctor = x.constructor,
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

        return x.isNeg() ? '-' + str : str;
      };


      /*
      // Add aliases to match BigDecimal method names.
      // P.add = P.plus;
      P.subtract = P.minus;
      P.multiply = P.times;
      P.divide = P.div;
      P.remainder = P.mod;
      P.compareTo = P.cmp;
      P.negate = P.neg;
       */


      // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


      /*
       *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
       *                           finiteToString, naturalExponential, naturalLogarithm
       *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
       *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
       *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
       *  convertBase              toStringBinary, parseOther
       *  cos                      P.cos
       *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
       *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
       *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
       *                           taylorSeries, atan2, parseOther
       *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
       *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
       *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
       *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
       *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
       *                           P.truncated, divide, getLn10, getPi, naturalExponential,
       *                           naturalLogarithm, ceil, floor, round, trunc
       *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
       *                           toStringBinary
       *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
       *  getLn10                  P.logarithm, naturalLogarithm
       *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
       *  getPrecision             P.precision, P.toFraction
       *  getZeroString            digitsToString, finiteToString
       *  intPow                   P.toPower, parseOther
       *  isOdd                    toLessThanHalfPi
       *  maxOrMin                 max, min
       *  naturalExponential       P.naturalExponential, P.toPower
       *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
       *                           P.toPower, naturalExponential
       *  nonFiniteToString        finiteToString, toStringBinary
       *  parseDecimal             Decimal
       *  parseOther               Decimal
       *  sin                      P.sin
       *  taylorSeries             P.cosh, P.sinh, cos, sin
       *  toLessThanHalfPi         P.cos, P.sin
       *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
       *  truncate                 intPow
       *
       *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
       *                           naturalLogarithm, config, parseOther, random, Decimal
       */


      function digitsToString(d) {
        var i, k, ws,
          indexOfLastWord = d.length - 1,
          str = '',
          w = d[0];

        if (indexOfLastWord > 0) {
          str += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + '';
            k = LOG_BASE - ws.length;
            if (k) str += getZeroString(k);
            str += ws;
          }

          w = d[i];
          ws = w + '';
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
        } else if (w === 0) {
          return '0';
        }

        // Remove trailing zeros of last w.
        for (; w % 10 === 0;) w /= 10;

        return str + w;
      }


      function checkInt32(i, min, max) {
        if (i !== ~~i || i < min || i > max) {
          throw Error(invalidArgument + i);
        }
      }


      /*
       * Check 5 rounding digits if `repeating` is null, 4 otherwise.
       * `repeating == null` if caller is `log` or `pow`,
       * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
       */
      function checkRoundingDigits(d, i, rm, repeating) {
        var di, k, r, rd;

        // Get the length of the first word of the array d.
        for (k = d[0]; k >= 10; k /= 10) --i;

        // Is the rounding digit in the first word of d?
        if (--i < 0) {
          i += LOG_BASE;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE);
          i %= LOG_BASE;
        }

        // i is the index (0 - 6) of the rounding digit.
        // E.g. if within the word 3487563 the first rounding digit is 5,
        // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
        k = mathpow(10, LOG_BASE - i);
        rd = d[di] % k | 0;

        if (repeating == null) {
          if (i < 3) {
            if (i == 0) rd = rd / 100 | 0;
            else if (i == 1) rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
              (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
                (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0) rd = rd / 1000 | 0;
            else if (i == 1) rd = rd / 100 | 0;
            else if (i == 2) rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k ||
            (!repeating && rm > 3) && rd + 1 == k / 2) &&
              (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
          }
        }

        return r;
      }


      // Convert string of `baseIn` to an array of numbers of `baseOut`.
      // Eg. convertBase('255', 10, 16) returns [15, 15].
      // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
      function convertBase(str, baseIn, baseOut) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          strL = str.length;

        for (; i < strL;) {
          for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
          arr[0] += NUMERALS.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }


      /*
       * cos(x) = 1 - x^2/2! + x^4/4! - ...
       * |x| < pi/2
       *
       */
      function cosine(Ctor, x) {
        var k, y,
          len = x.d.length;

        // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
        // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

        // Estimate the optimum number of times to use the argument reduction.
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          y = '2.3283064365386962890625e-10';
        }

        Ctor.precision += k;

        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

        // Reverse argument reduction
        for (var i = k; i--;) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }

        Ctor.precision -= k;

        return x;
      }


      /*
       * Perform division in the specified base.
       */
      var divide = (function () {

        // Assumes non-zero x and k, and hence non-zero result.
        function multiplyInteger(x, k, base) {
          var temp,
            carry = 0,
            i = x.length;

          for (x = x.slice(); i--;) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }

          if (carry) x.unshift(carry);

          return x;
        }

        function compare(a, b, aL, bL) {
          var i, r;

          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }

          return r;
        }

        function subtract(a, b, aL, base) {
          var i = 0;

          // Subtract b from a.
          for (; aL--;) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }

          // Remove leading zeros.
          for (; !a[0] && a.length > 1;) a.shift();
        }

        return function (x, y, pr, rm, dp, base) {
          var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
            yL, yz,
            Ctor = x.constructor,
            sign = x.s == y.s ? 1 : -1,
            xd = x.d,
            yd = y.d;

          // Either NaN, Infinity or 0?
          if (!xd || !xd[0] || !yd || !yd[0]) {

            return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

              // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
              xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
          }

          if (base) {
            logBase = 1;
            e = x.e - y.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
          }

          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign);
          qd = q.d = [];

          // Result exponent may be one less than e.
          // The digit array of a Decimal from toStringBinary may have trailing zeros.
          for (i = 0; yd[i] == (xd[i] || 0); i++);

          if (yd[i] > (xd[i] || 0)) e--;

          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }

          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {

            // Convert precision in number of base 10 digits to base 1e7 digits.
            sd = sd / logBase + 2 | 0;
            i = 0;

            // divisor < 1e7
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;

              // k is the carry.
              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }

              more = k || i < xL;

            // divisor >= 1e7
            } else {

              // Normalise xd and yd so highest order digit of yd is >= base/2
              k = base / (yd[0] + 1) | 0;

              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }

              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;

              // Add zeros to make remainder as long as divisor.
              for (; remL < yL;) rem[remL++] = 0;

              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];

              if (yd[1] >= base / 2) ++yd0;

              do {
                k = 0;

                // Compare divisor and remainder.
                cmp = compare(yd, rem, yL, remL);

                // If divisor < remainder.
                if (cmp < 0) {

                  // Calculate trial digit, k.
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                  // k will be how many times the divisor goes into the current remainder.
                  k = rem0 / yd0 | 0;

                  //  Algorithm:
                  //  1. product = divisor * trial digit (k)
                  //  2. if product > remainder: product -= divisor, k--
                  //  3. remainder -= product
                  //  4. if product was < remainder at 2:
                  //    5. compare new remainder and divisor
                  //    6. If remainder > divisor: remainder -= divisor, k++

                  if (k > 1) {
                    if (k >= base) k = base - 1;

                    // product = divisor * trial digit.
                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length;

                    // Compare product and remainder.
                    cmp = compare(prod, rem, prodL, remL);

                    // product > remainder.
                    if (cmp == 1) {
                      k--;

                      // Subtract divisor from product.
                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {

                    // cmp is -1.
                    // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                    // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                    if (k == 0) cmp = k = 1;
                    prod = yd.slice();
                  }

                  prodL = prod.length;
                  if (prodL < remL) prod.unshift(0);

                  // Subtract product from remainder.
                  subtract(rem, prod, remL, base);

                  // If product was < previous remainder.
                  if (cmp == -1) {
                    remL = rem.length;

                    // Compare divisor and new remainder.
                    cmp = compare(yd, rem, yL, remL);

                    // If divisor < new remainder, subtract divisor from remainder.
                    if (cmp < 1) {
                      k++;

                      // Subtract divisor from remainder.
                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }

                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }    // if cmp === 1, k will be 0

                // Add the next digit, k, to the result array.
                qd[i++] = k;

                // Update the remainder.
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }

              } while ((xi++ < xL || rem[0] !== void 0) && sd--);

              more = rem[0] !== void 0;
            }

            // Leading zero?
            if (!qd[0]) qd.shift();
          }

          // logBase is 1 when divide is being used for base conversion.
          if (logBase == 1) {
            q.e = e;
            inexact = more;
          } else {

            // To calculate q.e, first get the number of digits of qd[0].
            for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
            q.e = i + e * logBase - 1;

            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
          }

          return q;
        };
      })();


      /*
       * Round `x` to `sd` significant digits using rounding mode `rm`.
       * Check for over/under-flow.
       */
       function finalise(x, sd, rm, isTruncated) {
        var digits, i, j, k, rd, roundUp, w, xd, xdi,
          Ctor = x.constructor;

        // Don't round if sd is null or undefined.
        out: if (sd != null) {
          xd = x.d;

          // Infinity/NaN.
          if (!xd) return x;

          // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
          // w: the word of xd containing rd, a base 1e7 number.
          // xdi: the index of w within xd.
          // digits: the number of digits of w.
          // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
          // they had leading zeros)
          // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

          // Get the length of the first word of the digits array xd.
          for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
          i = sd - digits;

          // Is the rounding digit in the first word of xd?
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0];

            // Get the rounding digit at index j of w.
            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;
            if (xdi >= k) {
              if (isTruncated) {

                // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
                for (; k++ <= xdi;) xd.push(0);
                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi];

              // Get the number of digits of w.
              for (digits = 1; k >= 10; k /= 10) digits++;

              // Get the index of rd within w.
              i %= LOG_BASE;

              // Get the index of rd within w, adjusted for leading zeros.
              // The number of leading zeros of w is given by LOG_BASE - digits.
              j = i - LOG_BASE + digits;

              // Get the rounding digit at index j of w.
              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          }

          // Are there any non-zero digits after the rounding digit?
          isTruncated = isTruncated || sd < 0 ||
            xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

          // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
          // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
          // will give 714.

          roundUp = rm < 4
            ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
            : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

              // Check whether the digit to the left of the rounding digit is odd.
              ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
                rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xd[0]) {
            xd.length = 0;
            if (roundUp) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {

              // Zero.
              xd[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i);

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of w.
            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }

          if (roundUp) {
            for (;;) {

              // Is the digit to be rounded up in the first word of xd?
              if (xdi == 0) {

                // i will be the length of xd[0] before k is added.
                for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
                j = xd[0] += k;
                for (k = 1; j >= 10; j /= 10) k++;

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE) xd[0] = 1;
                }

                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE) break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xd.length; xd[--i] === 0;) xd.pop();
        }

        if (external) {

          // Overflow?
          if (x.e > Ctor.maxE) {

            // Infinity.
            x.d = null;
            x.e = NaN;

          // Underflow?
          } else if (x.e < Ctor.minE) {

            // Zero.
            x.e = 0;
            x.d = [0];
            // Ctor.underflow = true;
          } // else Ctor.underflow = false;
        }

        return x;
      }


      function finiteToString(x, isExp, sd) {
        if (!x.isFinite()) return nonFiniteToString(x);
        var k,
          e = x.e,
          str = digitsToString(x.d),
          len = str.length;

        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + '.' + str.slice(1);
          }

          str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
        } else if (e < 0) {
          str = '0.' + getZeroString(-e - 1) + str;
          if (sd && (k = sd - len) > 0) str += getZeroString(k);
        } else if (e >= len) {
          str += getZeroString(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
        } else {
          if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len) str += '.';
            str += getZeroString(k);
          }
        }

        return str;
      }


      // Calculate the base 10 exponent from the base 1e7 exponent.
      function getBase10Exponent(digits, e) {
        var w = digits[0];

        // Add the number of digits of the first word of the digits array.
        for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
        return e;
      }


      function getLn10(Ctor, sd, pr) {
        if (sd > LN10_PRECISION) {

          // Reset global state in case the exception is caught.
          external = true;
          if (pr) Ctor.precision = pr;
          throw Error(precisionLimitExceeded);
        }
        return finalise(new Ctor(LN10), sd, 1, true);
      }


      function getPi(Ctor, sd, rm) {
        if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
        return finalise(new Ctor(PI), sd, rm, true);
      }


      function getPrecision(digits) {
        var w = digits.length - 1,
          len = w * LOG_BASE + 1;

        w = digits[w];

        // If non-zero...
        if (w) {

          // Subtract the number of trailing zeros of the last word.
          for (; w % 10 == 0; w /= 10) len--;

          // Add the number of digits of the first word.
          for (w = digits[0]; w >= 10; w /= 10) len++;
        }

        return len;
      }


      function getZeroString(k) {
        var zs = '';
        for (; k--;) zs += '0';
        return zs;
      }


      /*
       * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
       * integer of type number.
       *
       * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
       *
       */
      function intPow(Ctor, x, n, pr) {
        var isTruncated,
          r = new Ctor(1),

          // Max n of 9007199254740991 takes 53 loop iterations.
          // Maximum digits array length; leaves [28, 34] guard digits.
          k = Math.ceil(pr / LOG_BASE + 4);

        external = false;

        for (;;) {
          if (n % 2) {
            r = r.times(x);
            if (truncate(r.d, k)) isTruncated = true;
          }

          n = mathfloor(n / 2);
          if (n === 0) {

            // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0) ++r.d[n];
            break;
          }

          x = x.times(x);
          truncate(x.d, k);
        }

        external = true;

        return r;
      }


      function isOdd(n) {
        return n.d[n.d.length - 1] & 1;
      }


      /*
       * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
       */
      function maxOrMin(Ctor, args, ltgt) {
        var y,
          x = new Ctor(args[0]),
          i = 0;

        for (; ++i < args.length;) {
          y = new Ctor(args[i]);
          if (!y.s) {
            x = y;
            break;
          } else if (x[ltgt](y)) {
            x = y;
          }
        }

        return x;
      }


      /*
       * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
       * digits.
       *
       * Taylor/Maclaurin series.
       *
       * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
       *
       * Argument reduction:
       *   Repeat x = x / 32, k += 5, until |x| < 0.1
       *   exp(x) = exp(x / 2^k)^(2^k)
       *
       * Previously, the argument was initially reduced by
       * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
       * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
       * found to be slower than just dividing repeatedly by 32 as above.
       *
       * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
       * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
       * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
       *
       *  exp(Infinity)  = Infinity
       *  exp(-Infinity) = 0
       *  exp(NaN)       = NaN
       *  exp(0)        = 1
       *
       *  exp(x) is non-terminating for any finite, non-zero x.
       *
       *  The result will always be correctly rounded.
       *
       */
      function naturalExponential(x, sd) {
        var denominator, guard, j, pow, sum, t, wpr,
          rep = 0,
          i = 0,
          k = 0,
          Ctor = x.constructor,
          rm = Ctor.rounding,
          pr = Ctor.precision;

        // 0/NaN/Infinity?
        if (!x.d || !x.d[0] || x.e > 17) {

          return new Ctor(x.d
            ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
            : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }

        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }

        t = new Ctor(0.03125);

        // while abs(x) >= 0.1
        while (x.e > -2) {

          // x = x / 2^5
          x = x.times(t);
          k += 5;
        }

        // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
        // necessary to ensure the first 4 rounding digits are correct.
        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow = sum = new Ctor(1);
        Ctor.precision = wpr;

        for (;;) {
          pow = finalise(pow.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum.plus(divide(pow, denominator, wpr, 1));

          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            j = k;
            while (j--) sum = finalise(sum.times(sum), wpr, 1);

            // Check to see if the first 4 rounding digits are [49]999.
            // If so, repeat the summation with a higher precision, otherwise
            // e.g. with precision: 18, rounding: 1
            // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
            // `wpr - guard` is the index of first rounding digit.
            if (sd == null) {

              if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise(sum, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum;
            }
          }

          sum = t;
        }
      }


      /*
       * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
       * digits.
       *
       *  ln(-n)        = NaN
       *  ln(0)         = -Infinity
       *  ln(-0)        = -Infinity
       *  ln(1)         = 0
       *  ln(Infinity)  = Infinity
       *  ln(-Infinity) = NaN
       *  ln(NaN)       = NaN
       *
       *  ln(n) (n != 1) is non-terminating.
       *
       */
      function naturalLogarithm(y, sd) {
        var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
          n = 1,
          guard = 10,
          x = y,
          xd = x.d,
          Ctor = x.constructor,
          rm = Ctor.rounding,
          pr = Ctor.precision;

        // Is x negative or Infinity, NaN, 0 or 1?
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }

        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }

        Ctor.precision = wpr += guard;
        c = digitsToString(xd);
        c0 = c.charAt(0);

        if (Math.abs(e = x.e) < 1.5e15) {

          // Argument reduction.
          // The series converges faster the closer the argument is to 1, so using
          // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
          // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
          // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
          // later be divided by this number, then separate out the power of 10 using
          // ln(a*10^b) = ln(a) + b*ln(10).

          // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
          //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
          // max n is 6 (gives 0.7 - 1.3)
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }

          e = x.e;

          if (c0 > 1) {
            x = new Ctor('0.' + c);
            e++;
          } else {
            x = new Ctor(c0 + '.' + c.slice(1));
          }
        } else {

          // The argument reduction method above may result in overflow if the argument y is a massive
          // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
          // function using ln(x*10^e) = ln(x) + e*ln(10).
          t = getLn10(Ctor, wpr + 2, pr).times(e + '');
          x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;

          return sd == null ? finalise(x, pr, rm, external = true) : x;
        }

        // x1 is x reduced to a value near 1.
        x1 = x;

        // Taylor series.
        // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
        // where x = (y - 1)/(y + 1)    (|x| < 1)
        sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise(x.times(x), wpr, 1);
        denominator = 3;

        for (;;) {
          numerator = finalise(numerator.times(x2), wpr, 1);
          t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            sum = sum.times(2);

            // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
            // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
            if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
            sum = divide(sum, new Ctor(n), wpr, 1);

            // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
            // been repeated previously) and the first 4 rounding digits 9999?
            // If so, restart the summation with a higher precision, otherwise
            // e.g. with precision: 12, rounding: 1
            // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
            // `wpr - guard` is the index of first rounding digit.
            if (sd == null) {
              if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise(sum, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum;
            }
          }

          sum = t;
          denominator += 2;
        }
      }


      // Infinity, NaN.
      function nonFiniteToString(x) {
        // Unsigned.
        return String(x.s * x.s / 0);
      }


      /*
       * Parse the value of a new Decimal `x` from string `str`.
       */
      function parseDecimal(x, str) {
        var e, i, len;

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

        // Determine leading zeros.
        for (i = 0; str.charCodeAt(i) === 48; i++);

        // Determine trailing zeros.
        for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
        str = str.slice(i, len);

        if (str) {
          len -= i;
          x.e = e = e - i - 1;
          x.d = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first word of the digits array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;

          if (i < len) {
            if (i) x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }

          for (; i--;) str += '0';
          x.d.push(+str);

          if (external) {

            // Overflow?
            if (x.e > x.constructor.maxE) {

              // Infinity.
              x.d = null;
              x.e = NaN;

            // Underflow?
            } else if (x.e < x.constructor.minE) {

              // Zero.
              x.e = 0;
              x.d = [0];
              // x.constructor.underflow = true;
            } // else x.constructor.underflow = false;
          }
        } else {

          // Zero.
          x.e = 0;
          x.d = [0];
        }

        return x;
      }


      /*
       * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
       */
      function parseOther(x, str) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

        if (str === 'Infinity' || str === 'NaN') {
          if (!+str) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }

        if (isHex.test(str))  {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary.test(str))  {
          base = 2;
        } else if (isOctal.test(str))  {
          base = 8;
        } else {
          throw Error(invalidArgument + str);
        }

        // Is there a binary exponent part?
        i = str.search(/p/i);

        if (i > 0) {
          p = +str.slice(i + 1);
          str = str.substring(2, i);
        } else {
          str = str.slice(2);
        }

        // Convert `str` as an integer then divide the result by `base` raised to a power such that the
        // fraction part will be restored.
        i = str.indexOf('.');
        isFloat = i >= 0;
        Ctor = x.constructor;

        if (isFloat) {
          str = str.replace('.', '');
          len = str.length;
          i = len - i;

          // log[10](16) = 1.2041... , log[10](88) = 1.9444....
          divisor = intPow(Ctor, new Ctor(base), i, i * 2);
        }

        xd = convertBase(str, base, BASE);
        xe = xd.length - 1;

        // Remove trailing zeros.
        for (i = xe; xd[i] === 0; --i) xd.pop();
        if (i < 0) return new Ctor(x.s * 0);
        x.e = getBase10Exponent(xd, xe);
        x.d = xd;
        external = false;

        // At what precision to perform the division to ensure exact conversion?
        // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
        // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
        // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
        // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
        // Therefore using 4 * the number of digits of str will always be enough.
        if (isFloat) x = divide(x, divisor, len * 4);

        // Multiply by the binary exponent part if present.
        if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
        external = true;

        return x;
      }


      /*
       * sin(x) = x - x^3/3! + x^5/5! - ...
       * |x| < pi/2
       *
       */
      function sine(Ctor, x) {
        var k,
          len = x.d.length;

        if (len < 3) return taylorSeries(Ctor, 2, x, x);

        // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
        // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
        // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

        // Estimate the optimum number of times to use the argument reduction.
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;

        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x);

        // Reverse argument reduction
        var sin2_x,
          d5 = new Ctor(5),
          d16 = new Ctor(16),
          d20 = new Ctor(20);
        for (; k--;) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }

        return x;
      }


      // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
      function taylorSeries(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2,
          pr = Ctor.precision,
          k = Math.ceil(pr / LOG_BASE);

        external = false;
        x2 = x.times(x);
        u = new Ctor(y);

        for (;;) {
          t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);

          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--;);
            if (j == -1) break;
          }

          j = u;
          u = y;
          y = t;
          t = j;
        }

        external = true;
        t.d.length = k + 1;

        return t;
      }


      // Exponent e must be positive and non-zero.
      function tinyPow(b, e) {
        var n = b;
        while (--e) n *= b;
        return n;
      }


      // Return the absolute value of `x` reduced to less than or equal to half pi.
      function toLessThanHalfPi(Ctor, x) {
        var t,
          isNeg = x.s < 0,
          pi = getPi(Ctor, Ctor.precision, 1),
          halfPi = pi.times(0.5);

        x = x.abs();

        if (x.lte(halfPi)) {
          quadrant = isNeg ? 4 : 1;
          return x;
        }

        t = x.divToInt(pi);

        if (t.isZero()) {
          quadrant = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi));

          // 0 <= x < pi
          if (x.lte(halfPi)) {
            quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
            return x;
          }

          quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
        }

        return x.minus(pi).abs();
      }


      /*
       * Return the value of Decimal `x` as a string in base `baseOut`.
       *
       * If the optional `sd` argument is present include a binary exponent suffix.
       */
      function toStringBinary(x, baseOut, sd, rm) {
        var base, e, i, k, len, roundUp, str, xd, y,
          Ctor = x.constructor,
          isExp = sd !== void 0;

        if (isExp) {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }

        if (!x.isFinite()) {
          str = nonFiniteToString(x);
        } else {
          str = finiteToString(x);
          i = str.indexOf('.');

          // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
          // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
          // minBinaryExponent = floor(decimalExponent * log[2](10))
          // log[2](10) = 3.321928094887362347870319429489390175864

          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }

          // Convert the number as an integer then divide the result by its base raised to a power such
          // that the fraction part will be restored.

          // Non-integer.
          if (i >= 0) {
            str = str.replace('.', '');
            y = new Ctor(1);
            y.e = str.length - i;
            y.d = convertBase(finiteToString(y), 10, base);
            y.e = y.d.length;
          }

          xd = convertBase(str, 10, base);
          e = len = xd.length;

          // Remove trailing zeros.
          for (; xd[--len] == 0;) xd.pop();

          if (!xd[0]) {
            str = isExp ? '0p+0' : '0';
          } else {
            if (i < 0) {
              e--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e;
              x = divide(x, y, sd, rm, 0, base);
              xd = x.d;
              e = x.e;
              roundUp = inexact;
            }

            // The rounding digit, i.e. the digit after the digit that may be rounded up.
            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;

            roundUp = rm < 4
              ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
              : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
                rm === (x.s < 0 ? 8 : 7));

            xd.length = sd;

            if (roundUp) {

              // Rounding up may mean the previous digit has to be rounded up and so on.
              for (; ++xd[--sd] > base - 1;) {
                xd[sd] = 0;
                if (!sd) {
                  ++e;
                  xd.unshift(1);
                }
              }
            }

            // Determine trailing zeros.
            for (len = xd.length; !xd[len - 1]; --len);

            // E.g. [4, 11, 15] becomes 4bf.
            for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

            // Add binary exponent suffix?
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;
                  for (--len; len % i; len++) str += '0';
                  xd = convertBase(str, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len);

                  // xd[0] will always be be 1
                  for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
                } else {
                  str = str.charAt(0) + '.' + str.slice(1);
                }
              }

              str =  str + (e < 0 ? 'p' : 'p+') + e;
            } else if (e < 0) {
              for (; ++e;) str = '0' + str;
              str = '0.' + str;
            } else {
              if (++e > len) for (e -= len; e-- ;) str += '0';
              else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
            }
          }

          str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
        }

        return x.s < 0 ? '-' + str : str;
      }


      // Does not strip trailing zeros.
      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }


      // Decimal methods


      /*
       *  abs
       *  acos
       *  acosh
       *  add
       *  asin
       *  asinh
       *  atan
       *  atanh
       *  atan2
       *  cbrt
       *  ceil
       *  clone
       *  config
       *  cos
       *  cosh
       *  div
       *  exp
       *  floor
       *  hypot
       *  ln
       *  log
       *  log2
       *  log10
       *  max
       *  min
       *  mod
       *  mul
       *  pow
       *  random
       *  round
       *  set
       *  sign
       *  sin
       *  sinh
       *  sqrt
       *  sub
       *  tan
       *  tanh
       *  trunc
       */


      /*
       * Return a new Decimal whose value is the absolute value of `x`.
       *
       * x {number|string|Decimal}
       *
       */
      function abs(x) {
        return new this(x).abs();
      }


      /*
       * Return a new Decimal whose value is the arccosine in radians of `x`.
       *
       * x {number|string|Decimal}
       *
       */
      function acos(x) {
        return new this(x).acos();
      }


      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function acosh(x) {
        return new this(x).acosh();
      }


      /*
       * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */
      function add(x, y) {
        return new this(x).plus(y);
      }


      /*
       * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */
      function asin(x) {
        return new this(x).asin();
      }


      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function asinh(x) {
        return new this(x).asinh();
      }


      /*
       * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */
      function atan(x) {
        return new this(x).atan();
      }


      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function atanh(x) {
        return new this(x).atanh();
      }


      /*
       * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
       * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-pi, pi]
       *
       * y {number|string|Decimal} The y-coordinate.
       * x {number|string|Decimal} The x-coordinate.
       *
       * atan2(0, -0)               = pi
       * atan2(0, +0)               = 0
       * atan2(0, -x)               = pi for x > 0
       * atan2(0, x)                = 0 for x > 0
       * atan2(-y, 0)               = -pi/2 for y > 0
       * atan2(y, 0)                = pi/2 for y > 0
       * atan2(y, -Infinity)        = pi for finite y > 0
       * atan2(y, +Infinity)        = 0 for finite y > 0
       * atan2(Infinity, x)         = pi/2 for finite x
       * atan2(Infinity, -Infinity) = 3*pi/4
       * atan2(Infinity, +Infinity) = pi/4
       * atan2(NaN, x) = NaN
       * atan2(y, NaN) = NaN
       *
       */
      function atan2(y, x) {
        y = new this(y);
        x = new this(x);
        var r,
          pr = this.precision,
          rm = this.rounding,
          wpr = pr + 4;

        // Either NaN
        if (!y.s || !x.s) {
          r = new this(NaN);

        // Both Infinity
        } else if (!y.d && !x.d) {
          r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;

        // x is Infinity or y is 0
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
          r.s = y.s;

        // y is Infinity or x is 0
        } else if (!y.d || x.isZero()) {
          r = getPi(this, wpr, 1).times(0.5);
          r.s = y.s;

        // Both non-zero and finite
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide(y, x, wpr, 1));
          x = getPi(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide(y, x, wpr, 1));
        }

        return r;
      }


      /*
       * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */
      function cbrt(x) {
        return new this(x).cbrt();
      }


      /*
       * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
       *
       * x {number|string|Decimal}
       *
       */
      function ceil(x) {
        return finalise(x = new this(x), x.e + 1, 2);
      }


      /*
       * Configure global settings for a Decimal constructor.
       *
       * `obj` is an object with one or more of the following properties,
       *
       *   precision  {number}
       *   rounding   {number}
       *   toExpNeg   {number}
       *   toExpPos   {number}
       *   maxE       {number}
       *   minE       {number}
       *   modulo     {number}
       *   crypto     {boolean|number}
       *   defaults   {true}
       *
       * E.g. Decimal.config({ precision: 20, rounding: 4 })
       *
       */
      function config(obj) {
        if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
        var i, p, v,
          useDefaults = obj.defaults === true,
          ps = [
            'precision', 1, MAX_DIGITS,
            'rounding', 0, 8,
            'toExpNeg', -EXP_LIMIT, 0,
            'toExpPos', 0, EXP_LIMIT,
            'maxE', 0, EXP_LIMIT,
            'minE', -EXP_LIMIT, 0,
            'modulo', 0, 9
          ];

        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
            else throw Error(invalidArgument + p + ': ' + v);
          }
        }

        if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto &&
                (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument + p + ': ' + v);
          }
        }

        return this;
      }


      /*
       * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function cos(x) {
        return new this(x).cos();
      }


      /*
       * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function cosh(x) {
        return new this(x).cosh();
      }


      /*
       * Create and return a Decimal constructor with the same configuration properties as this Decimal
       * constructor.
       *
       */
      function clone(obj) {
        var i, p, ps;

        /*
         * The Decimal constructor and exported function.
         * Return a new Decimal instance.
         *
         * v {number|string|Decimal} A numeric value.
         *
         */
        function Decimal(v) {
          var e, i, t,
            x = this;

          // Decimal called without new.
          if (!(x instanceof Decimal)) return new Decimal(v);

          // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
          // which points to Object.
          x.constructor = Decimal;

          // Duplicate.
          if (v instanceof Decimal) {
            x.s = v.s;

            if (external) {
              if (!v.d || v.e > Decimal.maxE) {

                // Infinity.
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal.minE) {

                // Zero.
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }

            return;
          }

          t = typeof v;

          if (t === 'number') {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }

            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }

            // Fast path for small integers.
            if (v === ~~v && v < 1e7) {
              for (e = 0, i = v; i >= 10; i /= 10) e++;

              if (external) {
                if (e > Decimal.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e < Decimal.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e;
                  x.d = [v];
                }
              } else {
                x.e = e;
                x.d = [v];
              }

              return;

            // Infinity, NaN.
            } else if (v * 0 !== 0) {
              if (!v) x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }

            return parseDecimal(x, v.toString());

          } else if (t !== 'string') {
            throw Error(invalidArgument + v);
          }

          // Minus sign?
          if ((i = v.charCodeAt(0)) === 45) {
            v = v.slice(1);
            x.s = -1;
          } else {
            // Plus sign?
            if (i === 43) v = v.slice(1);
            x.s = 1;
          }

          return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
        }

        Decimal.prototype = P;

        Decimal.ROUND_UP = 0;
        Decimal.ROUND_DOWN = 1;
        Decimal.ROUND_CEIL = 2;
        Decimal.ROUND_FLOOR = 3;
        Decimal.ROUND_HALF_UP = 4;
        Decimal.ROUND_HALF_DOWN = 5;
        Decimal.ROUND_HALF_EVEN = 6;
        Decimal.ROUND_HALF_CEIL = 7;
        Decimal.ROUND_HALF_FLOOR = 8;
        Decimal.EUCLID = 9;

        Decimal.config = Decimal.set = config;
        Decimal.clone = clone;
        Decimal.isDecimal = isDecimalInstance;

        Decimal.abs = abs;
        Decimal.acos = acos;
        Decimal.acosh = acosh;        // ES6
        Decimal.add = add;
        Decimal.asin = asin;
        Decimal.asinh = asinh;        // ES6
        Decimal.atan = atan;
        Decimal.atanh = atanh;        // ES6
        Decimal.atan2 = atan2;
        Decimal.cbrt = cbrt;          // ES6
        Decimal.ceil = ceil;
        Decimal.cos = cos;
        Decimal.cosh = cosh;          // ES6
        Decimal.div = div;
        Decimal.exp = exp;
        Decimal.floor = floor;
        Decimal.hypot = hypot;        // ES6
        Decimal.ln = ln;
        Decimal.log = log;
        Decimal.log10 = log10;        // ES6
        Decimal.log2 = log2;          // ES6
        Decimal.max = max;
        Decimal.min = min;
        Decimal.mod = mod;
        Decimal.mul = mul;
        Decimal.pow = pow;
        Decimal.random = random;
        Decimal.round = round;
        Decimal.sign = sign;          // ES6
        Decimal.sin = sin;
        Decimal.sinh = sinh;          // ES6
        Decimal.sqrt = sqrt;
        Decimal.sub = sub;
        Decimal.tan = tan;
        Decimal.tanh = tanh;          // ES6
        Decimal.trunc = trunc;        // ES6

        if (obj === void 0) obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
            for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
          }
        }

        Decimal.config(obj);

        return Decimal;
      }


      /*
       * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */
      function div(x, y) {
        return new this(x).div(y);
      }


      /*
       * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} The power to which to raise the base of the natural log.
       *
       */
      function exp(x) {
        return new this(x).exp();
      }


      /*
       * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
       *
       * x {number|string|Decimal}
       *
       */
      function floor(x) {
        return finalise(x = new this(x), x.e + 1, 3);
      }


      /*
       * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
       * rounded to `precision` significant digits using rounding mode `rounding`.
       *
       * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
       *
       * arguments {number|string|Decimal}
       *
       */
      function hypot() {
        var i, n,
          t = new this(0);

        external = false;

        for (i = 0; i < arguments.length;) {
          n = new this(arguments[i++]);
          if (!n.d) {
            if (n.s) {
              external = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }

        external = true;

        return t.sqrt();
      }


      /*
       * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
       * otherwise return false.
       *
       */
      function isDecimalInstance(obj) {
        return obj instanceof Decimal || obj && obj.name === '[object Decimal]' || false;
      }


      /*
       * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */
      function ln(x) {
        return new this(x).ln();
      }


      /*
       * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
       * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
       *
       * log[y](x)
       *
       * x {number|string|Decimal} The argument of the logarithm.
       * y {number|string|Decimal} The base of the logarithm.
       *
       */
      function log(x, y) {
        return new this(x).log(y);
      }


      /*
       * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */
      function log2(x) {
        return new this(x).log(2);
      }


      /*
       * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */
      function log10(x) {
        return new this(x).log(10);
      }


      /*
       * Return a new Decimal whose value is the maximum of the arguments.
       *
       * arguments {number|string|Decimal}
       *
       */
      function max() {
        return maxOrMin(this, arguments, 'lt');
      }


      /*
       * Return a new Decimal whose value is the minimum of the arguments.
       *
       * arguments {number|string|Decimal}
       *
       */
      function min() {
        return maxOrMin(this, arguments, 'gt');
      }


      /*
       * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
       * using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */
      function mod(x, y) {
        return new this(x).mod(y);
      }


      /*
       * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */
      function mul(x, y) {
        return new this(x).mul(y);
      }


      /*
       * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} The base.
       * y {number|string|Decimal} The exponent.
       *
       */
      function pow(x, y) {
        return new this(x).pow(y);
      }


      /*
       * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
       * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
       * are produced).
       *
       * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
       *
       */
      function random(sd) {
        var d, e, k, n,
          i = 0,
          r = new this(1),
          rd = [];

        if (sd === void 0) sd = this.precision;
        else checkInt32(sd, 1, MAX_DIGITS);

        k = Math.ceil(sd / LOG_BASE);

        if (!this.crypto) {
          for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

        // Browsers supporting crypto.getRandomValues.
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));

          for (; i < k;) {
            n = d[i];

            // 0 <= n < 4294967296
            // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
            if (n >= 4.29e9) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {

              // 0 <= n <= 4289999999
              // 0 <= (n % 1e7) <= 9999999
              rd[i++] = n % 1e7;
            }
          }

        // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {

          // buffer
          d = crypto.randomBytes(k *= 4);

          for (; i < k;) {

            // 0 <= n < 2147483648
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

            // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
            if (n >= 2.14e9) {
              crypto.randomBytes(4).copy(d, i);
            } else {

              // 0 <= n <= 2139999999
              // 0 <= (n % 1e7) <= 9999999
              rd.push(n % 1e7);
              i += 4;
            }
          }

          i = k / 4;
        } else {
          throw Error(cryptoUnavailable);
        }

        k = rd[--i];
        sd %= LOG_BASE;

        // Convert trailing digits to zeros according to sd.
        if (k && sd) {
          n = mathpow(10, LOG_BASE - sd);
          rd[i] = (k / n | 0) * n;
        }

        // Remove trailing words which are zero.
        for (; rd[i] === 0; i--) rd.pop();

        // Zero?
        if (i < 0) {
          e = 0;
          rd = [0];
        } else {
          e = -1;

          // Remove leading words which are zero and adjust exponent accordingly.
          for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

          // Count the digits of the first word of rd to determine leading zeros.
          for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

          // Adjust the exponent for leading zeros of the first word of rd.
          if (k < LOG_BASE) e -= LOG_BASE - k;
        }

        r.e = e;
        r.d = rd;

        return r;
      }


      /*
       * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
       *
       * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
       *
       * x {number|string|Decimal}
       *
       */
      function round(x) {
        return finalise(x = new this(x), x.e + 1, this.rounding);
      }


      /*
       * Return
       *   1    if x > 0,
       *  -1    if x < 0,
       *   0    if x is 0,
       *  -0    if x is -0,
       *   NaN  otherwise
       *
       * x {number|string|Decimal}
       *
       */
      function sign(x) {
        x = new this(x);
        return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
      }


      /*
       * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
       * using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function sin(x) {
        return new this(x).sin();
      }


      /*
       * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function sinh(x) {
        return new this(x).sinh();
      }


      /*
       * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */
      function sqrt(x) {
        return new this(x).sqrt();
      }


      /*
       * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
       * using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */
      function sub(x, y) {
        return new this(x).sub(y);
      }


      /*
       * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function tan(x) {
        return new this(x).tan();
      }


      /*
       * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */
      function tanh(x) {
        return new this(x).tanh();
      }


      /*
       * Return a new Decimal whose value is `x` truncated to an integer.
       *
       * x {number|string|Decimal}
       *
       */
      function trunc(x) {
        return finalise(x = new this(x), x.e + 1, 1);
      }


      // Create and configure initial Decimal constructor.
      Decimal = clone(DEFAULTS);

      Decimal['default'] = Decimal.Decimal = Decimal;

      // Create the internal constants from their string values.
      LN10 = new Decimal(LN10);
      PI = new Decimal(PI);


      // Export.


      // AMD.
      if ( module.exports) {
        if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {
          P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
          P[Symbol.toStringTag] = 'Decimal';
        }

        module.exports = Decimal;

      // Browser.
      } else {
        if (!globalScope) {
          globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;
        }

        noConflict = globalScope.Decimal;
        Decimal.noConflict = function () {
          globalScope.Decimal = noConflict;
          return Decimal;
        };

        globalScope.Decimal = Decimal;
      }
    })(commonjsGlobal);
    });

    const name = 'BigNumber';
    const dependencies$1 = ['?on', 'config'];

    const createBigNumberClass = /* #__PURE__ */ factory(name, dependencies$1, ({ on, config }) => {
      const BigNumber = decimal.clone({ precision: config.precision });

      /**
       * Attach type information
       */
      BigNumber.prototype.type = 'BigNumber';
      BigNumber.prototype.isBigNumber = true;

      /**
       * Get a JSON representation of a BigNumber containing
       * type information
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "BigNumber", "value": "0.2"}`
       */
      BigNumber.prototype.toJSON = function () {
        return {
          mathjs: 'BigNumber',
          value: this.toString()
        }
      };

      /**
       * Instantiate a BigNumber from a JSON object
       * @param {Object} json  a JSON object structured as:
       *                       `{"mathjs": "BigNumber", "value": "0.2"}`
       * @return {BigNumber}
       */
      BigNumber.fromJSON = function (json) {
        return new BigNumber(json.value)
      };

      if (on) {
        // listen for changed in the configuration, automatically apply changed precision
        on('config', function (curr, prev) {
          if (curr.precision !== prev.precision) {
            BigNumber.config({ precision: curr.precision });
          }
        });
      }

      return BigNumber
    }, { isClass: true });

    var complex = createCommonjsModule(function (module, exports) {
    /**
     * @license Complex.js v2.0.11 11/02/2016
     *
     * Copyright (c) 2016, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **/

    /**
     *
     * This class allows the manipulation of complex numbers.
     * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
     *
     * Object form
     * { re: <real>, im: <imaginary> }
     * { arg: <angle>, abs: <radius> }
     * { phi: <angle>, r: <radius> }
     *
     * Array / Vector form
     * [ real, imaginary ]
     *
     * Double form
     * 99.3 - Single double value
     *
     * String form
     * '23.1337' - Simple real number
     * '15+3i' - a simple complex number
     * '3-i' - a simple complex number
     *
     * Example:
     *
     * var c = new Complex('99.3+8i');
     * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
     *
     */

    (function(root) {

      var cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) * 0.5;
      };

      var sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) * 0.5;
      };

      /**
       * Calculates cos(x) - 1 using Taylor series if x is small.
       *
       * @param {number} x
       * @returns {number} cos(x) - 1
       */

      var cosm1 = function(x) {
        var limit = Math.PI/4;
        if (x < -limit || x > limit) {
          return (Math.cos(x) - 1.0);
        }

        var xx = x * x;
        return xx *
          (-0.5 + xx *
            (1/24 + xx *
              (-1/720 + xx *
                (1/40320 + xx *
                  (-1/3628800 + xx *
                    (1/4790014600 + xx *
                      (-1/87178291200 + xx *
                        (1/20922789888000)
                      )
                    )
                  )
                )
              )
            )
          )
      };

      var hypot = function(x, y) {

        var a = Math.abs(x);
        var b = Math.abs(y);

        if (a < 3000 && b < 3000) {
          return Math.sqrt(a * a + b * b);
        }

        if (a < b) {
          a = b;
          b = x / y;
        } else {
          b = y / x;
        }
        return a * Math.sqrt(1 + b * b);
      };

      var parser_exit = function() {
        throw SyntaxError('Invalid Param');
      };

      /**
       * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
       *
       * @param {number} a
       * @param {number} b
       * @returns {number}
       */
      function logHypot(a, b) {

        var _a = Math.abs(a);
        var _b = Math.abs(b);

        if (a === 0) {
          return Math.log(_b);
        }

        if (b === 0) {
          return Math.log(_a);
        }

        if (_a < 3000 && _b < 3000) {
          return Math.log(a * a + b * b) * 0.5;
        }

        /* I got 4 ideas to compute this property without overflow:
         *
         * Testing 1000000 times with random samples for a,b  [1, 1000000000] against a big decimal library to get an error estimate
         *
         * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

         Math.log(a * a + b * b) / 2

         *
         *
         * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

         var fn = function(a, b) {
         a = Math.abs(a);
         b = Math.abs(b);
         var t = Math.min(a, b);
         a = Math.max(a, b);
         t = t / a;

         return Math.log(a) + Math.log(1 + t * t) / 2;
         };

         * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

         Math.log(a / Math.cos(Math.atan2(b, a)))

         * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

         Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

         */

        return Math.log(a / Math.cos(Math.atan2(b, a)));
      }

      var parse = function(a, b) {

        var z = {'re': 0, 'im': 0};

        if (a === undefined || a === null) {
          z['re'] =
                  z['im'] = 0;
        } else if (b !== undefined) {
          z['re'] = a;
          z['im'] = b;
        } else
          switch (typeof a) {

            case 'object':

              if ('im' in a && 're' in a) {
                z['re'] = a['re'];
                z['im'] = a['im'];
              } else if ('abs' in a && 'arg' in a) {
                if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
                  return Complex['INFINITY'];
                }
                z['re'] = a['abs'] * Math.cos(a['arg']);
                z['im'] = a['abs'] * Math.sin(a['arg']);
              } else if ('r' in a && 'phi' in a) {
                if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
                  return Complex['INFINITY'];
                }
                z['re'] = a['r'] * Math.cos(a['phi']);
                z['im'] = a['r'] * Math.sin(a['phi']);
              } else if (a.length === 2) { // Quick array check
                z['re'] = a[0];
                z['im'] = a[1];
              } else {
                parser_exit();
              }
              break;

            case 'string':

              z['im'] = /* void */
                      z['re'] = 0;

              var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
              var plus = 1;
              var minus = 0;

              if (tokens === null) {
                parser_exit();
              }

              for (var i = 0; i < tokens.length; i++) {

                var c = tokens[i];

                if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
                  plus++;
                } else if (c === '-') {
                  minus++;
                } else if (c === 'i' || c === 'I') {

                  if (plus + minus === 0) {
                    parser_exit();
                  }

                  if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
                    z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
                    i++;
                  } else {
                    z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
                  }
                  plus = minus = 0;

                } else {

                  if (plus + minus === 0 || isNaN(c)) {
                    parser_exit();
                  }

                  if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
                    z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
                    i++;
                  } else {
                    z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
                  }
                  plus = minus = 0;
                }
              }

              // Still something on the stack
              if (plus + minus > 0) {
                parser_exit();
              }
              break;

            case 'number':
              z['im'] = 0;
              z['re'] = a;
              break;

            default:
              parser_exit();
          }

        return z;
      };

      /**
       * @constructor
       * @returns {Complex}
       */
      function Complex(a, b) {

        if (!(this instanceof Complex)) {
          return new Complex(a, b);
        }

        var z = parse(a, b);

        this['re'] = z['re'];
        this['im'] = z['im'];
      }

      Complex.prototype = {

        're': 0,
        'im': 0,

        /**
         * Calculates the sign of a complex number, which is a normalized complex
         *
         * @returns {Complex}
         */
        'sign': function() {

          var abs = this['abs']();

          return new Complex(
                  this['re'] / abs,
                  this['im'] / abs);
        },

        /**
         * Adds two complex numbers
         *
         * @returns {Complex}
         */
        'add': function(a, b) {

          var z = new Complex(a, b);

          // Infinity + Infinity = NaN
          if (this['isInfinite']() && z['isInfinite']()) {
            return Complex['NAN'];
          }

          // Infinity + z = Infinity { where z != Infinity }
          if (this['isInfinite']() || z['isInfinite']()) {
            return Complex['INFINITY'];
          }

          return new Complex(
                  this['re'] + z['re'],
                  this['im'] + z['im']);
        },

        /**
         * Subtracts two complex numbers
         *
         * @returns {Complex}
         */
        'sub': function(a, b) {

          var z = new Complex(a, b);

          // Infinity - Infinity = NaN
          if (this['isInfinite']() && z['isInfinite']()) {
            return Complex['NAN'];
          }

          // Infinity - z = Infinity { where z != Infinity }
          if (this['isInfinite']() || z['isInfinite']()) {
            return Complex['INFINITY'];
          }

          return new Complex(
                  this['re'] - z['re'],
                  this['im'] - z['im']);
        },

        /**
         * Multiplies two complex numbers
         *
         * @returns {Complex}
         */
        'mul': function(a, b) {

          var z = new Complex(a, b);

          // Infinity * 0 = NaN
          if ((this['isInfinite']() && z['isZero']()) || (this['isZero']() && z['isInfinite']())) {
            return Complex['NAN'];
          }

          // Infinity * z = Infinity { where z != 0 }
          if (this['isInfinite']() || z['isInfinite']()) {
            return Complex['INFINITY'];
          }

          // Short circuit for real values
          if (z['im'] === 0 && this['im'] === 0) {
            return new Complex(this['re'] * z['re'], 0);
          }

          return new Complex(
                  this['re'] * z['re'] - this['im'] * z['im'],
                  this['re'] * z['im'] + this['im'] * z['re']);
        },

        /**
         * Divides two complex numbers
         *
         * @returns {Complex}
         */
        'div': function(a, b) {

          var z = new Complex(a, b);

          // 0 / 0 = NaN and Infinity / Infinity = NaN
          if ((this['isZero']() && z['isZero']()) || (this['isInfinite']() && z['isInfinite']())) {
            return Complex['NAN'];
          }

          // Infinity / 0 = Infinity
          if (this['isInfinite']() || z['isZero']()) {
            return Complex['INFINITY'];
          }

          // 0 / Infinity = 0
          if (this['isZero']() || z['isInfinite']()) {
            return Complex['ZERO'];
          }

          a = this['re'];
          b = this['im'];

          var c = z['re'];
          var d = z['im'];
          var t, x;

          if (0 === d) {
            // Divisor is real
            return new Complex(a / c, b / c);
          }

          if (Math.abs(c) < Math.abs(d)) {

            x = c / d;
            t = c * x + d;

            return new Complex(
                    (a * x + b) / t,
                    (b * x - a) / t);

          } else {

            x = d / c;
            t = d * x + c;

            return new Complex(
                    (a + b * x) / t,
                    (b - a * x) / t);
          }
        },

        /**
         * Calculate the power of two complex numbers
         *
         * @returns {Complex}
         */
        'pow': function(a, b) {

          var z = new Complex(a, b);

          a = this['re'];
          b = this['im'];

          if (z['isZero']()) {
            return Complex['ONE'];
          }

          // If the exponent is real
          if (z['im'] === 0) {

            if (b === 0 && a >= 0) {

              return new Complex(Math.pow(a, z['re']), 0);

            } else if (a === 0) { // If base is fully imaginary

              switch ((z['re'] % 4 + 4) % 4) {
                case 0:
                  return new Complex(Math.pow(b, z['re']), 0);
                case 1:
                  return new Complex(0, Math.pow(b, z['re']));
                case 2:
                  return new Complex(-Math.pow(b, z['re']), 0);
                case 3:
                  return new Complex(0, -Math.pow(b, z['re']));
              }
            }
          }

          /* I couldn't find a good formula, so here is a derivation and optimization
           *
           * z_1^z_2 = (a + bi)^(c + di)
           *         = exp((c + di) * log(a + bi)
           *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
           * =>...
           * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
           * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
           *
           * =>...
           * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
           * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
           *
           * =>
           * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
           * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
           *
           */

          if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
            return Complex['ZERO'];
          }

          var arg = Math.atan2(b, a);
          var loh = logHypot(a, b);

          a = Math.exp(z['re'] * loh - z['im'] * arg);
          b = z['im'] * loh + z['re'] * arg;
          return new Complex(
                  a * Math.cos(b),
                  a * Math.sin(b));
        },

        /**
         * Calculate the complex square root
         *
         * @returns {Complex}
         */
        'sqrt': function() {

          var a = this['re'];
          var b = this['im'];
          var r = this['abs']();

          var re, im;

          if (a >= 0) {

            if (b === 0) {
              return new Complex(Math.sqrt(a), 0);
            }

            re = 0.5 * Math.sqrt(2.0 * (r + a));
          } else {
            re = Math.abs(b) / Math.sqrt(2 * (r - a));
          }

          if (a <= 0) {
            im = 0.5 * Math.sqrt(2.0 * (r - a));
          } else {
            im = Math.abs(b) / Math.sqrt(2 * (r + a));
          }

          return new Complex(re, b < 0 ? -im : im);
        },

        /**
         * Calculate the complex exponent
         *
         * @returns {Complex}
         */
        'exp': function() {

          var tmp = Math.exp(this['re']);

          if (this['im'] === 0) ;
          return new Complex(
                  tmp * Math.cos(this['im']),
                  tmp * Math.sin(this['im']));
        },

        /**
         * Calculate the complex exponent and subtracts one.
         *
         * This may be more accurate than `Complex(x).exp().sub(1)` if
         * `x` is small.
         *
         * @returns {Complex}
         */
        'expm1': function() {

          /**
           * exp(a + i*b) - 1
           = exp(a) * (cos(b) + j*sin(b)) - 1
           = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
           */

          var a = this['re'];
          var b = this['im'];

          return new Complex(
                  Math.expm1(a) * Math.cos(b) + cosm1(b),
                  Math.exp(a) * Math.sin(b));
        },

        /**
         * Calculate the natural log
         *
         * @returns {Complex}
         */
        'log': function() {

          var a = this['re'];
          var b = this['im'];

          return new Complex(
                  logHypot(a, b),
                  Math.atan2(b, a));
        },

        /**
         * Calculate the magnitude of the complex number
         *
         * @returns {number}
         */
        'abs': function() {

          return hypot(this['re'], this['im']);
        },

        /**
         * Calculate the angle of the complex number
         *
         * @returns {number}
         */
        'arg': function() {

          return Math.atan2(this['im'], this['re']);
        },

        /**
         * Calculate the sine of the complex number
         *
         * @returns {Complex}
         */
        'sin': function() {

          // sin(c) = (e^b - e^(-b)) / (2i)

          var a = this['re'];
          var b = this['im'];

          return new Complex(
                  Math.sin(a) * cosh(b),
                  Math.cos(a) * sinh(b));
        },

        /**
         * Calculate the cosine
         *
         * @returns {Complex}
         */
        'cos': function() {

          // cos(z) = (e^b + e^(-b)) / 2

          var a = this['re'];
          var b = this['im'];

          return new Complex(
                  Math.cos(a) * cosh(b),
                  -Math.sin(a) * sinh(b));
        },

        /**
         * Calculate the tangent
         *
         * @returns {Complex}
         */
        'tan': function() {

          // tan(c) = (e^(ci) - e^(-ci)) / (i(e^(ci) + e^(-ci)))

          var a = 2 * this['re'];
          var b = 2 * this['im'];
          var d = Math.cos(a) + cosh(b);

          return new Complex(
                  Math.sin(a) / d,
                  sinh(b) / d);
        },

        /**
         * Calculate the cotangent
         *
         * @returns {Complex}
         */
        'cot': function() {

          // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))

          var a = 2 * this['re'];
          var b = 2 * this['im'];
          var d = Math.cos(a) - cosh(b);

          return new Complex(
                  -Math.sin(a) / d,
                  sinh(b) / d);
        },

        /**
         * Calculate the secant
         *
         * @returns {Complex}
         */
        'sec': function() {

          // sec(c) = 2 / (e^(ci) + e^(-ci))

          var a = this['re'];
          var b = this['im'];
          var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);

          return new Complex(
                  Math.cos(a) * cosh(b) / d,
                  Math.sin(a) * sinh(b) / d);
        },

        /**
         * Calculate the cosecans
         *
         * @returns {Complex}
         */
        'csc': function() {

          // csc(c) = 2i / (e^(ci) - e^(-ci))

          var a = this['re'];
          var b = this['im'];
          var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);

          return new Complex(
                  Math.sin(a) * cosh(b) / d,
                  -Math.cos(a) * sinh(b) / d);
        },

        /**
         * Calculate the complex arcus sinus
         *
         * @returns {Complex}
         */
        'asin': function() {

          // asin(c) = -i * log(ci + sqrt(1 - c^2))

          var a = this['re'];
          var b = this['im'];

          var t1 = new Complex(
                  b * b - a * a + 1,
                  -2 * a * b)['sqrt']();

          var t2 = new Complex(
                  t1['re'] - b,
                  t1['im'] + a)['log']();

          return new Complex(t2['im'], -t2['re']);
        },

        /**
         * Calculate the complex arcus cosinus
         *
         * @returns {Complex}
         */
        'acos': function() {

          // acos(c) = i * log(c - i * sqrt(1 - c^2))

          var a = this['re'];
          var b = this['im'];

          var t1 = new Complex(
                  b * b - a * a + 1,
                  -2 * a * b)['sqrt']();

          var t2 = new Complex(
                  t1['re'] - b,
                  t1['im'] + a)['log']();

          return new Complex(Math.PI / 2 - t2['im'], t2['re']);
        },

        /**
         * Calculate the complex arcus tangent
         *
         * @returns {Complex}
         */
        'atan': function() {

          // atan(c) = i / 2 log((i + x) / (i - x))

          var a = this['re'];
          var b = this['im'];

          if (a === 0) {

            if (b === 1) {
              return new Complex(0, Infinity);
            }

            if (b === -1) {
              return new Complex(0, -Infinity);
            }
          }

          var d = a * a + (1.0 - b) * (1.0 - b);

          var t1 = new Complex(
                  (1 - b * b - a * a) / d,
                  -2 * a / d).log();

          return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
        },

        /**
         * Calculate the complex arcus cotangent
         *
         * @returns {Complex}
         */
        'acot': function() {

          // acot(c) = i / 2 log((c - i) / (c + i))

          var a = this['re'];
          var b = this['im'];

          if (b === 0) {
            return new Complex(Math.atan2(1, a), 0);
          }

          var d = a * a + b * b;
          return (d !== 0)
                  ? new Complex(
                          a / d,
                          -b / d).atan()
                  : new Complex(
                          (a !== 0) ? a / 0 : 0,
                          (b !== 0) ? -b / 0 : 0).atan();
        },

        /**
         * Calculate the complex arcus secant
         *
         * @returns {Complex}
         */
        'asec': function() {

          // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))

          var a = this['re'];
          var b = this['im'];

          if (a === 0 && b === 0) {
            return new Complex(0, Infinity);
          }

          var d = a * a + b * b;
          return (d !== 0)
                  ? new Complex(
                          a / d,
                          -b / d).acos()
                  : new Complex(
                          (a !== 0) ? a / 0 : 0,
                          (b !== 0) ? -b / 0 : 0).acos();
        },

        /**
         * Calculate the complex arcus cosecans
         *
         * @returns {Complex}
         */
        'acsc': function() {

          // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))

          var a = this['re'];
          var b = this['im'];

          if (a === 0 && b === 0) {
            return new Complex(Math.PI / 2, Infinity);
          }

          var d = a * a + b * b;
          return (d !== 0)
                  ? new Complex(
                          a / d,
                          -b / d).asin()
                  : new Complex(
                          (a !== 0) ? a / 0 : 0,
                          (b !== 0) ? -b / 0 : 0).asin();
        },

        /**
         * Calculate the complex sinh
         *
         * @returns {Complex}
         */
        'sinh': function() {

          // sinh(c) = (e^c - e^-c) / 2

          var a = this['re'];
          var b = this['im'];

          return new Complex(
                  sinh(a) * Math.cos(b),
                  cosh(a) * Math.sin(b));
        },

        /**
         * Calculate the complex cosh
         *
         * @returns {Complex}
         */
        'cosh': function() {

          // cosh(c) = (e^c + e^-c) / 2

          var a = this['re'];
          var b = this['im'];

          return new Complex(
                  cosh(a) * Math.cos(b),
                  sinh(a) * Math.sin(b));
        },

        /**
         * Calculate the complex tanh
         *
         * @returns {Complex}
         */
        'tanh': function() {

          // tanh(c) = (e^c - e^-c) / (e^c + e^-c)

          var a = 2 * this['re'];
          var b = 2 * this['im'];
          var d = cosh(a) + Math.cos(b);

          return new Complex(
                  sinh(a) / d,
                  Math.sin(b) / d);
        },

        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        'coth': function() {

          // coth(c) = (e^c + e^-c) / (e^c - e^-c)

          var a = 2 * this['re'];
          var b = 2 * this['im'];
          var d = cosh(a) - Math.cos(b);

          return new Complex(
                  sinh(a) / d,
                  -Math.sin(b) / d);
        },

        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        'csch': function() {

          // csch(c) = 2 / (e^c - e^-c)

          var a = this['re'];
          var b = this['im'];
          var d = Math.cos(2 * b) - cosh(2 * a);

          return new Complex(
                  -2 * sinh(a) * Math.cos(b) / d,
                  2 * cosh(a) * Math.sin(b) / d);
        },

        /**
         * Calculate the complex sech
         *
         * @returns {Complex}
         */
        'sech': function() {

          // sech(c) = 2 / (e^c + e^-c)

          var a = this['re'];
          var b = this['im'];
          var d = Math.cos(2 * b) + cosh(2 * a);

          return new Complex(
                  2 * cosh(a) * Math.cos(b) / d,
                  -2 * sinh(a) * Math.sin(b) / d);
        },

        /**
         * Calculate the complex asinh
         *
         * @returns {Complex}
         */
        'asinh': function() {

          // asinh(c) = log(c + sqrt(c^2 + 1))

          var tmp = this['im'];
          this['im'] = -this['re'];
          this['re'] = tmp;
          var res = this['asin']();

          this['re'] = -this['im'];
          this['im'] = tmp;
          tmp = res['re'];

          res['re'] = -res['im'];
          res['im'] = tmp;
          return res;
        },

        /**
         * Calculate the complex asinh
         *
         * @returns {Complex}
         */
        'acosh': function() {

          // acosh(c) = log(c + sqrt(c^2 - 1))

          var res = this['acos']();
          if (res['im'] <= 0) {
            var tmp = res['re'];
            res['re'] = -res['im'];
            res['im'] = tmp;
          } else {
            var tmp = res['im'];
            res['im'] = -res['re'];
            res['re'] = tmp;
          }
          return res;
        },

        /**
         * Calculate the complex atanh
         *
         * @returns {Complex}
         */
        'atanh': function() {

          // atanh(c) = log((1+c) / (1-c)) / 2

          var a = this['re'];
          var b = this['im'];

          var noIM = a > 1 && b === 0;
          var oneMinus = 1 - a;
          var onePlus = 1 + a;
          var d = oneMinus * oneMinus + b * b;

          var x = (d !== 0)
                  ? new Complex(
                          (onePlus * oneMinus - b * b) / d,
                          (b * oneMinus + onePlus * b) / d)
                  : new Complex(
                          (a !== -1) ? (a / 0) : 0,
                          (b !== 0) ? (b / 0) : 0);

          var temp = x['re'];
          x['re'] = logHypot(x['re'], x['im']) / 2;
          x['im'] = Math.atan2(x['im'], temp) / 2;
          if (noIM) {
            x['im'] = -x['im'];
          }
          return x;
        },

        /**
         * Calculate the complex acoth
         *
         * @returns {Complex}
         */
        'acoth': function() {

          // acoth(c) = log((c+1) / (c-1)) / 2

          var a = this['re'];
          var b = this['im'];

          if (a === 0 && b === 0) {
            return new Complex(0, Math.PI / 2);
          }

          var d = a * a + b * b;
          return (d !== 0)
                  ? new Complex(
                          a / d,
                          -b / d).atanh()
                  : new Complex(
                          (a !== 0) ? a / 0 : 0,
                          (b !== 0) ? -b / 0 : 0).atanh();
        },

        /**
         * Calculate the complex acsch
         *
         * @returns {Complex}
         */
        'acsch': function() {

          // acsch(c) = log((1+sqrt(1+c^2))/c)

          var a = this['re'];
          var b = this['im'];

          if (b === 0) {

            return new Complex(
                    (a !== 0)
                    ? Math.log(a + Math.sqrt(a * a + 1))
                    : Infinity, 0);
          }

          var d = a * a + b * b;
          return (d !== 0)
                  ? new Complex(
                          a / d,
                          -b / d).asinh()
                  : new Complex(
                          (a !== 0) ? a / 0 : 0,
                          (b !== 0) ? -b / 0 : 0).asinh();
        },

        /**
         * Calculate the complex asech
         *
         * @returns {Complex}
         */
        'asech': function() {

          // asech(c) = log((1+sqrt(1-c^2))/c)

          var a = this['re'];
          var b = this['im'];

          if (this['isZero']()) {
            return Complex['INFINITY'];
          }

          var d = a * a + b * b;
          return (d !== 0)
                  ? new Complex(
                          a / d,
                          -b / d).acosh()
                  : new Complex(
                          (a !== 0) ? a / 0 : 0,
                          (b !== 0) ? -b / 0 : 0).acosh();
        },

        /**
         * Calculate the complex inverse 1/z
         *
         * @returns {Complex}
         */
        'inverse': function() {

          // 1 / 0 = Infinity and 1 / Infinity = 0
          if (this['isZero']()) {
            return Complex['INFINITY'];
          }

          if (this['isInfinite']()) {
            return Complex['ZERO'];
          }

          var a = this['re'];
          var b = this['im'];

          var d = a * a + b * b;

          return new Complex(a / d, -b / d);
        },

        /**
         * Returns the complex conjugate
         *
         * @returns {Complex}
         */
        'conjugate': function() {

          return new Complex(this['re'], -this['im']);
        },

        /**
         * Gets the negated complex number
         *
         * @returns {Complex}
         */
        'neg': function() {

          return new Complex(-this['re'], -this['im']);
        },

        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        'ceil': function(places) {

          places = Math.pow(10, places || 0);

          return new Complex(
                  Math.ceil(this['re'] * places) / places,
                  Math.ceil(this['im'] * places) / places);
        },

        /**
         * Floors the actual complex number
         *
         * @returns {Complex}
         */
        'floor': function(places) {

          places = Math.pow(10, places || 0);

          return new Complex(
                  Math.floor(this['re'] * places) / places,
                  Math.floor(this['im'] * places) / places);
        },

        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        'round': function(places) {

          places = Math.pow(10, places || 0);

          return new Complex(
                  Math.round(this['re'] * places) / places,
                  Math.round(this['im'] * places) / places);
        },

        /**
         * Compares two complex numbers
         *
         * **Note:** new Complex(Infinity).equals(Infinity) === false
         *
         * @returns {boolean}
         */
        'equals': function(a, b) {

          var z = new Complex(a, b);

          return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&
                  Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
        },

        /**
         * Clones the actual object
         *
         * @returns {Complex}
         */
        'clone': function() {

          return new Complex(this['re'], this['im']);
        },

        /**
         * Gets a string of the actual complex number
         *
         * @returns {string}
         */
        'toString': function() {

          var a = this['re'];
          var b = this['im'];
          var ret = '';

          if (this['isNaN']()) {
            return 'NaN';
          }

          if (this['isZero']()) {
            return '0';
          }

          if (this['isInfinite']()) {
            return 'Infinity';
          }

          if (a !== 0) {
            ret += a;
          }

          if (b !== 0) {

            if (a !== 0) {
              ret += b < 0 ? ' - ' : ' + ';
            } else if (b < 0) {
              ret += '-';
            }

            b = Math.abs(b);

            if (1 !== b) {
              ret += b;
            }
            ret += 'i';
          }

          if (!ret)
            return '0';

          return ret;
        },

        /**
         * Returns the actual number as a vector
         *
         * @returns {Array}
         */
        'toVector': function() {

          return [this['re'], this['im']];
        },

        /**
         * Returns the actual real value of the current object
         *
         * @returns {number|null}
         */
        'valueOf': function() {

          if (this['im'] === 0) {
            return this['re'];
          }
          return null;
        },

        /**
         * Determines whether a complex number is not on the Riemann sphere.
         *
         * @returns {boolean}
         */
        'isNaN': function() {
          return isNaN(this['re']) || isNaN(this['im']);
        },

        /**
         * Determines whether or not a complex number is at the zero pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        'isZero': function() {
          return (
                  (this['re'] === 0 || this['re'] === -0) &&
                  (this['im'] === 0 || this['im'] === -0)
                  );
        },

        /**
         * Determines whether a complex number is not at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        'isFinite': function() {
          return isFinite(this['re']) && isFinite(this['im']);
        },

        /**
         * Determines whether or not a complex number is at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        'isInfinite': function() {
          return !(this['isNaN']() || this['isFinite']());
        }
      };

      Complex['ZERO'] = new Complex(0, 0);
      Complex['ONE'] = new Complex(1, 0);
      Complex['I'] = new Complex(0, 1);
      Complex['PI'] = new Complex(Math.PI, 0);
      Complex['E'] = new Complex(Math.E, 0);
      Complex['INFINITY'] = new Complex(Infinity, Infinity);
      Complex['NAN'] = new Complex(NaN, NaN);
      Complex['EPSILON'] = 1e-16;

      {
        Object.defineProperty(exports, "__esModule", {'value': true});
        Complex['default'] = Complex;
        Complex['Complex'] = Complex;
        module['exports'] = Complex;
      }

    })();
    });

    var Complex = unwrapExports(complex);

    const name$1 = 'Complex';
    const dependencies$2 = [];

    const createComplexClass = /* #__PURE__ */ factory(name$1, dependencies$2, () => {
      /**
       * Attach type information
       */
      Complex.prototype.type = 'Complex';
      Complex.prototype.isComplex = true;

      /**
       * Get a JSON representation of the complex number
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
       */
      Complex.prototype.toJSON = function () {
        return {
          mathjs: 'Complex',
          re: this.re,
          im: this.im
        }
      };

      /*
       * Return the value of the complex number in polar notation
       * The angle phi will be set in the interval of [-pi, pi].
       * @return {{r: number, phi: number}} Returns and object with properties r and phi.
       */
      Complex.prototype.toPolar = function () {
        return {
          r: this.abs(),
          phi: this.arg()
        }
      };

      /**
       * Get a string representation of the complex number,
       * with optional formatting options.
       * @param {Object | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @return {string} str
       */
      Complex.prototype.format = function (options) {
        let str = '';
        let im = this.im;
        let re = this.re;
        const strRe = format(this.re, options);
        const strIm = format(this.im, options);

        // round either re or im when smaller than the configured precision
        const precision = isNumber(options) ? options : options ? options.precision : null;
        if (precision !== null) {
          const epsilon = Math.pow(10, -precision);
          if (Math.abs(re / im) < epsilon) {
            re = 0;
          }
          if (Math.abs(im / re) < epsilon) {
            im = 0;
          }
        }

        if (im === 0) {
          // real value
          str = strRe;
        } else if (re === 0) {
          // purely complex value
          if (im === 1) {
            str = 'i';
          } else if (im === -1) {
            str = '-i';
          } else {
            str = strIm + 'i';
          }
        } else {
          // complex value
          if (im < 0) {
            if (im === -1) {
              str = strRe + ' - i';
            } else {
              str = strRe + ' - ' + strIm.substring(1) + 'i';
            }
          } else {
            if (im === 1) {
              str = strRe + ' + i';
            } else {
              str = strRe + ' + ' + strIm + 'i';
            }
          }
        }
        return str
      };

      /**
       * Create a complex number from polar coordinates
       *
       * Usage:
       *
       *     Complex.fromPolar(r: number, phi: number) : Complex
       *     Complex.fromPolar({r: number, phi: number}) : Complex
       *
       * @param {*} args...
       * @return {Complex}
       */
      Complex.fromPolar = function (args) {
        switch (arguments.length) {
          case 1:
            const arg = arguments[0];
            if (typeof arg === 'object') {
              return Complex(arg)
            }
            throw new TypeError('Input has to be an object with r and phi keys.')

          case 2:
            const r = arguments[0];
            let phi = arguments[1];
            if (isNumber(r)) {
              if (isUnit(phi) && phi.hasBase('ANGLE')) {
                // convert unit to a number in radians
                phi = phi.toNumber('rad');
              }

              if (isNumber(phi)) {
                return new Complex({ r: r, phi: phi })
              }

              throw new TypeError('Phi is not a number nor an angle unit.')
            } else {
              throw new TypeError('Radius r is not a number.')
            }

          default:
            throw new SyntaxError('Wrong number of arguments in function fromPolar')
        }
      };

      Complex.prototype.valueOf = Complex.prototype.toString;

      /**
       * Create a Complex number from a JSON object
       * @param {Object} json  A JSON Object structured as
       *                       {"mathjs": "Complex", "re": 2, "im": 3}
       *                       All properties are optional, default values
       *                       for `re` and `im` are 0.
       * @return {Complex} Returns a new Complex number
       */
      Complex.fromJSON = function (json) {
        return new Complex(json)
      };

      /**
       * Compare two complex numbers, `a` and `b`:
       *
       * - Returns 1 when the real part of `a` is larger than the real part of `b`
       * - Returns -1 when the real part of `a` is smaller than the real part of `b`
       * - Returns 1 when the real parts are equal
       *   and the imaginary part of `a` is larger than the imaginary part of `b`
       * - Returns -1 when the real parts are equal
       *   and the imaginary part of `a` is smaller than the imaginary part of `b`
       * - Returns 0 when both real and imaginary parts are equal.
       *
       * @params {Complex} a
       * @params {Complex} b
       * @returns {number} Returns the comparison result: -1, 0, or 1
       */
      Complex.compare = function (a, b) {
        if (a.re > b.re) { return 1 }
        if (a.re < b.re) { return -1 }

        if (a.im > b.im) { return 1 }
        if (a.im < b.im) { return -1 }

        return 0
      };

      return Complex
    }, { isClass: true });

    var fraction = createCommonjsModule(function (module, exports) {
    /**
     * @license Fraction.js v4.0.12 09/09/2015
     * http://www.xarg.org/2014/03/rational-numbers-in-javascript/
     *
     * Copyright (c) 2015, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **/


    /**
     *
     * This class offers the possibility to calculate fractions.
     * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
     *
     * Array/Object form
     * [ 0 => <nominator>, 1 => <denominator> ]
     * [ n => <nominator>, d => <denominator> ]
     *
     * Integer form
     * - Single integer value
     *
     * Double form
     * - Single double value
     *
     * String form
     * 123.456 - a simple double
     * 123/456 - a string fraction
     * 123.'456' - a double with repeating decimal places
     * 123.(456) - synonym
     * 123.45'6' - a double with repeating last place
     * 123.45(6) - synonym
     *
     * Example:
     *
     * var f = new Fraction("9.4'31'");
     * f.mul([-4, 3]).div(4.9);
     *
     */

    (function(root) {

      // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
      // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
      // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
      var MAX_CYCLE_LEN = 2000;

      // Parsed data to avoid calling "new" all the time
      var P = {
        "s": 1,
        "n": 0,
        "d": 1
      };

      function createError(name) {

        function errorConstructor() {
          var temp = Error.apply(this, arguments);
          temp['name'] = this['name'] = name;
          this['stack'] = temp['stack'];
          this['message'] = temp['message'];
        }

        /**
         * Error constructor
         *
         * @constructor
         */
        function IntermediateInheritor() {}
        IntermediateInheritor.prototype = Error.prototype;
        errorConstructor.prototype = new IntermediateInheritor();

        return errorConstructor;
      }

      var DivisionByZero = Fraction['DivisionByZero'] = createError('DivisionByZero');
      var InvalidParameter = Fraction['InvalidParameter'] = createError('InvalidParameter');

      function assign(n, s) {

        if (isNaN(n = parseInt(n, 10))) {
          throwInvalidParam();
        }
        return n * s;
      }

      function throwInvalidParam() {
        throw new InvalidParameter();
      }

      var parse = function(p1, p2) {

        var n = 0, d = 1, s = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;

        var A = 0, B = 1;
        var C = 1, D = 1;

        var N = 10000000;
        var M;

        if (p1 === undefined || p1 === null) ; else if (p2 !== undefined) {
          n = p1;
          d = p2;
          s = n * d;
        } else
          switch (typeof p1) {

            case "object":
            {
              if ("d" in p1 && "n" in p1) {
                n = p1["n"];
                d = p1["d"];
                if ("s" in p1)
                  n *= p1["s"];
              } else if (0 in p1) {
                n = p1[0];
                if (1 in p1)
                  d = p1[1];
              } else {
                throwInvalidParam();
              }
              s = n * d;
              break;
            }
            case "number":
            {
              if (p1 < 0) {
                s = p1;
                p1 = -p1;
              }

              if (p1 % 1 === 0) {
                n = p1;
              } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

                if (p1 >= 1) {
                  z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                  p1 /= z;
                }

                // Using Farey Sequences
                // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

                while (B <= N && D <= N) {
                  M = (A + C) / (B + D);

                  if (p1 === M) {
                    if (B + D <= N) {
                      n = A + C;
                      d = B + D;
                    } else if (D > B) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                    break;

                  } else {

                    if (p1 > M) {
                      A += C;
                      B += D;
                    } else {
                      C += A;
                      D += B;
                    }

                    if (B > N) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                  }
                }
                n *= z;
              } else if (isNaN(p1) || isNaN(p2)) {
                d = n = NaN;
              }
              break;
            }
            case "string":
            {
              B = p1.match(/\d+|./g);

              if (B === null)
                throwInvalidParam();

              if (B[A] === '-') {// Check for minus sign at the beginning
                s = -1;
                A++;
              } else if (B[A] === '+') {// Check for plus sign at the beginning
                A++;
              }

              if (B.length === A + 1) { // Check if it's just a simple number "1234"
                w = assign(B[A++], s);
              } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

                if (B[A] !== '.') { // Handle 0.5 and .5
                  v = assign(B[A++], s);
                }
                A++;

                // Check for decimal places
                if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                  w = assign(B[A], s);
                  y = Math.pow(10, B[A].length);
                  A++;
                }

                // Check for repeating places
                if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                  x = assign(B[A + 1], s);
                  z = Math.pow(10, B[A + 1].length) - 1;
                  A += 3;
                }

              } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
                w = assign(B[A], s);
                y = assign(B[A + 2], 1);
                A += 3;
              } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
                v = assign(B[A], s);
                w = assign(B[A + 2], s);
                y = assign(B[A + 4], 1);
                A += 5;
              }

              if (B.length <= A) { // Check for more tokens on the stack
                d = y * z;
                s = /* void */
                        n = x + d * v + z * w;
                break;
              }

              /* Fall through on error */
            }
            default:
              throwInvalidParam();
          }

        if (d === 0) {
          throw new DivisionByZero();
        }

        P["s"] = s < 0 ? -1 : 1;
        P["n"] = Math.abs(n);
        P["d"] = Math.abs(d);
      };

      function modpow(b, e, m) {

        var r = 1;
        for (; e > 0; b = (b * b) % m, e >>= 1) {

          if (e & 1) {
            r = (r * b) % m;
          }
        }
        return r;
      }


      function cycleLen(n, d) {

        for (; d % 2 === 0;
                d /= 2) {
        }

        for (; d % 5 === 0;
                d /= 5) {
        }

        if (d === 1) // Catch non-cyclic numbers
          return 0;

        // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
        // 10^(d-1) % d == 1
        // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
        // as we want to translate the numbers to strings.

        var rem = 10 % d;
        var t = 1;

        for (; rem !== 1; t++) {
          rem = rem * 10 % d;

          if (t > MAX_CYCLE_LEN)
            return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
        }
        return t;
      }


         function cycleStart(n, d, len) {

        var rem1 = 1;
        var rem2 = modpow(10, len, d);

        for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
          // Solve 10^s == 10^(s+t) (mod d)

          if (rem1 === rem2)
            return t;

          rem1 = rem1 * 10 % d;
          rem2 = rem2 * 10 % d;
        }
        return 0;
      }

      function gcd(a, b) {

        if (!a)
          return b;
        if (!b)
          return a;

        while (1) {
          a %= b;
          if (!a)
            return b;
          b %= a;
          if (!b)
            return a;
        }
      }
      /**
       * Module constructor
       *
       * @constructor
       * @param {number|Fraction=} a
       * @param {number=} b
       */
      function Fraction(a, b) {

        if (!(this instanceof Fraction)) {
          return new Fraction(a, b);
        }

        parse(a, b);

        if (Fraction['REDUCE']) {
          a = gcd(P["d"], P["n"]); // Abuse a
        } else {
          a = 1;
        }

        this["s"] = P["s"];
        this["n"] = P["n"] / a;
        this["d"] = P["d"] / a;
      }

      /**
       * Boolean global variable to be able to disable automatic reduction of the fraction
       *
       */
      Fraction['REDUCE'] = 1;

      Fraction.prototype = {

        "s": 1,
        "n": 0,
        "d": 1,

        /**
         * Calculates the absolute value
         *
         * Ex: new Fraction(-4).abs() => 4
         **/
        "abs": function() {

          return new Fraction(this["n"], this["d"]);
        },

        /**
         * Inverts the sign of the current fraction
         *
         * Ex: new Fraction(-4).neg() => 4
         **/
        "neg": function() {

          return new Fraction(-this["s"] * this["n"], this["d"]);
        },

        /**
         * Adds two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
         **/
        "add": function(a, b) {

          parse(a, b);
          return new Fraction(
                  this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
                  this["d"] * P["d"]
                  );
        },

        /**
         * Subtracts two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
         **/
        "sub": function(a, b) {

          parse(a, b);
          return new Fraction(
                  this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
                  this["d"] * P["d"]
                  );
        },

        /**
         * Multiplies two rational numbers
         *
         * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
         **/
        "mul": function(a, b) {

          parse(a, b);
          return new Fraction(
                  this["s"] * P["s"] * this["n"] * P["n"],
                  this["d"] * P["d"]
                  );
        },

        /**
         * Divides two rational numbers
         *
         * Ex: new Fraction("-17.(345)").inverse().div(3)
         **/
        "div": function(a, b) {

          parse(a, b);
          return new Fraction(
                  this["s"] * P["s"] * this["n"] * P["d"],
                  this["d"] * P["n"]
                  );
        },

        /**
         * Clones the actual object
         *
         * Ex: new Fraction("-17.(345)").clone()
         **/
        "clone": function() {
          return new Fraction(this);
        },

        /**
         * Calculates the modulo of two rational numbers - a more precise fmod
         *
         * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
         **/
        "mod": function(a, b) {

          if (isNaN(this['n']) || isNaN(this['d'])) {
            return new Fraction(NaN);
          }

          if (a === undefined) {
            return new Fraction(this["s"] * this["n"] % this["d"], 1);
          }

          parse(a, b);
          if (0 === P["n"] && 0 === this["d"]) {
            Fraction(0, 0); // Throw DivisionByZero
          }

          /*
           * First silly attempt, kinda slow
           *
           return that["sub"]({
           "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
           "d": num["d"],
           "s": this["s"]
           });*/

          /*
           * New attempt: a1 / b1 = a2 / b2 * q + r
           * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
           * => (b2 * a1 % a2 * b1) / (b1 * b2)
           */
          return new Fraction(
                  this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
                  P["d"] * this["d"]
                  );
        },

        /**
         * Calculates the fractional gcd of two rational numbers
         *
         * Ex: new Fraction(5,8).gcd(3,7) => 1/56
         */
        "gcd": function(a, b) {

          parse(a, b);

          // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

          return new Fraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
        },

        /**
         * Calculates the fractional lcm of two rational numbers
         *
         * Ex: new Fraction(5,8).lcm(3,7) => 15
         */
        "lcm": function(a, b) {

          parse(a, b);

          // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

          if (P["n"] === 0 && this["n"] === 0) {
            return new Fraction;
          }
          return new Fraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
        },

        /**
         * Calculates the ceil of a rational number
         *
         * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
         **/
        "ceil": function(places) {

          places = Math.pow(10, places || 0);

          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return new Fraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },

        /**
         * Calculates the floor of a rational number
         *
         * Ex: new Fraction('4.(3)').floor() => (4 / 1)
         **/
        "floor": function(places) {

          places = Math.pow(10, places || 0);

          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return new Fraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },

        /**
         * Rounds a rational numbers
         *
         * Ex: new Fraction('4.(3)').round() => (4 / 1)
         **/
        "round": function(places) {

          places = Math.pow(10, places || 0);

          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return new Fraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },

        /**
         * Gets the inverse of the fraction, means numerator and denumerator are exchanged
         *
         * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
         **/
        "inverse": function() {

          return new Fraction(this["s"] * this["d"], this["n"]);
        },

        /**
         * Calculates the fraction to some integer exponent
         *
         * Ex: new Fraction(-1,2).pow(-3) => -8
         */
        "pow": function(m) {

          if (m < 0) {
            return new Fraction(Math.pow(this['s'] * this["d"], -m), Math.pow(this["n"], -m));
          } else {
            return new Fraction(Math.pow(this['s'] * this["n"], m), Math.pow(this["d"], m));
          }
        },

        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "equals": function(a, b) {

          parse(a, b);
          return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
        },

        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "compare": function(a, b) {

          parse(a, b);
          var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
          return (0 < t) - (t < 0);
        },

        "simplify": function(eps) {

          // First naive implementation, needs improvement

          if (isNaN(this['n']) || isNaN(this['d'])) {
            return this;
          }

          var cont = this['abs']()['toContinued']();

          eps = eps || 0.001;

          function rec(a) {
            if (a.length === 1)
              return new Fraction(a[0]);
            return rec(a.slice(1))['inverse']()['add'](a[0]);
          }

          for (var i = 0; i < cont.length; i++) {
            var tmp = rec(cont.slice(0, i + 1));
            if (tmp['sub'](this['abs']())['abs']().valueOf() < eps) {
              return tmp['mul'](this['s']);
            }
          }
          return this;
        },

        /**
         * Check if two rational numbers are divisible
         *
         * Ex: new Fraction(19.6).divisible(1.5);
         */
        "divisible": function(a, b) {

          parse(a, b);
          return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
        },

        /**
         * Returns a decimal representation of the fraction
         *
         * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
         **/
        'valueOf': function() {

          return this["s"] * this["n"] / this["d"];
        },

        /**
         * Returns a string-fraction representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
         **/
        'toFraction': function(excludeWhole) {

          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += '-';
          }

          if (d === 1) {
            str += n;
          } else {

            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              str += " ";
              n %= d;
            }

            str += n;
            str += '/';
            str += d;
          }
          return str;
        },

        /**
         * Returns a latex representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
         **/
        'toLatex': function(excludeWhole) {

          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += '-';
          }

          if (d === 1) {
            str += n;
          } else {

            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              n %= d;
            }

            str += "\\frac{";
            str += n;
            str += '}{';
            str += d;
            str += '}';
          }
          return str;
        },

        /**
         * Returns an array of continued fraction elements
         *
         * Ex: new Fraction("7/8").toContinued() => [0,1,7]
         */
        'toContinued': function() {

          var t;
          var a = this['n'];
          var b = this['d'];
          var res = [];

          if (isNaN(this['n']) || isNaN(this['d'])) {
            return res;
          }

          do {
            res.push(Math.floor(a / b));
            t = a % b;
            a = b;
            b = t;
          } while (a !== 1);

          return res;
        },

        /**
         * Creates a string representation of a fraction with all digits
         *
         * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
         **/
        'toString': function(dec) {

          var g;
          var N = this["n"];
          var D = this["d"];

          if (isNaN(N) || isNaN(D)) {
            return "NaN";
          }

          if (!Fraction['REDUCE']) {
            g = gcd(N, D);
            N /= g;
            D /= g;
          }

          dec = dec || 15; // 15 = decimal places when no repitation

          var cycLen = cycleLen(N, D); // Cycle length
          var cycOff = cycleStart(N, D, cycLen); // Cycle start

          var str = this['s'] === -1 ? "-" : "";

          str += N / D | 0;

          N %= D;
          N *= 10;

          if (N)
            str += ".";

          if (cycLen) {

            for (var i = cycOff; i--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += "(";
            for (var i = cycLen; i--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += ")";
          } else {
            for (var i = dec; N && i--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
          }
          return str;
        }
      };

      {
        Object.defineProperty(exports, "__esModule", {'value': true});
        Fraction['default'] = Fraction;
        Fraction['Fraction'] = Fraction;
        module['exports'] = Fraction;
      }

    })();
    });

    var Fraction = unwrapExports(fraction);

    const name$2 = 'Fraction';
    const dependencies$3 = [];

    const createFractionClass = /* #__PURE__ */ factory(name$2, dependencies$3, () => {
      /**
       * Attach type information
       */
      Fraction.prototype.type = 'Fraction';
      Fraction.prototype.isFraction = true;

      /**
       * Get a JSON representation of a Fraction containing type information
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "Fraction", "n": 3, "d": 8}`
       */
      Fraction.prototype.toJSON = function () {
        return {
          mathjs: 'Fraction',
          n: this.s * this.n,
          d: this.d
        }
      };

      /**
       * Instantiate a Fraction from a JSON object
       * @param {Object} json  a JSON object structured as:
       *                       `{"mathjs": "Fraction", "n": 3, "d": 8}`
       * @return {BigNumber}
       */
      Fraction.fromJSON = function (json) {
        return new Fraction(json)
      };

      return Fraction
    }, { isClass: true });

    const name$3 = 'Matrix';
    const dependencies$4 = [];

    const createMatrixClass = /* #__PURE__ */ factory(name$3, dependencies$4, () => {
      /**
       * @constructor Matrix
       *
       * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
       * array. A matrix can be constructed as:
       *
       *     let matrix = math.matrix(data)
       *
       * Matrix contains the functions to resize, get and set values, get the size,
       * clone the matrix and to convert the matrix to a vector, array, or scalar.
       * Furthermore, one can iterate over the matrix using map and forEach.
       * The internal Array of the Matrix can be accessed using the function valueOf.
       *
       * Example usage:
       *
       *     let matrix = math.matrix([[1, 2], [3, 4]])
       *     matix.size()              // [2, 2]
       *     matrix.resize([3, 2], 5)
       *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]
       *     matrix.subset([1,2])       // 3 (indexes are zero-based)
       *
       */
      function Matrix () {
        if (!(this instanceof Matrix)) {
          throw new SyntaxError('Constructor must be called with the new operator')
        }
      }

      /**
       * Attach type information
       */
      Matrix.prototype.type = 'Matrix';
      Matrix.prototype.isMatrix = true;

      /**
       * Get the Matrix storage constructor for the given format.
       *
       * @param {string} format       The Matrix storage format.
       *
       * @return {Function}           The Matrix storage constructor.
       */
      Matrix.storage = function (format) {
        // TODO: deprecated since v6.0.0. Clean up some day
        throw new Error('Matrix.storage is deprecated since v6.0.0. ' +
          'Use the factory function math.matrix instead.')
      };

      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()   // retrieve storage format
       *
       * @return {string}           The storage format.
       */
      Matrix.prototype.storage = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke storage on a Matrix interface')
      };

      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()    // retrieve matrix datatype
       *
       * @return {string}           The datatype.
       */
      Matrix.prototype.datatype = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke datatype on a Matrix interface')
      };

      /**
       * Create a new Matrix With the type of the current matrix instance
       * @param {Array | Object} data
       * @param {string} [datatype]
       */
      Matrix.prototype.create = function (data, datatype) {
        throw new Error('Cannot invoke create on a Matrix interface')
      };

      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @param {Index} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */
      Matrix.prototype.subset = function (index, replacement, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke subset on a Matrix interface')
      };

      /**
       * Get a single element from the matrix.
       * @param {number[]} index   Zero-based index
       * @return {*} value
       */
      Matrix.prototype.get = function (index) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke get on a Matrix interface')
      };

      /**
       * Replace a single element in the matrix.
       * @param {number[]} index   Zero-based index
       * @param {*} value
       * @param {*} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be left undefined.
       * @return {Matrix} self
       */
      Matrix.prototype.set = function (index, value, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke set on a Matrix interface')
      };

      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @param {number[]} size           The new size the matrix should have.
       * @param {*} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {Matrix}                 The resized matrix
       */
      Matrix.prototype.resize = function (size, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke resize on a Matrix interface')
      };

      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * @param {number[]} size           The new size the matrix should have.
       * @param {boolean} [copy]          Return a reshaped copy of the matrix
       *
       * @return {Matrix}                 The reshaped matrix
       */
      Matrix.prototype.reshape = function (size, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke reshape on a Matrix interface')
      };

      /**
       * Create a clone of the matrix
       * @return {Matrix} clone
       */
      Matrix.prototype.clone = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke clone on a Matrix interface')
      };

      /**
       * Retrieve the size of the matrix.
       * @returns {number[]} size
       */
      Matrix.prototype.size = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke size on a Matrix interface')
      };

      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       *
       * @return {Matrix} matrix
       */
      Matrix.prototype.map = function (callback, skipZeros) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke map on a Matrix interface')
      };

      /**
       * Execute a callback function on each entry of the matrix.
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       */
      Matrix.prototype.forEach = function (callback) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke forEach on a Matrix interface')
      };

      /**
       * Create an Array with a copy of the data of the Matrix
       * @returns {Array} array
       */
      Matrix.prototype.toArray = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke toArray on a Matrix interface')
      };

      /**
       * Get the primitive value of the Matrix: a multidimensional array
       * @returns {Array} array
       */
      Matrix.prototype.valueOf = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke valueOf on a Matrix interface')
      };

      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @param {Object | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @returns {string} str
       */
      Matrix.prototype.format = function (options) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke format on a Matrix interface')
      };

      /**
       * Get a string representation of the matrix
       * @returns {string} str
       */
      Matrix.prototype.toString = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke toString on a Matrix interface')
      };

      return Matrix
    }, { isClass: true });

    const name$4 = 'DenseMatrix';
    const dependencies$5 = [
      'Matrix'
    ];

    const createDenseMatrixClass = /* #__PURE__ */ factory(name$4, dependencies$5, ({ Matrix }) => {
      /**
       * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
       * @class DenseMatrix
       */
      function DenseMatrix (data, datatype) {
        if (!(this instanceof DenseMatrix)) { throw new SyntaxError('Constructor must be called with the new operator') }
        if (datatype && !isString(datatype)) { throw new Error('Invalid datatype: ' + datatype) }

        if (isMatrix(data)) {
          // check data is a DenseMatrix
          if (data.type === 'DenseMatrix') {
            // clone data & size
            this._data = clone(data._data);
            this._size = clone(data._size);
            this._datatype = datatype || data._datatype;
          } else {
            // build data from existing matrix
            this._data = data.toArray();
            this._size = data.size();
            this._datatype = datatype || data._datatype;
          }
        } else if (data && isArray(data.data) && isArray(data.size)) {
          // initialize fields from JSON representation
          this._data = data.data;
          this._size = data.size;
          this._datatype = datatype || data.datatype;
        } else if (isArray(data)) {
          // replace nested Matrices with Arrays
          this._data = preprocess(data);
          // get the dimensions of the array
          this._size = arraySize(this._data);
          // verify the dimensions of the array, TODO: compute size while processing array
          validate(this._data, this._size);
          // data type unknown
          this._datatype = datatype;
        } else if (data) {
          // unsupported type
          throw new TypeError('Unsupported type of data (' + typeOf(data) + ')')
        } else {
          // nothing provided
          this._data = [];
          this._size = [0];
          this._datatype = datatype;
        }
      }

      DenseMatrix.prototype = new Matrix();

      /**
       * Create a new DenseMatrix
       */
      DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {
        return new DenseMatrix(data, datatype)
      };

      /**
       * Attach type information
       */
      DenseMatrix.prototype.type = 'DenseMatrix';
      DenseMatrix.prototype.isDenseMatrix = true;

      /**
       * Get the matrix type
       *
       * Usage:
       *    const matrixType = matrix.getDataType()  // retrieves the matrix type
       *
       * @memberOf DenseMatrix
       * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
       */
      DenseMatrix.prototype.getDataType = function () {
        return getArrayDataType(this._data, typeOf)
      };

      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()  // retrieve storage format
       *
       * @memberof DenseMatrix
       * @return {string}           The storage format.
       */
      DenseMatrix.prototype.storage = function () {
        return 'dense'
      };

      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()   // retrieve matrix datatype
       *
       * @memberof DenseMatrix
       * @return {string}           The datatype.
       */
      DenseMatrix.prototype.datatype = function () {
        return this._datatype
      };

      /**
       * Create a new DenseMatrix
       * @memberof DenseMatrix
       * @param {Array} data
       * @param {string} [datatype]
       */
      DenseMatrix.prototype.create = function (data, datatype) {
        return new DenseMatrix(data, datatype)
      };

      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @memberof DenseMatrix
       * @param {Index} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */
      DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {
        switch (arguments.length) {
          case 1:
            return _get(this, index)

            // intentional fall through
          case 2:
          case 3:
            return _set(this, index, replacement, defaultValue)

          default:
            throw new SyntaxError('Wrong number of arguments')
        }
      };

      /**
       * Get a single element from the matrix.
       * @memberof DenseMatrix
       * @param {number[]} index   Zero-based index
       * @return {*} value
       */
      DenseMatrix.prototype.get = function (index) {
        if (!isArray(index)) { throw new TypeError('Array expected') }
        if (index.length !== this._size.length) { throw new DimensionError(index.length, this._size.length) }

        // check index
        for (let x = 0; x < index.length; x++) { validateIndex(index[x], this._size[x]); }

        let data = this._data;
        for (let i = 0, ii = index.length; i < ii; i++) {
          const indexI = index[i];
          validateIndex(indexI, data.length);
          data = data[indexI];
        }

        return data
      };

      /**
       * Replace a single element in the matrix.
       * @memberof DenseMatrix
       * @param {number[]} index   Zero-based index
       * @param {*} value
       * @param {*} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be left undefined.
       * @return {DenseMatrix} self
       */
      DenseMatrix.prototype.set = function (index, value, defaultValue) {
        if (!isArray(index)) { throw new TypeError('Array expected') }
        if (index.length < this._size.length) { throw new DimensionError(index.length, this._size.length, '<') }

        let i, ii, indexI;

        // enlarge matrix when needed
        const size = index.map(function (i) {
          return i + 1
        });
        _fit(this, size, defaultValue);

        // traverse over the dimensions
        let data = this._data;
        for (i = 0, ii = index.length - 1; i < ii; i++) {
          indexI = index[i];
          validateIndex(indexI, data.length);
          data = data[indexI];
        }

        // set new value
        indexI = index[index.length - 1];
        validateIndex(indexI, data.length);
        data[indexI] = value;

        return this
      };

      /**
       * Get a submatrix of this matrix
       * @memberof DenseMatrix
       * @param {DenseMatrix} matrix
       * @param {Index} index   Zero-based index
       * @private
       */
      function _get (matrix, index) {
        if (!isIndex(index)) {
          throw new TypeError('Invalid index')
        }

        const isScalar = index.isScalar();
        if (isScalar) {
          // return a scalar
          return matrix.get(index.min())
        } else {
          // validate dimensions
          const size = index.size();
          if (size.length !== matrix._size.length) {
            throw new DimensionError(size.length, matrix._size.length)
          }

          // validate if any of the ranges in the index is out of range
          const min = index.min();
          const max = index.max();
          for (let i = 0, ii = matrix._size.length; i < ii; i++) {
            validateIndex(min[i], matrix._size[i]);
            validateIndex(max[i], matrix._size[i]);
          }

          // retrieve submatrix
          // TODO: more efficient when creating an empty matrix and setting _data and _size manually
          return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype)
        }
      }

      /**
       * Recursively get a submatrix of a multi dimensional matrix.
       * Index is not checked for correct number or length of dimensions.
       * @memberof DenseMatrix
       * @param {Array} data
       * @param {Index} index
       * @param {number} dims   Total number of dimensions
       * @param {number} dim    Current dimension
       * @return {Array} submatrix
       * @private
       */
      function _getSubmatrix (data, index, dims, dim) {
        const last = (dim === dims - 1);
        const range = index.dimension(dim);

        if (last) {
          return range.map(function (i) {
            validateIndex(i, data.length);
            return data[i]
          }).valueOf()
        } else {
          return range.map(function (i) {
            validateIndex(i, data.length);
            const child = data[i];
            return _getSubmatrix(child, index, dims, dim + 1)
          }).valueOf()
        }
      }

      /**
       * Replace a submatrix in this matrix
       * Indexes are zero-based.
       * @memberof DenseMatrix
       * @param {DenseMatrix} matrix
       * @param {Index} index
       * @param {DenseMatrix | Array | *} submatrix
       * @param {*} defaultValue          Default value, filled in on new entries when
       *                                  the matrix is resized.
       * @return {DenseMatrix} matrix
       * @private
       */
      function _set (matrix, index, submatrix, defaultValue) {
        if (!index || index.isIndex !== true) {
          throw new TypeError('Invalid index')
        }

        // get index size and check whether the index contains a single value
        const iSize = index.size();
        const isScalar = index.isScalar();

        // calculate the size of the submatrix, and convert it into an Array if needed
        let sSize;
        if (isMatrix(submatrix)) {
          sSize = submatrix.size();
          submatrix = submatrix.valueOf();
        } else {
          sSize = arraySize(submatrix);
        }

        if (isScalar) {
          // set a scalar

          // check whether submatrix is a scalar
          if (sSize.length !== 0) {
            throw new TypeError('Scalar expected')
          }

          matrix.set(index.min(), submatrix, defaultValue);
        } else {
          // set a submatrix

          // validate dimensions
          if (iSize.length < matrix._size.length) {
            throw new DimensionError(iSize.length, matrix._size.length, '<')
          }

          if (sSize.length < iSize.length) {
            // calculate number of missing outer dimensions
            let i = 0;
            let outer = 0;
            while (iSize[i] === 1 && sSize[i] === 1) {
              i++;
            }
            while (iSize[i] === 1) {
              outer++;
              i++;
            }

            // unsqueeze both outer and inner dimensions
            submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
          }

          // check whether the size of the submatrix matches the index size
          if (!deepStrictEqual(iSize, sSize)) {
            throw new DimensionError(iSize, sSize, '>')
          }

          // enlarge matrix when needed
          const size = index.max().map(function (i) {
            return i + 1
          });
          _fit(matrix, size, defaultValue);

          // insert the sub matrix
          const dims = iSize.length;
          const dim = 0;
          _setSubmatrix(matrix._data, index, submatrix, dims, dim);
        }

        return matrix
      }

      /**
       * Replace a submatrix of a multi dimensional matrix.
       * @memberof DenseMatrix
       * @param {Array} data
       * @param {Index} index
       * @param {Array} submatrix
       * @param {number} dims   Total number of dimensions
       * @param {number} dim
       * @private
       */
      function _setSubmatrix (data, index, submatrix, dims, dim) {
        const last = (dim === dims - 1);
        const range = index.dimension(dim);

        if (last) {
          range.forEach(function (dataIndex, subIndex) {
            validateIndex(dataIndex);
            data[dataIndex] = submatrix[subIndex[0]];
          });
        } else {
          range.forEach(function (dataIndex, subIndex) {
            validateIndex(dataIndex);
            _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
          });
        }
      }

      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @memberof DenseMatrix
       * @param {number[]} size           The new size the matrix should have.
       * @param {*} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {Matrix}                 The resized matrix
       */
      DenseMatrix.prototype.resize = function (size, defaultValue, copy) {
        // validate arguments
        if (!isArray(size)) { throw new TypeError('Array expected') }

        // matrix to resize
        const m = copy ? this.clone() : this;
        // resize matrix
        return _resize(m, size, defaultValue)
      };

      function _resize (matrix, size, defaultValue) {
        // check size
        if (size.length === 0) {
          // first value in matrix
          let v = matrix._data;
          // go deep
          while (isArray(v)) {
            v = v[0];
          }
          return v
        }
        // resize matrix
        matrix._size = size.slice(0); // copy the array
        matrix._data = resize(matrix._data, matrix._size, defaultValue);
        // return matrix
        return matrix
      }

      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * NOTE: This might be better suited to copy by default, instead of modifying
       *       in place. For now, it operates in place to remain consistent with
       *       resize().
       *
       * @memberof DenseMatrix
       * @param {number[]} size           The new size the matrix should have.
       * @param {boolean} [copy]          Return a reshaped copy of the matrix
       *
       * @return {Matrix}                 The reshaped matrix
       */
      DenseMatrix.prototype.reshape = function (size, copy) {
        const m = copy ? this.clone() : this;

        m._data = reshape(m._data, size);
        m._size = size.slice(0);
        return m
      };

      /**
       * Enlarge the matrix when it is smaller than given size.
       * If the matrix is larger or equal sized, nothing is done.
       * @memberof DenseMatrix
       * @param {DenseMatrix} matrix           The matrix to be resized
       * @param {number[]} size
       * @param {*} defaultValue          Default value, filled in on new entries.
       * @private
       */
      function _fit (matrix, size, defaultValue) {
        const // copy the array
          newSize = matrix._size.slice(0);

        let changed = false;

        // add dimensions when needed
        while (newSize.length < size.length) {
          newSize.push(0);
          changed = true;
        }

        // enlarge size when needed
        for (let i = 0, ii = size.length; i < ii; i++) {
          if (size[i] > newSize[i]) {
            newSize[i] = size[i];
            changed = true;
          }
        }

        if (changed) {
          // resize only when size is changed
          _resize(matrix, newSize, defaultValue);
        }
      }

      /**
       * Create a clone of the matrix
       * @memberof DenseMatrix
       * @return {DenseMatrix} clone
       */
      DenseMatrix.prototype.clone = function () {
        const m = new DenseMatrix({
          data: clone(this._data),
          size: clone(this._size),
          datatype: this._datatype
        });
        return m
      };

      /**
       * Retrieve the size of the matrix.
       * @memberof DenseMatrix
       * @returns {number[]} size
       */
      DenseMatrix.prototype.size = function () {
        return this._size.slice(0) // return a clone of _size
      };

      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @memberof DenseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       *
       * @return {DenseMatrix} matrix
       */
      DenseMatrix.prototype.map = function (callback) {
        // matrix instance
        const me = this;
        const recurse = function (value, index) {
          if (isArray(value)) {
            return value.map(function (child, i) {
              return recurse(child, index.concat(i))
            })
          } else {
            return callback(value, index, me)
          }
        };
        // return dense format
        return new DenseMatrix({
          data: recurse(this._data, []),
          size: clone(this._size),
          datatype: this._datatype
        })
      };

      /**
       * Execute a callback function on each entry of the matrix.
       * @memberof DenseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       */
      DenseMatrix.prototype.forEach = function (callback) {
        // matrix instance
        const me = this;
        const recurse = function (value, index) {
          if (isArray(value)) {
            value.forEach(function (child, i) {
              recurse(child, index.concat(i));
            });
          } else {
            callback(value, index, me);
          }
        };
        recurse(this._data, []);
      };

      /**
       * Create an Array with a copy of the data of the DenseMatrix
       * @memberof DenseMatrix
       * @returns {Array} array
       */
      DenseMatrix.prototype.toArray = function () {
        return clone(this._data)
      };

      /**
       * Get the primitive value of the DenseMatrix: a multidimensional array
       * @memberof DenseMatrix
       * @returns {Array} array
       */
      DenseMatrix.prototype.valueOf = function () {
        return this._data
      };

      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @memberof DenseMatrix
       * @param {Object | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @returns {string} str
       */
      DenseMatrix.prototype.format = function (options) {
        return format$2(this._data, options)
      };

      /**
       * Get a string representation of the matrix
       * @memberof DenseMatrix
       * @returns {string} str
       */
      DenseMatrix.prototype.toString = function () {
        return format$2(this._data)
      };

      /**
       * Get a JSON representation of the matrix
       * @memberof DenseMatrix
       * @returns {Object}
       */
      DenseMatrix.prototype.toJSON = function () {
        return {
          mathjs: 'DenseMatrix',
          data: this._data,
          size: this._size,
          datatype: this._datatype
        }
      };

      /**
       * Get the kth Matrix diagonal.
       *
       * @memberof DenseMatrix
       * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
       *
       * @returns {Matrix}                     The matrix with the diagonal values.
       */
      DenseMatrix.prototype.diagonal = function (k) {
        // validate k if any
        if (k) {
          // convert BigNumber to a number
          if (isBigNumber(k)) { k = k.toNumber(); }
          // is must be an integer
          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError('The parameter k must be an integer number')
          }
        } else {
          // default value
          k = 0;
        }

        const kSuper = k > 0 ? k : 0;
        const kSub = k < 0 ? -k : 0;

        // rows & columns
        const rows = this._size[0];
        const columns = this._size[1];

        // number diagonal values
        const n = Math.min(rows - kSub, columns - kSuper);

        // x is a matrix get diagonal from matrix
        const data = [];

        // loop rows
        for (let i = 0; i < n; i++) {
          data[i] = this._data[i + kSub][i + kSuper];
        }

        // create DenseMatrix
        return new DenseMatrix({
          data: data,
          size: [n],
          datatype: this._datatype
        })
      };

      /**
       * Create a diagonal matrix.
       *
       * @memberof DenseMatrix
       * @param {Array} size                     The matrix size.
       * @param {number | Matrix | Array } value The values for the diagonal.
       * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.
       * @param {number} [defaultValue]          The default value for non-diagonal
       * @param {string} [datatype]              The datatype for the diagonal
       *
       * @returns {DenseMatrix}
       */
      DenseMatrix.diagonal = function (size, value, k, defaultValue) {
        if (!isArray(size)) { throw new TypeError('Array expected, size parameter') }
        if (size.length !== 2) { throw new Error('Only two dimensions matrix are supported') }

        // map size & validate
        size = size.map(function (s) {
          // check it is a big number
          if (isBigNumber(s)) {
            // convert it
            s = s.toNumber();
          }
          // validate arguments
          if (!isNumber(s) || !isInteger(s) || s < 1) {
            throw new Error('Size values must be positive integers')
          }
          return s
        });

        // validate k if any
        if (k) {
          // convert BigNumber to a number
          if (isBigNumber(k)) { k = k.toNumber(); }
          // is must be an integer
          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError('The parameter k must be an integer number')
          }
        } else {
          // default value
          k = 0;
        }

        const kSuper = k > 0 ? k : 0;
        const kSub = k < 0 ? -k : 0;

        // rows and columns
        const rows = size[0];
        const columns = size[1];

        // number of non-zero items
        const n = Math.min(rows - kSub, columns - kSuper);

        // value extraction function
        let _value;

        // check value
        if (isArray(value)) {
          // validate array
          if (value.length !== n) {
            // number of values in array must be n
            throw new Error('Invalid value array length')
          }
          // define function
          _value = function (i) {
            // return value @ i
            return value[i]
          };
        } else if (isMatrix(value)) {
          // matrix size
          const ms = value.size();
          // validate matrix
          if (ms.length !== 1 || ms[0] !== n) {
            // number of values in array must be n
            throw new Error('Invalid matrix length')
          }
          // define function
          _value = function (i) {
            // return value @ i
            return value.get([i])
          };
        } else {
          // define function
          _value = function () {
            // return value
            return value
          };
        }

        // discover default value if needed
        if (!defaultValue) {
          // check first value in array
          defaultValue = isBigNumber(_value(0))
            ? _value(0).mul(0) // trick to create a BigNumber with value zero
            : 0;
        }

        // empty array
        let data = [];

        // check we need to resize array
        if (size.length > 0) {
          // resize array
          data = resize(data, size, defaultValue);
          // fill diagonal
          for (let d = 0; d < n; d++) {
            data[d + kSub][d + kSuper] = _value(d);
          }
        }

        // create DenseMatrix
        return new DenseMatrix({
          data: data,
          size: [rows, columns]
        })
      };

      /**
       * Generate a matrix from a JSON object
       * @memberof DenseMatrix
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
       *                       where mathjs is optional
       * @returns {DenseMatrix}
       */
      DenseMatrix.fromJSON = function (json) {
        return new DenseMatrix(json)
      };

      /**
       * Swap rows i and j in Matrix.
       *
       * @memberof DenseMatrix
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       *
       * @return {Matrix}        The matrix reference
       */
      DenseMatrix.prototype.swapRows = function (i, j) {
        // check index
        if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
          throw new Error('Row index must be positive integers')
        }
        // check dimensions
        if (this._size.length !== 2) {
          throw new Error('Only two dimensional matrix is supported')
        }
        // validate index
        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[0]);

        // swap rows
        DenseMatrix._swapRows(i, j, this._data);
        // return current instance
        return this
      };

      /**
       * Swap rows i and j in Dense Matrix data structure.
       *
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       * @param {Array} data     Matrix data
       */
      DenseMatrix._swapRows = function (i, j, data) {
        // swap values i <-> j
        const vi = data[i];
        data[i] = data[j];
        data[j] = vi;
      };

      /**
       * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
       * Matrices. Replaces all nested Matrices with Arrays
       * @memberof DenseMatrix
       * @param {Array} data
       * @return {Array} data
       */
      function preprocess (data) {
        for (let i = 0, ii = data.length; i < ii; i++) {
          const elem = data[i];
          if (isArray(elem)) {
            data[i] = preprocess(elem);
          } else if (elem && elem.isMatrix === true) {
            data[i] = preprocess(elem.valueOf());
          }
        }

        return data
      }

      return DenseMatrix
    }, { isClass: true });

    /**
     * Compares two BigNumbers.
     * @param {BigNumber} x       First value to compare
     * @param {BigNumber} y       Second value to compare
     * @param {number} [epsilon]  The maximum relative difference between x and y
     *                            If epsilon is undefined or null, the function will
     *                            test whether x and y are exactly equal.
     * @return {boolean} whether the two numbers are nearly equal
     */
    function nearlyEqual$1 (x, y, epsilon) {
      // if epsilon is null or undefined, test whether x and y are exactly equal
      if (epsilon === null || epsilon === undefined) {
        return x.eq(y)
      }

      // use "==" operator, handles infinities
      if (x.eq(y)) {
        return true
      }

      // NaN
      if (x.isNaN() || y.isNaN()) {
        return false
      }

      // at this point x and y should be finite
      if (x.isFinite() && y.isFinite()) {
        // check numbers are very close, needed when comparing numbers near zero
        const diff = x.minus(y).abs();
        if (diff.isZero()) {
          return true
        } else {
          // use relative error
          const max = x.constructor.max(x.abs(), y.abs());
          return diff.lte(max.times(epsilon))
        }
      }

      // Infinite and Number or negative Infinite and positive Infinite cases
      return false
    }

    /**
     * Test whether two complex values are equal provided a given epsilon.
     * Does not use or change the global Complex.EPSILON setting
     * @param {Complex} x
     * @param {Complex} y
     * @param {number} epsilon
     * @returns {boolean}
     */
    function complexEquals (x, y, epsilon) {
      return nearlyEqual(x.re, y.re, epsilon) && nearlyEqual(x.im, y.im, epsilon)
    }

    const name$5 = 'equalScalar';
    const dependencies$6 = ['typed', 'config'];

    const createEqualScalar = /* #__PURE__ */ factory(name$5, dependencies$6, ({ typed, config }) => {
      /**
       * Test whether two scalar values are nearly equal.
       *
       * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
       * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
       * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
       * @private
       */
      const equalScalar = typed(name$5, {

        'boolean, boolean': function (x, y) {
          return x === y
        },

        'number, number': function (x, y) {
          return nearlyEqual(x, y, config.epsilon)
        },

        'BigNumber, BigNumber': function (x, y) {
          return x.eq(y) || nearlyEqual$1(x, y, config.epsilon)
        },

        'Fraction, Fraction': function (x, y) {
          return x.equals(y)
        },

        'Complex, Complex': function (x, y) {
          return complexEquals(x, y, config.epsilon)
        },

        'Unit, Unit': function (x, y) {
          if (!x.equalBase(y)) {
            throw new Error('Cannot compare units with different base')
          }
          return equalScalar(x.value, y.value)
        }
      });

      return equalScalar
    });

    const createEqualScalarNumber = factory(name$5, ['typed', 'config'], ({ typed, config }) => {
      return typed(name$5, {
        'number, number': function (x, y) {
          return nearlyEqual(x, y, config.epsilon)
        }
      })
    });

    const name$6 = 'SparseMatrix';
    const dependencies$7 = [
      'typed',
      'equalScalar',
      'Matrix'
    ];

    const createSparseMatrixClass = /* #__PURE__ */ factory(name$6, dependencies$7, ({ typed, equalScalar, Matrix }) => {
      /**
       * Sparse Matrix implementation. This type implements a Compressed Column Storage format
       * for sparse matrices.
       * @class SparseMatrix
       */
      function SparseMatrix (data, datatype) {
        if (!(this instanceof SparseMatrix)) { throw new SyntaxError('Constructor must be called with the new operator') }
        if (datatype && !isString(datatype)) { throw new Error('Invalid datatype: ' + datatype) }

        if (isMatrix(data)) {
          // create from matrix
          _createFromMatrix(this, data, datatype);
        } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
          // initialize fields
          this._values = data.values;
          this._index = data.index;
          this._ptr = data.ptr;
          this._size = data.size;
          this._datatype = datatype || data.datatype;
        } else if (isArray(data)) {
          // create from array
          _createFromArray(this, data, datatype);
        } else if (data) {
          // unsupported type
          throw new TypeError('Unsupported type of data (' + typeOf(data) + ')')
        } else {
          // nothing provided
          this._values = [];
          this._index = [];
          this._ptr = [0];
          this._size = [0, 0];
          this._datatype = datatype;
        }
      }

      function _createFromMatrix (matrix, source, datatype) {
        // check matrix type
        if (source.type === 'SparseMatrix') {
          // clone arrays
          matrix._values = source._values ? clone(source._values) : undefined;
          matrix._index = clone(source._index);
          matrix._ptr = clone(source._ptr);
          matrix._size = clone(source._size);
          matrix._datatype = datatype || source._datatype;
        } else {
          // build from matrix data
          _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
        }
      }

      function _createFromArray (matrix, data, datatype) {
        // initialize fields
        matrix._values = [];
        matrix._index = [];
        matrix._ptr = [];
        matrix._datatype = datatype;
        // discover rows & columns, do not use math.size() to avoid looping array twice
        const rows = data.length;
        let columns = 0;

        // equal signature to use
        let eq = equalScalar;
        // zero value
        let zero = 0;

        if (isString(datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
          // convert 0 to the same datatype
          zero = typed.convert(0, datatype);
        }

        // check we have rows (empty array)
        if (rows > 0) {
          // column index
          let j = 0;
          do {
            // store pointer to values index
            matrix._ptr.push(matrix._index.length);
            // loop rows
            for (let i = 0; i < rows; i++) {
              // current row
              const row = data[i];
              // check row is an array
              if (isArray(row)) {
                // update columns if needed (only on first column)
                if (j === 0 && columns < row.length) { columns = row.length; }
                // check row has column
                if (j < row.length) {
                  // value
                  const v = row[j];
                  // check value != 0
                  if (!eq(v, zero)) {
                    // store value
                    matrix._values.push(v);
                    // index
                    matrix._index.push(i);
                  }
                }
              } else {
                // update columns if needed (only on first column)
                if (j === 0 && columns < 1) { columns = 1; }
                // check value != 0 (row is a scalar)
                if (!eq(row, zero)) {
                  // store value
                  matrix._values.push(row);
                  // index
                  matrix._index.push(i);
                }
              }
            }
            // increment index
            j++;
          }
          while (j < columns)
        }
        // store number of values in ptr
        matrix._ptr.push(matrix._index.length);
        // size
        matrix._size = [rows, columns];
      }

      SparseMatrix.prototype = new Matrix();

      /**
       * Create a new SparseMatrix
       */
      SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {
        return new SparseMatrix(data, datatype)
      };

      /**
       * Attach type information
       */
      SparseMatrix.prototype.type = 'SparseMatrix';
      SparseMatrix.prototype.isSparseMatrix = true;

      /**
       * Get the matrix type
       *
       * Usage:
       *    const matrixType = matrix.getDataType()  // retrieves the matrix type
       *
       * @memberOf SparseMatrix
       * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
       */
      SparseMatrix.prototype.getDataType = function () {
        return getArrayDataType(this._values, typeOf)
      };

      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()   // retrieve storage format
       *
       * @memberof SparseMatrix
       * @return {string}           The storage format.
       */
      SparseMatrix.prototype.storage = function () {
        return 'sparse'
      };

      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()    // retrieve matrix datatype
       *
       * @memberof SparseMatrix
       * @return {string}           The datatype.
       */
      SparseMatrix.prototype.datatype = function () {
        return this._datatype
      };

      /**
       * Create a new SparseMatrix
       * @memberof SparseMatrix
       * @param {Array} data
       * @param {string} [datatype]
       */
      SparseMatrix.prototype.create = function (data, datatype) {
        return new SparseMatrix(data, datatype)
      };

      /**
       * Get the matrix density.
       *
       * Usage:
       *     const density = matrix.density()                   // retrieve matrix density
       *
       * @memberof SparseMatrix
       * @return {number}           The matrix density.
       */
      SparseMatrix.prototype.density = function () {
        // rows & columns
        const rows = this._size[0];
        const columns = this._size[1];
        // calculate density
        return rows !== 0 && columns !== 0 ? (this._index.length / (rows * columns)) : 0
      };

      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @memberof SparseMatrix
       * @param {Index} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */
      SparseMatrix.prototype.subset = function (index, replacement, defaultValue) { // check it is a pattern matrix
        if (!this._values) { throw new Error('Cannot invoke subset on a Pattern only matrix') }

        // check arguments
        switch (arguments.length) {
          case 1:
            return _getsubset(this, index)

            // intentional fall through
          case 2:
          case 3:
            return _setsubset(this, index, replacement, defaultValue)

          default:
            throw new SyntaxError('Wrong number of arguments')
        }
      };

      function _getsubset (matrix, idx) {
        // check idx
        if (!isIndex(idx)) {
          throw new TypeError('Invalid index')
        }

        const isScalar = idx.isScalar();
        if (isScalar) {
          // return a scalar
          return matrix.get(idx.min())
        }
        // validate dimensions
        const size = idx.size();
        if (size.length !== matrix._size.length) {
          throw new DimensionError(size.length, matrix._size.length)
        }

        // vars
        let i, ii, k, kk;

        // validate if any of the ranges in the index is out of range
        const min = idx.min();
        const max = idx.max();
        for (i = 0, ii = matrix._size.length; i < ii; i++) {
          validateIndex(min[i], matrix._size[i]);
          validateIndex(max[i], matrix._size[i]);
        }

        // matrix arrays
        const mvalues = matrix._values;
        const mindex = matrix._index;
        const mptr = matrix._ptr;

        // rows & columns dimensions for result matrix
        const rows = idx.dimension(0);
        const columns = idx.dimension(1);

        // workspace & permutation vector
        const w = [];
        const pv = [];

        // loop rows in resulting matrix
        rows.forEach(function (i, r) {
          // update permutation vector
          pv[i] = r[0];
          // mark i in workspace
          w[i] = true;
        });

        // result matrix arrays
        const values = mvalues ? [] : undefined;
        const index = [];
        const ptr = [];

        // loop columns in result matrix
        columns.forEach(function (j) {
          // update ptr
          ptr.push(index.length);
          // loop values in column j
          for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
            // row
            i = mindex[k];
            // check row is in result matrix
            if (w[i] === true) {
              // push index
              index.push(pv[i]);
              // check we need to process values
              if (values) { values.push(mvalues[k]); }
            }
          }
        });
        // update ptr
        ptr.push(index.length);

        // return matrix
        return new SparseMatrix({
          values: values,
          index: index,
          ptr: ptr,
          size: size,
          datatype: matrix._datatype
        })
      }

      function _setsubset (matrix, index, submatrix, defaultValue) {
        // check index
        if (!index || index.isIndex !== true) {
          throw new TypeError('Invalid index')
        }

        // get index size and check whether the index contains a single value
        const iSize = index.size();
        const isScalar = index.isScalar();

        // calculate the size of the submatrix, and convert it into an Array if needed
        let sSize;
        if (isMatrix(submatrix)) {
          // submatrix size
          sSize = submatrix.size();
          // use array representation
          submatrix = submatrix.toArray();
        } else {
          // get submatrix size (array, scalar)
          sSize = arraySize(submatrix);
        }

        // check index is a scalar
        if (isScalar) {
          // verify submatrix is a scalar
          if (sSize.length !== 0) {
            throw new TypeError('Scalar expected')
          }
          // set value
          matrix.set(index.min(), submatrix, defaultValue);
        } else {
          // validate dimensions, index size must be one or two dimensions
          if (iSize.length !== 1 && iSize.length !== 2) {
            throw new DimensionError(iSize.length, matrix._size.length, '<')
          }

          // check submatrix and index have the same dimensions
          if (sSize.length < iSize.length) {
            // calculate number of missing outer dimensions
            let i = 0;
            let outer = 0;
            while (iSize[i] === 1 && sSize[i] === 1) {
              i++;
            }
            while (iSize[i] === 1) {
              outer++;
              i++;
            }
            // unsqueeze both outer and inner dimensions
            submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
          }

          // check whether the size of the submatrix matches the index size
          if (!deepStrictEqual(iSize, sSize)) {
            throw new DimensionError(iSize, sSize, '>')
          }

          // offsets
          const x0 = index.min()[0];
          const y0 = index.min()[1];

          // submatrix rows and columns
          const m = sSize[0];
          const n = sSize[1];

          // loop submatrix
          for (let x = 0; x < m; x++) {
            // loop columns
            for (let y = 0; y < n; y++) {
              // value at i, j
              const v = submatrix[x][y];
              // invoke set (zero value will remove entry from matrix)
              matrix.set([x + x0, y + y0], v, defaultValue);
            }
          }
        }
        return matrix
      }

      /**
       * Get a single element from the matrix.
       * @memberof SparseMatrix
       * @param {number[]} index   Zero-based index
       * @return {*} value
       */
      SparseMatrix.prototype.get = function (index) {
        if (!isArray(index)) { throw new TypeError('Array expected') }
        if (index.length !== this._size.length) { throw new DimensionError(index.length, this._size.length) }

        // check it is a pattern matrix
        if (!this._values) { throw new Error('Cannot invoke get on a Pattern only matrix') }

        // row and column
        const i = index[0];
        const j = index[1];

        // check i, j are valid
        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[1]);

        // find value index
        const k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
        // check k is prior to next column k and it is in the correct row
        if (k < this._ptr[j + 1] && this._index[k] === i) { return this._values[k] }

        return 0
      };

      /**
       * Replace a single element in the matrix.
       * @memberof SparseMatrix
       * @param {number[]} index   Zero-based index
       * @param {*} v
       * @param {*} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be set to zero.
       * @return {SparseMatrix} self
       */
      SparseMatrix.prototype.set = function (index, v, defaultValue) {
        if (!isArray(index)) { throw new TypeError('Array expected') }
        if (index.length !== this._size.length) { throw new DimensionError(index.length, this._size.length) }

        // check it is a pattern matrix
        if (!this._values) { throw new Error('Cannot invoke set on a Pattern only matrix') }

        // row and column
        const i = index[0];
        const j = index[1];

        // rows & columns
        let rows = this._size[0];
        let columns = this._size[1];

        // equal signature to use
        let eq = equalScalar;
        // zero value
        let zero = 0;

        if (isString(this._datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
          // convert 0 to the same datatype
          zero = typed.convert(0, this._datatype);
        }

        // check we need to resize matrix
        if (i > rows - 1 || j > columns - 1) {
          // resize matrix
          _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
          // update rows & columns
          rows = this._size[0];
          columns = this._size[1];
        }

        // check i, j are valid
        validateIndex(i, rows);
        validateIndex(j, columns);

        // find value index
        const k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
        // check k is prior to next column k and it is in the correct row
        if (k < this._ptr[j + 1] && this._index[k] === i) {
          // check value != 0
          if (!eq(v, zero)) {
            // update value
            this._values[k] = v;
          } else {
            // remove value from matrix
            _remove(k, j, this._values, this._index, this._ptr);
          }
        } else {
          // insert value @ (i, j)
          _insert(k, i, j, v, this._values, this._index, this._ptr);
        }

        return this
      };

      function _getValueIndex (i, top, bottom, index) {
        // check row is on the bottom side
        if (bottom - top === 0) { return bottom }
        // loop rows [top, bottom[
        for (let r = top; r < bottom; r++) {
          // check we found value index
          if (index[r] === i) { return r }
        }
        // we did not find row
        return top
      }

      function _remove (k, j, values, index, ptr) {
        // remove value @ k
        values.splice(k, 1);
        index.splice(k, 1);
        // update pointers
        for (let x = j + 1; x < ptr.length; x++) { ptr[x]--; }
      }

      function _insert (k, i, j, v, values, index, ptr) {
        // insert value
        values.splice(k, 0, v);
        // update row for k
        index.splice(k, 0, i);
        // update column pointers
        for (let x = j + 1; x < ptr.length; x++) { ptr[x]++; }
      }

      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @memberof SparseMatrix
       * @param {number[]} size           The new size the matrix should have.
       * @param {*} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {Matrix}                 The resized matrix
       */
      SparseMatrix.prototype.resize = function (size, defaultValue, copy) {
        // validate arguments
        if (!isArray(size)) { throw new TypeError('Array expected') }
        if (size.length !== 2) { throw new Error('Only two dimensions matrix are supported') }

        // check sizes
        size.forEach(function (value) {
          if (!isNumber(value) || !isInteger(value) || value < 0) {
            throw new TypeError('Invalid size, must contain positive integers ' +
                                '(size: ' + format$2(size) + ')')
          }
        });

        // matrix to resize
        const m = copy ? this.clone() : this;
        // resize matrix
        return _resize(m, size[0], size[1], defaultValue)
      };

      function _resize (matrix, rows, columns, defaultValue) {
        // value to insert at the time of growing matrix
        let value = defaultValue || 0;

        // equal signature to use
        let eq = equalScalar;
        // zero value
        let zero = 0;

        if (isString(matrix._datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
          // convert 0 to the same datatype
          zero = typed.convert(0, matrix._datatype);
          // convert value to the same datatype
          value = typed.convert(value, matrix._datatype);
        }

        // should we insert the value?
        const ins = !eq(value, zero);

        // old columns and rows
        const r = matrix._size[0];
        let c = matrix._size[1];

        let i, j, k;

        // check we need to increase columns
        if (columns > c) {
          // loop new columns
          for (j = c; j < columns; j++) {
            // update matrix._ptr for current column
            matrix._ptr[j] = matrix._values.length;
            // check we need to insert matrix._values
            if (ins) {
              // loop rows
              for (i = 0; i < r; i++) {
                // add new matrix._values
                matrix._values.push(value);
                // update matrix._index
                matrix._index.push(i);
              }
            }
          }
          // store number of matrix._values in matrix._ptr
          matrix._ptr[columns] = matrix._values.length;
        } else if (columns < c) {
          // truncate matrix._ptr
          matrix._ptr.splice(columns + 1, c - columns);
          // truncate matrix._values and matrix._index
          matrix._values.splice(matrix._ptr[columns], matrix._values.length);
          matrix._index.splice(matrix._ptr[columns], matrix._index.length);
        }
        // update columns
        c = columns;

        // check we need to increase rows
        if (rows > r) {
          // check we have to insert values
          if (ins) {
            // inserts
            let n = 0;
            // loop columns
            for (j = 0; j < c; j++) {
              // update matrix._ptr for current column
              matrix._ptr[j] = matrix._ptr[j] + n;
              // where to insert matrix._values
              k = matrix._ptr[j + 1] + n;
              // pointer
              let p = 0;
              // loop new rows, initialize pointer
              for (i = r; i < rows; i++, p++) {
                // add value
                matrix._values.splice(k + p, 0, value);
                // update matrix._index
                matrix._index.splice(k + p, 0, i);
                // increment inserts
                n++;
              }
            }
            // store number of matrix._values in matrix._ptr
            matrix._ptr[c] = matrix._values.length;
          }
        } else if (rows < r) {
          // deletes
          let d = 0;
          // loop columns
          for (j = 0; j < c; j++) {
            // update matrix._ptr for current column
            matrix._ptr[j] = matrix._ptr[j] - d;
            // where matrix._values start for next column
            const k0 = matrix._ptr[j];
            const k1 = matrix._ptr[j + 1] - d;
            // loop matrix._index
            for (k = k0; k < k1; k++) {
              // row
              i = matrix._index[k];
              // check we need to delete value and matrix._index
              if (i > rows - 1) {
                // remove value
                matrix._values.splice(k, 1);
                // remove item from matrix._index
                matrix._index.splice(k, 1);
                // increase deletes
                d++;
              }
            }
          }
          // update matrix._ptr for current column
          matrix._ptr[j] = matrix._values.length;
        }
        // update matrix._size
        matrix._size[0] = rows;
        matrix._size[1] = columns;
        // return matrix
        return matrix
      }

      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * NOTE: This might be better suited to copy by default, instead of modifying
       *       in place. For now, it operates in place to remain consistent with
       *       resize().
       *
       * @memberof SparseMatrix
       * @param {number[]} size           The new size the matrix should have.
       * @param {boolean} [copy]          Return a reshaped copy of the matrix
       *
       * @return {Matrix}                 The reshaped matrix
       */
      SparseMatrix.prototype.reshape = function (size, copy) {
        // validate arguments
        if (!isArray(size)) { throw new TypeError('Array expected') }
        if (size.length !== 2) { throw new Error('Sparse matrices can only be reshaped in two dimensions') }

        // check sizes
        size.forEach(function (value) {
          if (!isNumber(value) || !isInteger(value) || value < 0) {
            throw new TypeError('Invalid size, must contain positive integers ' +
                                '(size: ' + format$2(size) + ')')
          }
        });

        // m * n must not change
        if (this._size[0] * this._size[1] !== size[0] * size[1]) {
          throw new Error('Reshaping sparse matrix will result in the wrong number of elements')
        }

        // matrix to reshape
        const m = copy ? this.clone() : this;

        // return unchanged if the same shape
        if (this._size[0] === size[0] && this._size[1] === size[1]) {
          return m
        }

        // Convert to COO format (generate a column index)
        const colIndex = [];
        for (let i = 0; i < m._ptr.length; i++) {
          for (let j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
            colIndex.push(i);
          }
        }

        // Clone the values array
        const values = m._values.slice();

        // Clone the row index array
        const rowIndex = m._index.slice();

        // Transform the (row, column) indices
        for (let i = 0; i < m._index.length; i++) {
          const r1 = rowIndex[i];
          const c1 = colIndex[i];
          const flat = r1 * m._size[1] + c1;
          colIndex[i] = flat % size[1];
          rowIndex[i] = Math.floor(flat / size[1]);
        }

        // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
        // in column-major order, so we have to reorder the value array now. One option is to use a multisort,
        // sorting several arrays based on some other array.

        // OR, we could easily just:

        // 1. Remove all values from the matrix
        m._values.length = 0;
        m._index.length = 0;
        m._ptr.length = size[1] + 1;
        m._size = size.slice();
        for (let i = 0; i < m._ptr.length; i++) {
          m._ptr[i] = 0;
        }

        // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
        // This step is probably the most time-consuming
        for (let h = 0; h < values.length; h++) {
          const i = rowIndex[h];
          const j = colIndex[h];
          const v = values[h];
          const k = _getValueIndex(i, m._ptr[j], m._ptr[j + 1], m._index);
          _insert(k, i, j, v, m._values, m._index, m._ptr);
        }

        // The value indices are inserted out of order, but apparently that's... still OK?

        return m
      };

      /**
       * Create a clone of the matrix
       * @memberof SparseMatrix
       * @return {SparseMatrix} clone
       */
      SparseMatrix.prototype.clone = function () {
        const m = new SparseMatrix({
          values: this._values ? clone(this._values) : undefined,
          index: clone(this._index),
          ptr: clone(this._ptr),
          size: clone(this._size),
          datatype: this._datatype
        });
        return m
      };

      /**
       * Retrieve the size of the matrix.
       * @memberof SparseMatrix
       * @returns {number[]} size
       */
      SparseMatrix.prototype.size = function () {
        return this._size.slice(0) // copy the Array
      };

      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @memberof SparseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       *
       * @return {SparseMatrix} matrix
       */
      SparseMatrix.prototype.map = function (callback, skipZeros) {
        // check it is a pattern matrix
        if (!this._values) { throw new Error('Cannot invoke map on a Pattern only matrix') }
        // matrix instance
        const me = this;
        // rows and columns
        const rows = this._size[0];
        const columns = this._size[1];
        // invoke callback
        const invoke = function (v, i, j) {
          // invoke callback
          return callback(v, [i, j], me)
        };
        // invoke _map
        return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros)
      };

      /**
       * Create a new matrix with the results of the callback function executed on the interval
       * [minRow..maxRow, minColumn..maxColumn].
       */
      function _map (matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
        // result arrays
        const values = [];
        const index = [];
        const ptr = [];

        // equal signature to use
        let eq = equalScalar;
        // zero value
        let zero = 0;

        if (isString(matrix._datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
          // convert 0 to the same datatype
          zero = typed.convert(0, matrix._datatype);
        }

        // invoke callback
        const invoke = function (v, x, y) {
          // invoke callback
          v = callback(v, x, y);
          // check value != 0
          if (!eq(v, zero)) {
            // store value
            values.push(v);
            // index
            index.push(x);
          }
        };
        // loop columns
        for (let j = minColumn; j <= maxColumn; j++) {
          // store pointer to values index
          ptr.push(values.length);
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          const k0 = matrix._ptr[j];
          const k1 = matrix._ptr[j + 1];

          if (skipZeros) {
            // loop k within [k0, k1[
            for (let k = k0; k < k1; k++) {
              // row index
              const i = matrix._index[k];
              // check i is in range
              if (i >= minRow && i <= maxRow) {
                // value @ k
                invoke(matrix._values[k], i - minRow, j - minColumn);
              }
            }
          } else {
            // create a cache holding all defined values
            const values = {};
            for (let k = k0; k < k1; k++) {
              const i = matrix._index[k];
              values[i] = matrix._values[k];
            }

            // loop over all rows (indexes can be unordered so we can't use that),
            // and either read the value or zero
            for (let i = minRow; i <= maxRow; i++) {
              const value = (i in values) ? values[i] : 0;
              invoke(value, i - minRow, j - minColumn);
            }
          }
        }

        // store number of values in ptr
        ptr.push(values.length);
        // return sparse matrix
        return new SparseMatrix({
          values: values,
          index: index,
          ptr: ptr,
          size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
        })
      }

      /**
       * Execute a callback function on each entry of the matrix.
       * @memberof SparseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       */
      SparseMatrix.prototype.forEach = function (callback, skipZeros) {
        // check it is a pattern matrix
        if (!this._values) { throw new Error('Cannot invoke forEach on a Pattern only matrix') }
        // matrix instance
        const me = this;
        // rows and columns
        const rows = this._size[0];
        const columns = this._size[1];
        // loop columns
        for (let j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          const k0 = this._ptr[j];
          const k1 = this._ptr[j + 1];

          if (skipZeros) {
            // loop k within [k0, k1[
            for (let k = k0; k < k1; k++) {
              // row index
              const i = this._index[k];

              // value @ k
              callback(this._values[k], [i, j], me);
            }
          } else {
            // create a cache holding all defined values
            const values = {};
            for (let k = k0; k < k1; k++) {
              const i = this._index[k];
              values[i] = this._values[k];
            }

            // loop over all rows (indexes can be unordered so we can't use that),
            // and either read the value or zero
            for (let i = 0; i < rows; i++) {
              const value = (i in values) ? values[i] : 0;
              callback(value, [i, j], me);
            }
          }
        }
      };

      /**
       * Create an Array with a copy of the data of the SparseMatrix
       * @memberof SparseMatrix
       * @returns {Array} array
       */
      SparseMatrix.prototype.toArray = function () {
        return _toArray(this._values, this._index, this._ptr, this._size, true)
      };

      /**
       * Get the primitive value of the SparseMatrix: a two dimensions array
       * @memberof SparseMatrix
       * @returns {Array} array
       */
      SparseMatrix.prototype.valueOf = function () {
        return _toArray(this._values, this._index, this._ptr, this._size, false)
      };

      function _toArray (values, index, ptr, size, copy) {
        // rows and columns
        const rows = size[0];
        const columns = size[1];
        // result
        const a = [];
        // vars
        let i, j;
        // initialize array
        for (i = 0; i < rows; i++) {
          a[i] = [];
          for (j = 0; j < columns; j++) { a[i][j] = 0; }
        }

        // loop columns
        for (j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          const k0 = ptr[j];
          const k1 = ptr[j + 1];
          // loop k within [k0, k1[
          for (let k = k0; k < k1; k++) {
            // row index
            i = index[k];
            // set value (use one for pattern matrix)
            a[i][j] = values ? (copy ? clone(values[k]) : values[k]) : 1;
          }
        }
        return a
      }

      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @memberof SparseMatrix
       * @param {Object | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @returns {string} str
       */
      SparseMatrix.prototype.format = function (options) {
        // rows and columns
        const rows = this._size[0];
        const columns = this._size[1];
        // density
        const density = this.density();
        // rows & columns
        let str = 'Sparse Matrix [' + format$2(rows, options) + ' x ' + format$2(columns, options) + '] density: ' + format$2(density, options) + '\n';
        // loop columns
        for (let j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          const k0 = this._ptr[j];
          const k1 = this._ptr[j + 1];
          // loop k within [k0, k1[
          for (let k = k0; k < k1; k++) {
            // row index
            const i = this._index[k];
            // append value
            str += '\n    (' + format$2(i, options) + ', ' + format$2(j, options) + ') ==> ' + (this._values ? format$2(this._values[k], options) : 'X');
          }
        }
        return str
      };

      /**
       * Get a string representation of the matrix
       * @memberof SparseMatrix
       * @returns {string} str
       */
      SparseMatrix.prototype.toString = function () {
        return format$2(this.toArray())
      };

      /**
       * Get a JSON representation of the matrix
       * @memberof SparseMatrix
       * @returns {Object}
       */
      SparseMatrix.prototype.toJSON = function () {
        return {
          mathjs: 'SparseMatrix',
          values: this._values,
          index: this._index,
          ptr: this._ptr,
          size: this._size,
          datatype: this._datatype
        }
      };

      /**
       * Get the kth Matrix diagonal.
       *
       * @memberof SparseMatrix
       * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
       *
       * @returns {Matrix}                     The matrix vector with the diagonal values.
       */
      SparseMatrix.prototype.diagonal = function (k) {
        // validate k if any
        if (k) {
          // convert BigNumber to a number
          if (isBigNumber(k)) { k = k.toNumber(); }
          // is must be an integer
          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError('The parameter k must be an integer number')
          }
        } else {
          // default value
          k = 0;
        }

        const kSuper = k > 0 ? k : 0;
        const kSub = k < 0 ? -k : 0;

        // rows & columns
        const rows = this._size[0];
        const columns = this._size[1];

        // number diagonal values
        const n = Math.min(rows - kSub, columns - kSuper);

        // diagonal arrays
        const values = [];
        const index = [];
        const ptr = [];
        // initial ptr value
        ptr[0] = 0;
        // loop columns
        for (let j = kSuper; j < columns && values.length < n; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          const k0 = this._ptr[j];
          const k1 = this._ptr[j + 1];
          // loop x within [k0, k1[
          for (let x = k0; x < k1; x++) {
            // row index
            const i = this._index[x];
            // check row
            if (i === j - kSuper + kSub) {
              // value on this column
              values.push(this._values[x]);
              // store row
              index[values.length - 1] = i - kSub;
              // exit loop
              break
            }
          }
        }
        // close ptr
        ptr.push(values.length);
        // return matrix
        return new SparseMatrix({
          values: values,
          index: index,
          ptr: ptr,
          size: [n, 1]
        })
      };

      /**
       * Generate a matrix from a JSON object
       * @memberof SparseMatrix
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
       *                       where mathjs is optional
       * @returns {SparseMatrix}
       */
      SparseMatrix.fromJSON = function (json) {
        return new SparseMatrix(json)
      };

      /**
       * Create a diagonal matrix.
       *
       * @memberof SparseMatrix
       * @param {Array} size                       The matrix size.
       * @param {number | Array | Matrix } value   The values for the diagonal.
       * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
       * @param {number} [defaultValue]            The default value for non-diagonal
       * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
       *
       * @returns {SparseMatrix}
       */
      SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {
        if (!isArray(size)) { throw new TypeError('Array expected, size parameter') }
        if (size.length !== 2) { throw new Error('Only two dimensions matrix are supported') }

        // map size & validate
        size = size.map(function (s) {
          // check it is a big number
          if (isBigNumber(s)) {
            // convert it
            s = s.toNumber();
          }
          // validate arguments
          if (!isNumber(s) || !isInteger(s) || s < 1) {
            throw new Error('Size values must be positive integers')
          }
          return s
        });

        // validate k if any
        if (k) {
          // convert BigNumber to a number
          if (isBigNumber(k)) { k = k.toNumber(); }
          // is must be an integer
          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError('The parameter k must be an integer number')
          }
        } else {
          // default value
          k = 0;
        }

        // equal signature to use
        let eq = equalScalar;
        // zero value
        let zero = 0;

        if (isString(datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
          // convert 0 to the same datatype
          zero = typed.convert(0, datatype);
        }

        const kSuper = k > 0 ? k : 0;
        const kSub = k < 0 ? -k : 0;

        // rows and columns
        const rows = size[0];
        const columns = size[1];

        // number of non-zero items
        const n = Math.min(rows - kSub, columns - kSuper);

        // value extraction function
        let _value;

        // check value
        if (isArray(value)) {
          // validate array
          if (value.length !== n) {
            // number of values in array must be n
            throw new Error('Invalid value array length')
          }
          // define function
          _value = function (i) {
            // return value @ i
            return value[i]
          };
        } else if (isMatrix(value)) {
          // matrix size
          const ms = value.size();
          // validate matrix
          if (ms.length !== 1 || ms[0] !== n) {
            // number of values in array must be n
            throw new Error('Invalid matrix length')
          }
          // define function
          _value = function (i) {
            // return value @ i
            return value.get([i])
          };
        } else {
          // define function
          _value = function () {
            // return value
            return value
          };
        }

        // create arrays
        const values = [];
        const index = [];
        const ptr = [];

        // loop items
        for (let j = 0; j < columns; j++) {
          // number of rows with value
          ptr.push(values.length);
          // diagonal index
          const i = j - kSuper;
          // check we need to set diagonal value
          if (i >= 0 && i < n) {
            // get value @ i
            const v = _value(i);
            // check for zero
            if (!eq(v, zero)) {
              // column
              index.push(i + kSub);
              // add value
              values.push(v);
            }
          }
        }
        // last value should be number of values
        ptr.push(values.length);
        // create SparseMatrix
        return new SparseMatrix({
          values: values,
          index: index,
          ptr: ptr,
          size: [rows, columns]
        })
      };

      /**
       * Swap rows i and j in Matrix.
       *
       * @memberof SparseMatrix
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       *
       * @return {Matrix}        The matrix reference
       */
      SparseMatrix.prototype.swapRows = function (i, j) {
        // check index
        if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
          throw new Error('Row index must be positive integers')
        }
        // check dimensions
        if (this._size.length !== 2) {
          throw new Error('Only two dimensional matrix is supported')
        }
        // validate index
        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[0]);

        // swap rows
        SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
        // return current instance
        return this
      };

      /**
       * Loop rows with data in column j.
       *
       * @param {number} j            Column
       * @param {Array} values        Matrix values
       * @param {Array} index         Matrix row indeces
       * @param {Array} ptr           Matrix column pointers
       * @param {Function} callback   Callback function invoked for every row in column j
       */
      SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {
        // indeces for column j
        const k0 = ptr[j];
        const k1 = ptr[j + 1];
        // loop
        for (let k = k0; k < k1; k++) {
          // invoke callback
          callback(index[k], values[k]);
        }
      };

      /**
       * Swap rows x and y in Sparse Matrix data structures.
       *
       * @param {number} x         Matrix row index 1
       * @param {number} y         Matrix row index 2
       * @param {number} columns   Number of columns in matrix
       * @param {Array} values     Matrix values
       * @param {Array} index      Matrix row indeces
       * @param {Array} ptr        Matrix column pointers
       */
      SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {
        // loop columns
        for (let j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          const k0 = ptr[j];
          const k1 = ptr[j + 1];
          // find value index @ x
          const kx = _getValueIndex(x, k0, k1, index);
          // find value index @ x
          const ky = _getValueIndex(y, k0, k1, index);
          // check both rows exist in matrix
          if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
            // swap values (check for pattern matrix)
            if (values) {
              const v = values[kx];
              values[kx] = values[ky];
              values[ky] = v;
            }
            // next column
            continue
          }
          // check x row exist & no y row
          if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
            // value @ x (check for pattern matrix)
            const vx = values ? values[kx] : undefined;
            // insert value @ y
            index.splice(ky, 0, y);
            if (values) { values.splice(ky, 0, vx); }
            // remove value @ x (adjust array index if needed)
            index.splice(ky <= kx ? kx + 1 : kx, 1);
            if (values) { values.splice(ky <= kx ? kx + 1 : kx, 1); }
            // next column
            continue
          }
          // check y row exist & no x row
          if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
            // value @ y (check for pattern matrix)
            const vy = values ? values[ky] : undefined;
            // insert value @ x
            index.splice(kx, 0, x);
            if (values) { values.splice(kx, 0, vy); }
            // remove value @ y (adjust array index if needed)
            index.splice(kx <= ky ? ky + 1 : ky, 1);
            if (values) { values.splice(kx <= ky ? ky + 1 : ky, 1); }
          }
        }
      };

      return SparseMatrix
    }, { isClass: true });

    const name$7 = 'matrix';
    const dependencies$8 = [ 'typed', 'Matrix', 'DenseMatrix', 'SparseMatrix' ];

    const createMatrix = /* #__PURE__ */ factory(name$7, dependencies$8, ({ typed, Matrix, DenseMatrix, SparseMatrix }) => {
      /**
       * Create a Matrix. The function creates a new `math.Matrix` object from
       * an `Array`. A Matrix has utility functions to manipulate the data in the
       * matrix, like getting the size and getting or setting values in the matrix.
       * Supported storage formats are 'dense' and 'sparse'.
       *
       * Syntax:
       *
       *    math.matrix()                         // creates an empty matrix using default storage format (dense).
       *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
       *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
       *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
       *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
       *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
       *
       * Examples:
       *
       *    let m = math.matrix([[1, 2], [3, 4]])
       *    m.size()                        // Array [2, 2]
       *    m.resize([3, 2], 5)
       *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
       *    m.get([1, 0])                    // number 3
       *
       * See also:
       *
       *    bignumber, boolean, complex, index, number, string, unit, sparse
       *
       * @param {Array | Matrix} [data]    A multi dimensional array
       * @param {string} [format]          The Matrix storage format
       *
       * @return {Matrix} The created matrix
       */
      return typed(name$7, {
        '': function () {
          return _create([])
        },

        'string': function (format) {
          return _create([], format)
        },

        'string, string': function (format, datatype) {
          return _create([], format, datatype)
        },

        'Array': function (data) {
          return _create(data)
        },

        'Matrix': function (data) {
          return _create(data, data.storage())
        },

        'Array | Matrix, string': _create,

        'Array | Matrix, string, string': _create
      })

      /**
       * Create a new Matrix with given storage format
       * @param {Array} data
       * @param {string} [format]
       * @param {string} [datatype]
       * @returns {Matrix} Returns a new Matrix
       * @private
       */
      function _create (data, format, datatype) {
        // get storage format constructor
        if (format === 'dense' || format === 'default' || format === undefined) {
          return new DenseMatrix(data, datatype)
        }

        if (format === 'sparse') {
          return new SparseMatrix(data, datatype)
        }

        throw new TypeError('Unknown matrix type ' + JSON.stringify(format) + '.')
      }
    });

    const name$8 = 'algorithm13';
    const dependencies$9 = ['typed'];

    const createAlgorithm13 = /* #__PURE__ */ factory(name$8, dependencies$9, ({ typed }) => {
      /**
       * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z).
       * Callback function invoked MxN times.
       *
       * C(i,j,...z) = f(Aij..z, Bij..z)
       *
       * @param {Matrix}   a                 The DenseMatrix instance (A)
       * @param {Matrix}   b                 The DenseMatrix instance (B)
       * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
       */
      return function algorithm13 (a, b, callback) {
        // a arrays
        const adata = a._data;
        const asize = a._size;
        const adt = a._datatype;
        // b arrays
        const bdata = b._data;
        const bsize = b._size;
        const bdt = b._datatype;
        // c arrays
        const csize = [];

        // validate dimensions
        if (asize.length !== bsize.length) { throw new DimensionError(asize.length, bsize.length) }

        // validate each one of the dimension sizes
        for (let s = 0; s < asize.length; s++) {
          // must match
          if (asize[s] !== bsize[s]) { throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')') }
          // update dimension in c
          csize[s] = asize[s];
        }

        // datatype
        let dt;
        // callback signature to use
        let cf = callback;

        // process data types
        if (typeof adt === 'string' && adt === bdt) {
          // datatype
          dt = adt;
          // callback
          cf = typed.find(callback, [dt, dt]);
        }

        // populate cdata, iterate through dimensions
        const cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];

        // c matrix
        return a.createDenseMatrix({
          data: cdata,
          size: csize,
          datatype: dt
        })
      }

      // recursive function
      function _iterate (f, level, s, n, av, bv) {
        // initialize array for this level
        const cv = [];
        // check we reach the last level
        if (level === s.length - 1) {
          // loop arrays in last level
          for (let i = 0; i < n; i++) {
            // invoke callback and store value
            cv[i] = f(av[i], bv[i]);
          }
        } else {
          // iterate current level
          for (let j = 0; j < n; j++) {
            // iterate next level
            cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
          }
        }
        return cv
      }
    });

    const name$9 = 'algorithm14';
    const dependencies$a = ['typed'];

    const createAlgorithm14 = /* #__PURE__ */ factory(name$9, dependencies$a, ({ typed }) => {
      /**
       * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b).
       * Callback function invoked MxN times.
       *
       * C(i,j,...z) = f(Aij..z, b)
       *
       * @param {Matrix}   a                 The DenseMatrix instance (A)
       * @param {Scalar}   b                 The Scalar value
       * @param {Function} callback          The f(Aij..z,b) operation to invoke
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
       */
      return function algorithm14 (a, b, callback, inverse) {
        // a arrays
        const adata = a._data;
        const asize = a._size;
        const adt = a._datatype;

        // datatype
        let dt;
        // callback signature to use
        let cf = callback;

        // process data types
        if (typeof adt === 'string') {
          // datatype
          dt = adt;
          // convert b to the same datatype
          b = typed.convert(b, dt);
          // callback
          cf = typed.find(callback, [dt, dt]);
        }

        // populate cdata, iterate through dimensions
        const cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];

        // c matrix
        return a.createDenseMatrix({
          data: cdata,
          size: clone(asize),
          datatype: dt
        })
      }

      // recursive function
      function _iterate (f, level, s, n, av, bv, inverse) {
        // initialize array for this level
        const cv = [];
        // check we reach the last level
        if (level === s.length - 1) {
          // loop arrays in last level
          for (let i = 0; i < n; i++) {
            // invoke callback and store value
            cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
          }
        } else {
          // iterate current level
          for (let j = 0; j < n; j++) {
            // iterate next level
            cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
          }
        }
        return cv
      }
    });

    const name$a = 'algorithm03';
    const dependencies$b = ['typed'];

    const createAlgorithm03 = /* #__PURE__ */ factory(name$a, dependencies$b, ({ typed }) => {
      /**
       * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
       * Callback function invoked M*N times.
       *
       *
       *            f(Dij, Sij)  ; S(i,j) !== 0
       * C(i,j) = 
       *            f(Dij, 0)    ; otherwise
       *
       *
       * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
       * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
       * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
       */
      return function algorithm03 (denseMatrix, sparseMatrix, callback, inverse) {
        // dense matrix arrays
        const adata = denseMatrix._data;
        const asize = denseMatrix._size;
        const adt = denseMatrix._datatype;
        // sparse matrix arrays
        const bvalues = sparseMatrix._values;
        const bindex = sparseMatrix._index;
        const bptr = sparseMatrix._ptr;
        const bsize = sparseMatrix._size;
        const bdt = sparseMatrix._datatype;

        // validate dimensions
        if (asize.length !== bsize.length) { throw new DimensionError(asize.length, bsize.length) }

        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) { throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')') }

        // sparse matrix cannot be a Pattern matrix
        if (!bvalues) { throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix') }

        // rows & columns
        const rows = asize[0];
        const columns = asize[1];

        // datatype
        let dt;
        // zero value
        let zero = 0;
        // callback signature to use
        let cf = callback;

        // process data types
        if (typeof adt === 'string' && adt === bdt) {
          // datatype
          dt = adt;
          // convert 0 to the same datatype
          zero = typed.convert(0, dt);
          // callback
          cf = typed.find(callback, [dt, dt]);
        }

        // result (DenseMatrix)
        const cdata = [];

        // initialize dense matrix
        for (let z = 0; z < rows; z++) {
          // initialize row
          cdata[z] = [];
        }

        // workspace
        const x = [];
        // marks indicating we have a value in x for a given column
        const w = [];

        // loop columns in b
        for (let j = 0; j < columns; j++) {
          // column mark
          const mark = j + 1;
          // values in column j
          for (let k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            // row
            const i = bindex[k];
            // update workspace
            x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
            w[i] = mark;
          }
          // process workspace
          for (let y = 0; y < rows; y++) {
            // check we have a calculated value for current row
            if (w[y] === mark) {
              // use calculated value
              cdata[y][j] = x[y];
            } else {
              // calculate value
              cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
            }
          }
        }

        // return dense matrix
        return denseMatrix.createDenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        })
      }
    });

    const name$b = 'algorithm12';
    const dependencies$c = ['typed', 'DenseMatrix'];

    const createAlgorithm12 = /* #__PURE__ */ factory(name$b, dependencies$c, ({ typed, DenseMatrix }) => {
      /**
       * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
       * Callback function invoked MxN times.
       *
       *
       *            f(Sij, b)  ; S(i,j) !== 0
       * C(i,j) = 
       *            f(0, b)    ; otherwise
       *
       *
       * @param {Matrix}   s                 The SparseMatrix instance (S)
       * @param {Scalar}   b                 The Scalar value
       * @param {Function} callback          The f(Aij,b) operation to invoke
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
       */
      return function algorithm12 (s, b, callback, inverse) {
        // sparse matrix arrays
        const avalues = s._values;
        const aindex = s._index;
        const aptr = s._ptr;
        const asize = s._size;
        const adt = s._datatype;

        // sparse matrix cannot be a Pattern matrix
        if (!avalues) { throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value') }

        // rows & columns
        const rows = asize[0];
        const columns = asize[1];

        // datatype
        let dt;
        // callback signature to use
        let cf = callback;

        // process data types
        if (typeof adt === 'string') {
          // datatype
          dt = adt;
          // convert b to the same datatype
          b = typed.convert(b, dt);
          // callback
          cf = typed.find(callback, [dt, dt]);
        }

        // result arrays
        const cdata = [];
        // matrix
        const c = new DenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });

        // workspaces
        const x = [];
        // marks indicating we have a value in x for a given column
        const w = [];

        // loop columns
        for (let j = 0; j < columns; j++) {
          // columns mark
          const mark = j + 1;
          // values in j
          for (let k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            // row
            const r = aindex[k];
            // update workspace
            x[r] = avalues[k];
            w[r] = mark;
          }
          // loop rows
          for (let i = 0; i < rows; i++) {
            // initialize C on first column
            if (j === 0) {
              // create row array
              cdata[i] = [];
            }
            // check sparse matrix has a value @ i,j
            if (w[i] === mark) {
              // invoke callback, update C
              cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
            } else {
              // dense matrix value @ i, j
              cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
            }
          }
        }

        // return sparse matrix
        return c
      }
    });

    const name$c = 'algorithm07';
    const dependencies$d = ['typed', 'DenseMatrix'];

    const createAlgorithm07 = /* #__PURE__ */ factory(name$c, dependencies$d, ({ typed, DenseMatrix }) => {
      /**
       * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij).
       * Callback function invoked MxN times.
       *
       * C(i,j) = f(Aij, Bij)
       *
       * @param {Matrix}   a                 The SparseMatrix instance (A)
       * @param {Matrix}   b                 The SparseMatrix instance (B)
       * @param {Function} callback          The f(Aij,Bij) operation to invoke
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
       */
      return function algorithm07 (a, b, callback) {
        // sparse matrix arrays
        const asize = a._size;
        const adt = a._datatype;
        // sparse matrix arrays
        const bsize = b._size;
        const bdt = b._datatype;

        // validate dimensions
        if (asize.length !== bsize.length) { throw new DimensionError(asize.length, bsize.length) }

        // check rows & columns
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) { throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')') }

        // rows & columns
        const rows = asize[0];
        const columns = asize[1];

        // datatype
        let dt;
        // zero value
        let zero = 0;
        // callback signature to use
        let cf = callback;

        // process data types
        if (typeof adt === 'string' && adt === bdt) {
          // datatype
          dt = adt;
          // convert 0 to the same datatype
          zero = typed.convert(0, dt);
          // callback
          cf = typed.find(callback, [dt, dt]);
        }

        // vars
        let i, j;

        // result arrays
        const cdata = [];
        // initialize c
        for (i = 0; i < rows; i++) { cdata[i] = []; }

        // matrix
        const c = new DenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });

        // workspaces
        const xa = [];
        const xb = [];
        // marks indicating we have a value in x for a given column
        const wa = [];
        const wb = [];

        // loop columns
        for (j = 0; j < columns; j++) {
          // columns mark
          const mark = j + 1;
          // scatter the values of A(:,j) into workspace
          _scatter(a, j, wa, xa, mark);
          // scatter the values of B(:,j) into workspace
          _scatter(b, j, wb, xb, mark);
          // loop rows
          for (i = 0; i < rows; i++) {
            // matrix values @ i,j
            const va = wa[i] === mark ? xa[i] : zero;
            const vb = wb[i] === mark ? xb[i] : zero;
            // invoke callback
            cdata[i][j] = cf(va, vb);
          }
        }

        // return sparse matrix
        return c
      }

      function _scatter (m, j, w, x, mark) {
        // a arrays
        const values = m._values;
        const index = m._index;
        const ptr = m._ptr;
        // loop values in column j
        for (let k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
          // row
          const i = index[k];
          // update workspace
          w[i] = mark;
          x[i] = values[k];
        }
      }
    });

    const name$d = 'equal';
    const dependencies$e = [
      'typed',
      'matrix',
      'equalScalar',
      'DenseMatrix'
    ];

    const createEqual = /* #__PURE__ */ factory(name$d, dependencies$e, ({ typed, matrix, equalScalar, DenseMatrix }) => {
      const algorithm03 = createAlgorithm03({ typed });
      const algorithm07 = createAlgorithm07({ typed, DenseMatrix });
      const algorithm12 = createAlgorithm12({ typed, DenseMatrix });
      const algorithm13 = createAlgorithm13({ typed });
      const algorithm14 = createAlgorithm14({ typed });

      /**
       * Test whether two values are equal.
       *
       * The function tests whether the relative difference between x and y is
       * smaller than the configured epsilon. The function cannot be used to
       * compare values smaller than approximately 2.22e-16.
       *
       * For matrices, the function is evaluated element wise.
       * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
       *
       * Values `null` and `undefined` are compared strictly, thus `null` is only
       * equal to `null` and nothing else, and `undefined` is only equal to
       * `undefined` and nothing else. Strings are compared by their numerical value.
       *
       * Syntax:
       *
       *    math.equal(x, y)
       *
       * Examples:
       *
       *    math.equal(2 + 2, 3)         // returns false
       *    math.equal(2 + 2, 4)         // returns true
       *
       *    const a = math.unit('50 cm')
       *    const b = math.unit('5 m')
       *    math.equal(a, b)             // returns true
       *
       *    const c = [2, 5, 1]
       *    const d = [2, 7, 1]
       *
       *    math.equal(c, d)             // returns [true, false, true]
       *    math.deepEqual(c, d)         // returns false
       *
       *    math.equal("1000", "1e3")    // returns true
       *    math.equal(0, null)          // returns false
       *
       * See also:
       *
       *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual, equalText
       *
       * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
       * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
       * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
       */
      const equal = typed(name$d, {

        'any, any': function (x, y) {
          // strict equality for null and undefined?
          if (x === null) { return y === null }
          if (y === null) { return x === null }
          if (x === undefined) { return y === undefined }
          if (y === undefined) { return x === undefined }

          return equalScalar(x, y)
        },

        'SparseMatrix, SparseMatrix': function (x, y) {
          return algorithm07(x, y, equalScalar)
        },

        'SparseMatrix, DenseMatrix': function (x, y) {
          return algorithm03(y, x, equalScalar, true)
        },

        'DenseMatrix, SparseMatrix': function (x, y) {
          return algorithm03(x, y, equalScalar, false)
        },

        'DenseMatrix, DenseMatrix': function (x, y) {
          return algorithm13(x, y, equalScalar)
        },

        'Array, Array': function (x, y) {
          // use matrix implementation
          return equal(matrix(x), matrix(y)).valueOf()
        },

        'Array, Matrix': function (x, y) {
          // use matrix implementation
          return equal(matrix(x), y)
        },

        'Matrix, Array': function (x, y) {
          // use matrix implementation
          return equal(x, matrix(y))
        },

        'SparseMatrix, any': function (x, y) {
          return algorithm12(x, y, equalScalar, false)
        },

        'DenseMatrix, any': function (x, y) {
          return algorithm14(x, y, equalScalar, false)
        },

        'any, SparseMatrix': function (x, y) {
          return algorithm12(y, x, equalScalar, true)
        },

        'any, DenseMatrix': function (x, y) {
          return algorithm14(y, x, equalScalar, true)
        },

        'Array, any': function (x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, equalScalar, false).valueOf()
        },

        'any, Array': function (x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, equalScalar, true).valueOf()
        }
      });

      return equal
    });

    const createEqualNumber = factory(name$d, ['typed', 'equalScalar'], ({ typed, equalScalar }) => {
      return typed(name$d, {
        'any, any': function (x, y) {
          // strict equality for null and undefined?
          if (x === null) { return y === null }
          if (y === null) { return x === null }
          if (x === undefined) { return y === undefined }
          if (y === undefined) { return x === undefined }

          return equalScalar(x, y)
        }
      })
    });

    const name$e = 'deepEqual';
    const dependencies$f = [
      'typed',
      'equal'
    ];

    const createDeepEqual = /* #__PURE__ */ factory(name$e, dependencies$f, ({ typed, equal }) => {
      /**
       * Test element wise whether two matrices are equal.
       * The function accepts both matrices and scalar values.
       *
       * Strings are compared by their numerical value.
       *
       * Syntax:
       *
       *    math.deepEqual(x, y)
       *
       * Examples:
       *
       *    math.deepEqual(2, 4)   // returns false
       *
       *    a = [2, 5, 1]
       *    b = [2, 7, 1]
       *
       *    math.deepEqual(a, b)   // returns false
       *    math.equal(a, b)       // returns [true, false, true]
       *
       * See also:
       *
       *    equal, unequal
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
       * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
       *            Returns true when the input matrices have the same size and each of their elements is equal.
       */
      return typed(name$e, {
        'any, any': function (x, y) {
          return _deepEqual(x.valueOf(), y.valueOf())
        }
      })

      /**
       * Test whether two arrays have the same size and all elements are equal
       * @param {Array | *} x
       * @param {Array | *} y
       * @return {boolean} Returns true if both arrays are deep equal
       */
      function _deepEqual (x, y) {
        if (Array.isArray(x)) {
          if (Array.isArray(y)) {
            const len = x.length;
            if (len !== y.length) {
              return false
            }

            for (let i = 0; i < len; i++) {
              if (!_deepEqual(x[i], y[i])) {
                return false
              }
            }

            return true
          } else {
            return false
          }
        } else {
          if (Array.isArray(y)) {
            return false
          } else {
            return equal(x, y)
          }
        }
      }
    });

    /**
     * THIS FILE IS AUTO-GENERATED
     * DON'T MAKE CHANGES HERE
     */
    const Complex$1 = /* #__PURE__ */ createComplexClass({});
    const BigNumber = /* #__PURE__ */ createBigNumberClass({ config });
    const Matrix = /* #__PURE__ */ createMatrixClass({});
    const Fraction$1 = /* #__PURE__ */ createFractionClass({});
    const DenseMatrix = /* #__PURE__ */ createDenseMatrixClass({ Matrix });
    const typed = /* #__PURE__ */ createTyped({ BigNumber, Complex: Complex$1, DenseMatrix, Fraction: Fraction$1 });
    const equalScalar = /* #__PURE__ */ createEqualScalar({ config, typed });
    const SparseMatrix = /* #__PURE__ */ createSparseMatrixClass({ Matrix, equalScalar, typed });
    const matrix = /* #__PURE__ */ createMatrix({ DenseMatrix, Matrix, SparseMatrix, typed });
    const equal$1 = /* #__PURE__ */ createEqual({ DenseMatrix, equalScalar, matrix, typed });
    const deepEqual = /* #__PURE__ */ createDeepEqual({ equal: equal$1, typed });

    var generateTotals = function (colors, solution) {
        var layerTotals = [];
        for (var i = 0; i < colors.length; i += 1) {
            var row = [];
            for (var rowIndex = 0; rowIndex < solution.length; rowIndex += 1) {
                var total = [];
                var inGroup = 0;
                for (var colIndex = 0; colIndex < solution[rowIndex].length; colIndex += 1) {
                    var current = solution[rowIndex][colIndex];
                    if (!!inGroup) {
                        if (current === i) {
                            inGroup += 1;
                        }
                        else {
                            if (inGroup) {
                                total.push(inGroup);
                                inGroup = 0;
                            }
                        }
                    }
                    else {
                        if (current === i) {
                            inGroup += 1;
                        }
                    }
                    if (colIndex === solution[rowIndex].length - 1
                        && current
                        && inGroup) {
                        total.push(inGroup);
                    }
                }
                row.push(total);
            }
            var col = [];
            for (var colIndex = 0; colIndex < solution[0].length; colIndex += 1) {
                var total = [];
                var inGroup = 0;
                for (var rowIndex = 0; rowIndex < solution.length; rowIndex += 1) {
                    var current = solution[rowIndex][colIndex];
                    if (inGroup) {
                        if (current === i) {
                            inGroup += 1;
                        }
                        else {
                            if (inGroup) {
                                total.push(inGroup);
                                inGroup = 0;
                            }
                        }
                    }
                    else {
                        if (current === i) {
                            inGroup += 1;
                        }
                    }
                    if (rowIndex === solution.length - 1
                        && current
                        && inGroup) {
                        total.push(inGroup);
                    }
                }
                col.push(total);
            }
            layerTotals.push([row, col]);
        }
        return layerTotals;
    };
    //# sourceMappingURL=utils.js.map

    const client = new DefaultClient({
      uri: 'http://localhost:4040/graphql'
    });

    const Levels = src`
  query {
    levels {
      title
      colors
      solution
    }
  }
`;

    const AddLevel = src`
  mutation addLevel($level: LevelInput!) {
    addLevel(level: $level) {
      title
      colors
      solution
    }
  }
`;

    var tinycolor = createCommonjsModule(function (module) {
    // TinyColor v1.4.1
    // https://github.com/bgrins/TinyColor
    // Brian Grinstead, MIT License

    (function(Math) {

    var trimLeft = /^\s+/,
        trimRight = /\s+$/,
        tinyCounter = 0,
        mathRound = Math.round,
        mathMin = Math.min,
        mathMax = Math.max,
        mathRandom = Math.random;

    function tinycolor (color, opts) {

        color = (color) ? color : '';
        opts = opts || { };

        // If input is already a tinycolor, return itself
        if (color instanceof tinycolor) {
           return color;
        }
        // If we are called as a function, call using new instead
        if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
        }

        var rgb = inputToRGB(color);
        this._originalInput = color,
        this._r = rgb.r,
        this._g = rgb.g,
        this._b = rgb.b,
        this._a = rgb.a,
        this._roundA = mathRound(100*this._a) / 100,
        this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;

        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this._r < 1) { this._r = mathRound(this._r); }
        if (this._g < 1) { this._g = mathRound(this._g); }
        if (this._b < 1) { this._b = mathRound(this._b); }

        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
    }

    tinycolor.prototype = {
        isDark: function() {
            return this.getBrightness() < 128;
        },
        isLight: function() {
            return !this.isDark();
        },
        isValid: function() {
            return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
            return this._format;
        },
        getAlpha: function() {
            return this._a;
        },
        getBrightness: function() {
            //http://www.w3.org/TR/AERT#color-contrast
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },
        getLuminance: function() {
            //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r/255;
            GsRGB = rgb.g/255;
            BsRGB = rgb.b/255;

            if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
            if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
            if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
            return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
        },
        setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100*this._a) / 100;
            return this;
        },
        toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return (this._a == 1) ?
              "hsv("  + h + ", " + s + "%, " + v + "%)" :
              "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
        },
        toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return (this._a == 1) ?
              "hsl("  + h + ", " + s + "%, " + l + "%)" :
              "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
        },
        toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
            return '#' + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
            return '#' + this.toHex8(allow4Char);
        },
        toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
              "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
              "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
            if (this._a === 0) {
                return "transparent";
            }

            if (this._a < 1) {
                return false;
            }

            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
            var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";

            if (secondColor) {
                var s = tinycolor(secondColor);
                secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }

            return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
        },
        toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;

            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === "name" && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === "rgb") {
                formattedString = this.toRgbString();
            }
            if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
            }
            if (format === "hex3") {
                formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
                formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
                formattedString = this.toHex8String();
            }
            if (format === "name") {
                formattedString = this.toName();
            }
            if (format === "hsl") {
                formattedString = this.toHslString();
            }
            if (format === "hsv") {
                formattedString = this.toHsvString();
            }

            return formattedString || this.toHexString();
        },
        clone: function() {
            return tinycolor(this.toString());
        },

        _applyModification: function(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
        },
        lighten: function() {
            return this._applyModification(lighten, arguments);
        },
        brighten: function() {
            return this._applyModification(brighten, arguments);
        },
        darken: function() {
            return this._applyModification(darken, arguments);
        },
        desaturate: function() {
            return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
            return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
            return this._applyModification(greyscale, arguments);
        },
        spin: function() {
            return this._applyModification(spin, arguments);
        },

        _applyCombination: function(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
            return this._applyCombination(analogous, arguments);
        },
        complement: function() {
            return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
            return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
            return this._applyCombination(tetrad, arguments);
        }
    };

    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function(color, opts) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === "a") {
                        newColor[i] = color[i];
                    }
                    else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }

        return tinycolor(color, opts);
    };

    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {

        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;

        if (typeof color == "string") {
            color = stringInputToObject(color);
        }

        if (typeof color == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            }
            else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
                s = convertToPercentage(color.s);
                v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, s, v);
                ok = true;
                format = "hsv";
            }
            else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
                s = convertToPercentage(color.s);
                l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, s, l);
                ok = true;
                format = "hsl";
            }

            if (color.hasOwnProperty("a")) {
                a = color.a;
            }
        }

        a = boundAlpha(a);

        return {
            ok: ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a: a
        };
    }


    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b){
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;

        if(max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;

        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);

        function hue2rgb(p, q, t) {
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        if(s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if(max == min) {
            h = 0; // achromatic
        }
        else {
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
     function hsvToRgb(h, s, v) {

        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = Math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        // Return a 3 character hex if possible
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b are contained in the set [0, 255] and
    // a in [0, 1]. Returns a 4 or 8 character rgba hex
    function rgbaToHex(r, g, b, a, allow4Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16)),
            pad2(convertDecimalToHex(a))
        ];

        // Return a 4 character hex if possible
        if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToArgbHex`
    // Converts an RGBA color to an ARGB Hex8 string
    // Rarely used, but required for "toFilter()"
    function rgbaToArgbHex(r, g, b, a) {

        var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        return hex.join("");
    }

    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
        if (!color1 || !color2) { return false; }
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };

    tinycolor.random = function() {
        return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
        });
    };


    // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

    function desaturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function saturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function greyscale(color) {
        return tinycolor(color).desaturate(100);
    }

    function lighten (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    function brighten(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var rgb = tinycolor(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
        return tinycolor(rgb);
    }

    function darken (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
    }

    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

    function complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
    }

    function triad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function tetrad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
        ];
    }

    function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;

        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];

        for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
        }
        return ret;
    }

    function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;

        while (results--) {
            ret.push(tinycolor({ h: h, s: s, v: v}));
            v = (v + modification) % 1;
        }

        return ret;
    }

    // Utility Functions
    // ---------------------

    tinycolor.mix = function(color1, color2, amount) {
        amount = (amount === 0) ? 0 : (amount || 50);

        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();

        var p = amount / 100;

        var rgba = {
            r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
            g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
            b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
            a: ((rgb2.a - rgb1.a) * p) + rgb1.a
        };

        return tinycolor(rgba);
    };


    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

    // `contrast`
    // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
    tinycolor.readability = function(color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
    };

    // `isReadable`
    // Ensure that foreground and background color combinations meet WCAG2 guidelines.
    // The third argument is an optional Object.
    //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
    //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
    // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

    // *Example*
    //    tinycolor.isReadable("#000", "#111") => false
    //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
    tinycolor.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor.readability(color1, color2);
        var wcag2Parms, out;

        out = false;

        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
                out = readability >= 4.5;
                break;
            case "AAlarge":
                out = readability >= 3;
                break;
            case "AAAsmall":
                out = readability >= 7;
                break;
        }
        return out;

    };

    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // Optionally returns Black or White if the most readable color is unreadable.
    // *Example*
    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
    tinycolor.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size ;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors ;
        level = args.level;
        size = args.size;

        for (var i= 0; i < colorList.length ; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
                bestScore = readability;
                bestColor = tinycolor(colorList[i]);
            }
        }

        if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
            return bestColor;
        }
        else {
            args.includeFallbackColors=false;
            return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
        }
    };


    // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };

    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = tinycolor.hexNames = flip(names);


    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = { };
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }

    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);

        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }

        return a;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) { n = "100%"; }

        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }

        // Handle floating point rounding errors
        if ((Math.abs(n - max) < 0.000001)) {
            return 1;
        }

        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }

    // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }

    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }

    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === "string" && n.indexOf('%') != -1;
    }

    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = (n * 100) + "%";
        }

        return n;
    }

    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return (parseIntFromHex(h) / 255);
    }

    var matchers = (function() {

        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = "[-\\+]?\\d+%?";

        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

        return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    })();

    // `isValidCSSUnit`
    // Take in a single string / number and check to see if it looks like a CSS unit
    // (see `matchers` above for definition).
    function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
    }

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {

        color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        }
        else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if ((match = matchers.rgb.exec(color))) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if ((match = matchers.rgba.exec(color))) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if ((match = matchers.hsl.exec(color))) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if ((match = matchers.hsla.exec(color))) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if ((match = matchers.hsv.exec(color))) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if ((match = matchers.hsva.exec(color))) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if ((match = matchers.hex8.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                a: convertHexToDecimal(match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex6.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            };
        }
        if ((match = matchers.hex4.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                a: convertHexToDecimal(match[4] + '' + match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex3.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? "name" : "hex"
            };
        }

        return false;
    }

    function validateWCAG2Parms(parms) {
        // return valid WCAG2 parms for isReadable.
        // If input parms are invalid, return {"level":"AA", "size":"small"}
        var level, size;
        parms = parms || {"level":"AA", "size":"small"};
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
            level = "AA";
        }
        if (size !== "small" && size !== "large") {
            size = "small";
        }
        return {"level":level, "size":size};
    }

    // Node: Export function
    if ( module.exports) {
        module.exports = tinycolor;
    }
    // AMD/requirejs: Define the module
    else {
        window.tinycolor = tinycolor;
    }

    })(Math);
    });

    /* src/Block.svelte generated by Svelte v3.6.7 */

    const file$7 = "src/Block.svelte";

    function create_fragment$7(ctx) {
    	var div, t0_value = ctx.hover ? 't' : 'f', t0, t1, current, dispose;

    	const default_slot_1 = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_1, ctx, null);

    	return {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();

    			if (default_slot) default_slot.c();

    			attr(div, "style", ctx._styles);
    			attr(div, "class", "svelte-1pm8ck7");
    			add_location(div, file$7, 40, 0, 943);

    			dispose = [
    				listen(div, "click", ctx.click_handler),
    				listen(div, "mouseenter", ctx.mouseenter_handler),
    				listen(div, "mouseover", ctx.mouseover_handler),
    				listen(div, "mouseleave", ctx.mouseleave_handler),
    				listen(div, "contextmenu", ctx.contextmenu_handler)
    			];
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(div_nodes);
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t0);
    			append(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.hover) && t0_value !== (t0_value = ctx.hover ? 't' : 'f')) {
    				set_data(t0, t0_value);
    			}

    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
    			}

    			if (!current || changed._styles) {
    				attr(div, "style", ctx._styles);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if (default_slot) default_slot.d(detaching);
    			run_all(dispose);
    		}
    	};
    }

    const white = '#eee';

    const black = '#111';

    const red = '#d22';

    function instance$7($$self, $$props, $$invalidate) {
    	let { row, col, state = -1, color, onClick, onMouseEnter, onMouseOver, onMouseLeave, onRightClick, transitionTime = 0.2, styles } = $$props;
      let hover = false;

    	const writable_props = ['row', 'col', 'state', 'color', 'onClick', 'onMouseEnter', 'onMouseOver', 'onMouseLeave', 'onRightClick', 'transitionTime', 'styles'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Block> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	function click_handler() {
    	    if (onClick) {
    	      onClick(row, col);
    	    }
    	  }

    	function mouseenter_handler() {
    	    hover = true; $$invalidate('hover', hover);
    	    if (onMouseEnter) {
    	      onMouseEnter(row, col);
    	    }
    	  }

    	function mouseover_handler() {
    	    if (onMouseOver) {
    	      onMouseOver(row, col);
    	    }
    	  }

    	function mouseleave_handler() {
    	    hover = false; $$invalidate('hover', hover);
    	    if (onMouseLeave) {
    	      onMouseLeave(row, col);
    	    }
    	  }

    	function contextmenu_handler(e) {
    	    if (onRightClick) {
    	      e.preventDefault();
    	      onRightClick(row, col);
    	    }
    	  }

    	$$self.$set = $$props => {
    		if ('row' in $$props) $$invalidate('row', row = $$props.row);
    		if ('col' in $$props) $$invalidate('col', col = $$props.col);
    		if ('state' in $$props) $$invalidate('state', state = $$props.state);
    		if ('color' in $$props) $$invalidate('color', color = $$props.color);
    		if ('onClick' in $$props) $$invalidate('onClick', onClick = $$props.onClick);
    		if ('onMouseEnter' in $$props) $$invalidate('onMouseEnter', onMouseEnter = $$props.onMouseEnter);
    		if ('onMouseOver' in $$props) $$invalidate('onMouseOver', onMouseOver = $$props.onMouseOver);
    		if ('onMouseLeave' in $$props) $$invalidate('onMouseLeave', onMouseLeave = $$props.onMouseLeave);
    		if ('onRightClick' in $$props) $$invalidate('onRightClick', onRightClick = $$props.onRightClick);
    		if ('transitionTime' in $$props) $$invalidate('transitionTime', transitionTime = $$props.transitionTime);
    		if ('styles' in $$props) $$invalidate('styles', styles = $$props.styles);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	let bg, textColor, _styles;

    	$$self.$$.update = ($$dirty = { state: 1, color: 1, bg: 1, textColor: 1, transitionTime: 1, styles: 1 }) => {
    		if ($$dirty.state || $$dirty.color) { $$invalidate('bg', bg = state === -2 ? red : (state === -1 ? white : color)); }
    		if ($$dirty.bg) { $$invalidate('textColor', textColor = tinycolor(bg).isLight() ? black : white); }
    		if ($$dirty.bg || $$dirty.textColor || $$dirty.transitionTime || $$dirty.styles) { $$invalidate('_styles', _styles = `background: ${bg}; color: ${textColor}; transition: all ${transitionTime}s ease-in-out;${!!styles ? styles : ''}`); }
    	};

    	return {
    		row,
    		col,
    		state,
    		color,
    		onClick,
    		onMouseEnter,
    		onMouseOver,
    		onMouseLeave,
    		onRightClick,
    		transitionTime,
    		styles,
    		hover,
    		_styles,
    		click_handler,
    		mouseenter_handler,
    		mouseover_handler,
    		mouseleave_handler,
    		contextmenu_handler,
    		$$slots,
    		$$scope
    	};
    }

    class Block extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, ["row", "col", "state", "color", "onClick", "onMouseEnter", "onMouseOver", "onMouseLeave", "onRightClick", "transitionTime", "styles"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.row === undefined && !('row' in props)) {
    			console.warn("<Block> was created without expected prop 'row'");
    		}
    		if (ctx.col === undefined && !('col' in props)) {
    			console.warn("<Block> was created without expected prop 'col'");
    		}
    		if (ctx.color === undefined && !('color' in props)) {
    			console.warn("<Block> was created without expected prop 'color'");
    		}
    		if (ctx.onClick === undefined && !('onClick' in props)) {
    			console.warn("<Block> was created without expected prop 'onClick'");
    		}
    		if (ctx.onMouseEnter === undefined && !('onMouseEnter' in props)) {
    			console.warn("<Block> was created without expected prop 'onMouseEnter'");
    		}
    		if (ctx.onMouseOver === undefined && !('onMouseOver' in props)) {
    			console.warn("<Block> was created without expected prop 'onMouseOver'");
    		}
    		if (ctx.onMouseLeave === undefined && !('onMouseLeave' in props)) {
    			console.warn("<Block> was created without expected prop 'onMouseLeave'");
    		}
    		if (ctx.onRightClick === undefined && !('onRightClick' in props)) {
    			console.warn("<Block> was created without expected prop 'onRightClick'");
    		}
    		if (ctx.styles === undefined && !('styles' in props)) {
    			console.warn("<Block> was created without expected prop 'styles'");
    		}
    	}

    	get row() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get col() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set col(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseEnter() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseEnter(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseOver() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseOver(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onMouseLeave() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onMouseLeave(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onRightClick() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onRightClick(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionTime() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionTime(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styles() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styles(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Griddler.svelte generated by Svelte v3.6.7 */

    const file$8 = "src/Griddler.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.total = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.total = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.item = list[i];
    	child_ctx.colIndex = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	child_ctx.rowIndex = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.total = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.total = list[i];
    	return child_ctx;
    }

    function get_each_context_6(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.color = list[i];
    	child_ctx.index = i;
    	return child_ctx;
    }

    function get_each_context_7(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.level = list[i];
    	child_ctx.index = i;
    	return child_ctx;
    }

    // (117:2) {#if levels && !!levels.length}
    function create_if_block_6(ctx) {
    	var div;

    	var each_value_7 = ctx.levels;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_7.length; i += 1) {
    		each_blocks[i] = create_each_block_7(get_each_context_7(ctx, each_value_7, i));
    	}

    	return {
    		c: function create() {
    			div = element("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(div, "class", "flex-row justify-center svelte-w9h21n");
    			set_style(div, "margin-bottom", "1rem");
    			add_location(div, file$8, 117, 4, 2504);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.levels) {
    				each_value_7 = ctx.levels;

    				for (var i = 0; i < each_value_7.length; i += 1) {
    					const child_ctx = get_each_context_7(ctx, each_value_7, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_7.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (119:6) {#each levels as level, index}
    function create_each_block_7(ctx) {
    	var div, t0, t1, dispose;

    	function click_handler() {
    		return ctx.click_handler(ctx);
    	}

    	return {
    		c: function create() {
    			div = element("div");
    			t0 = text(ctx.index);
    			t1 = space();
    			set_style(div, "margin-right", "0.5rem");
    			set_style(div, "display", "inline-block");
    			set_style(div, "padding", "0.5rem");
    			set_style(div, "background", "#fff");
    			set_style(div, "border-radius", "4px");
    			set_style(div, "cursor", "pointer");
    			add_location(div, file$8, 119, 8, 2615);
    			dispose = listen(div, "click", click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t0);
    			append(div, t1);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			dispose();
    		}
    	};
    }

    // (129:2) {#if colors && !!colors.length}
    function create_if_block_5(ctx) {
    	var div, current;

    	var each_value_6 = ctx.colors;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_6.length; i += 1) {
    		each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c: function create() {
    			div = element("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(div, "class", "flex-row justify-center margin-bottom svelte-w9h21n");
    			add_location(div, file$8, 129, 4, 2917);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (changed.colors || changed.setLayerIndex) {
    				each_value_6 = ctx.colors;

    				for (var i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6(ctx, each_value_6, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();
    				for (i = each_value_6.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value_6.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (132:8) <Block           state={1}           color={color}           onClick={() => { setLayerIndex(index); }}           styles="border-radius: 4px; margin: 0 4px;"         >
    function create_default_slot_4(ctx) {
    	var t0_value = ctx.color, t0, t1;

    	return {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colors) && t0_value !== (t0_value = ctx.color)) {
    				set_data(t0, t0_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(t1);
    			}
    		}
    	};
    }

    // (131:6) {#each colors as color, index}
    function create_each_block_6(ctx) {
    	var current;

    	function func() {
    		return ctx.func(ctx);
    	}

    	var block = new Block({
    		props: {
    		state: 1,
    		color: ctx.color,
    		onClick: func,
    		styles: "border-radius: 4px; margin: 0 4px;",
    		$$slots: { default: [create_default_slot_4] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			block.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(block, target, anchor);
    			current = true;
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			var block_changes = {};
    			if (changed.colors) block_changes.color = ctx.color;
    			if (changed.setLayerIndex) block_changes.onClick = func;
    			if (changed.$$scope || changed.colors) block_changes.$$scope = { changed, ctx };
    			block.$set(block_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(block.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(block.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(block, detaching);
    		}
    	};
    }

    // (144:4) {#if colTotals && !!colTotals.length}
    function create_if_block_4(ctx) {
    	var t0, t1, current;

    	var block0 = new Block({
    		props: {
    		color: ctx.color,
    		state: 1,
    		styles: "border-top-left-radius: 24px;"
    	},
    		$$inline: true
    	});

    	var each_value_5 = ctx.colTotals;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	var block1 = new Block({
    		props: {
    		color: ctx.color,
    		state: 1,
    		styles: "border-top-right-radius: 24px;"
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			block0.$$.fragment.c();
    			t0 = space();

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			block1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(block0, target, anchor);
    			insert(target, t0, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, t1, anchor);
    			mount_component(block1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var block0_changes = {};
    			if (changed.color) block0_changes.color = ctx.color;
    			block0.$set(block0_changes);

    			if (changed.color || changed.colTotals) {
    				each_value_5 = ctx.colTotals;

    				for (var i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t1.parentNode, t1);
    					}
    				}

    				group_outros();
    				for (i = each_value_5.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}

    			var block1_changes = {};
    			if (changed.color) block1_changes.color = ctx.color;
    			block1.$set(block1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(block0.$$.fragment, local);

    			for (var i = 0; i < each_value_5.length; i += 1) transition_in(each_blocks[i]);

    			transition_in(block1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(block0.$$.fragment, local);

    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			transition_out(block1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(block0, detaching);

    			if (detaching) {
    				detach(t0);
    			}

    			destroy_each(each_blocks, detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			destroy_component(block1, detaching);
    		}
    	};
    }

    // (151:8) <Block           color={color}           state={1}         >
    function create_default_slot_3(ctx) {
    	var t_value = ctx.total, t;

    	return {
    		c: function create() {
    			t = text(t_value);
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colTotals) && t_value !== (t_value = ctx.total)) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (150:6) {#each colTotals as total}
    function create_each_block_5(ctx) {
    	var current;

    	var block = new Block({
    		props: {
    		color: ctx.color,
    		state: 1,
    		$$slots: { default: [create_default_slot_3] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			block.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(block, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var block_changes = {};
    			if (changed.color) block_changes.color = ctx.color;
    			if (changed.$$scope || changed.colTotals) block_changes.$$scope = { changed, ctx };
    			block.$set(block_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(block.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(block.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(block, detaching);
    		}
    	};
    }

    // (166:4) {#if rowTotals && !!rowTotals.length}
    function create_if_block_3(ctx) {
    	var div, current;

    	var each_value_4 = ctx.rowTotals;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c: function create() {
    			div = element("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(div, "class", "flex-col svelte-w9h21n");
    			add_location(div, file$8, 166, 6, 3808);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (changed.color || changed.rowTotals) {
    				each_value_4 = ctx.rowTotals;

    				for (var i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();
    				for (i = each_value_4.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value_4.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (169:10) <Block             color={color}             state={1}           >
    function create_default_slot_2(ctx) {
    	var t0_value = ctx.total, t0, t1;

    	return {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.rowTotals) && t0_value !== (t0_value = ctx.total)) {
    				set_data(t0, t0_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(t1);
    			}
    		}
    	};
    }

    // (168:8) {#each rowTotals as total}
    function create_each_block_4(ctx) {
    	var current;

    	var block = new Block({
    		props: {
    		color: ctx.color,
    		state: 1,
    		$$slots: { default: [create_default_slot_2] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			block.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(block, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var block_changes = {};
    			if (changed.color) block_changes.color = ctx.color;
    			if (changed.$$scope || changed.rowTotals) block_changes.$$scope = { changed, ctx };
    			block.$set(block_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(block.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(block.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(block, detaching);
    		}
    	};
    }

    // (178:4) {#if board}
    function create_if_block_2(ctx) {
    	var div, section, current;

    	var each_value_2 = ctx.board;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			section = element("section");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(section, "class", "board svelte-w9h21n");
    			set_style(section, "grid-template-columns", "repeat(" + ctx.board[0].length + ", 1fr)");
    			set_style(section, "grid-template-rows", "repeat(" + ctx.board.length + ", 1fr)");
    			add_location(section, file$8, 179, 8, 4074);
    			attr(div, "class", "flex-row svelte-w9h21n");
    			add_location(div, file$8, 178, 6, 4043);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, section);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(section, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (changed.board || changed.toggleEnabled || changed.toggleDisabled || changed.colors) {
    				each_value_2 = ctx.board;

    				for (var i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(section, null);
    					}
    				}

    				group_outros();
    				for (i = each_value_2.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}

    			if (!current || changed.board) {
    				set_style(section, "grid-template-columns", "repeat(" + ctx.board[0].length + ", 1fr)");
    				set_style(section, "grid-template-rows", "repeat(" + ctx.board.length + ", 1fr)");
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value_2.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (185:12) {#each row as item, colIndex}
    function create_each_block_3(ctx) {
    	var current;

    	var block = new Block({
    		props: {
    		state: ctx.item,
    		row: ctx.rowIndex,
    		col: ctx.colIndex,
    		onClick: ctx.toggleEnabled,
    		onRightClick: ctx.toggleDisabled,
    		color: ctx.colors[ctx.item]
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			block.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(block, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var block_changes = {};
    			if (changed.board) block_changes.state = ctx.item;
    			if (changed.toggleEnabled) block_changes.onClick = ctx.toggleEnabled;
    			if (changed.toggleDisabled) block_changes.onRightClick = ctx.toggleDisabled;
    			if (changed.colors || changed.board) block_changes.color = ctx.colors[ctx.item];
    			block.$set(block_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(block.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(block.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(block, detaching);
    		}
    	};
    }

    // (184:10) {#each board as row, rowIndex}
    function create_each_block_2(ctx) {
    	var each_1_anchor, current;

    	var each_value_3 = ctx.row;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (changed.board || changed.toggleEnabled || changed.toggleDisabled || changed.colors) {
    				each_value_3 = ctx.row;

    				for (var i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();
    				for (i = each_value_3.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value_3.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (199:4) {#if rowTotals && !!rowTotals.length}
    function create_if_block_1(ctx) {
    	var div, current;

    	var each_value_1 = ctx.rowTotals;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c: function create() {
    			div = element("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(div, "class", "flex-col svelte-w9h21n");
    			add_location(div, file$8, 199, 6, 4702);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (changed.color || changed.rowTotals) {
    				each_value_1 = ctx.rowTotals;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();
    				for (i = each_value_1.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value_1.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (202:10) <Block             color={color}             state={1}           >
    function create_default_slot_1(ctx) {
    	var t0_value = ctx.total, t0, t1;

    	return {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.rowTotals) && t0_value !== (t0_value = ctx.total)) {
    				set_data(t0, t0_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(t1);
    			}
    		}
    	};
    }

    // (201:8) {#each rowTotals as total}
    function create_each_block_1(ctx) {
    	var current;

    	var block = new Block({
    		props: {
    		color: ctx.color,
    		state: 1,
    		$$slots: { default: [create_default_slot_1] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			block.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(block, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var block_changes = {};
    			if (changed.color) block_changes.color = ctx.color;
    			if (changed.$$scope || changed.rowTotals) block_changes.$$scope = { changed, ctx };
    			block.$set(block_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(block.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(block.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(block, detaching);
    		}
    	};
    }

    // (212:2) {#if colTotals && !!colTotals.length}
    function create_if_block(ctx) {
    	var div, t0, t1, current;

    	var block0 = new Block({
    		props: {
    		color: ctx.color,
    		state: 1,
    		styles: "border-bottom-left-radius: 24px;"
    	},
    		$$inline: true
    	});

    	var each_value = ctx.colTotals;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	var block1 = new Block({
    		props: {
    		color: ctx.color,
    		state: 1,
    		styles: "border-bottom-right-radius: 24px;"
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			block0.$$.fragment.c();
    			t0 = space();

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			block1.$$.fragment.c();
    			attr(div, "class", "flex-row justify-center svelte-w9h21n");
    			add_location(div, file$8, 212, 4, 4968);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(block0, div, null);
    			append(div, t0);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append(div, t1);
    			mount_component(block1, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var block0_changes = {};
    			if (changed.color) block0_changes.color = ctx.color;
    			block0.$set(block0_changes);

    			if (changed.color || changed.colTotals) {
    				each_value = ctx.colTotals;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t1);
    					}
    				}

    				group_outros();
    				for (i = each_value.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}

    			var block1_changes = {};
    			if (changed.color) block1_changes.color = ctx.color;
    			block1.$set(block1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(block0.$$.fragment, local);

    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			transition_in(block1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(block0.$$.fragment, local);

    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			transition_out(block1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(block0, );

    			destroy_each(each_blocks, detaching);

    			destroy_component(block1, );
    		}
    	};
    }

    // (220:8) <Block           color={color}           state={1}         >
    function create_default_slot(ctx) {
    	var t_value = ctx.total, t;

    	return {
    		c: function create() {
    			t = text(t_value);
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.colTotals) && t_value !== (t_value = ctx.total)) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (219:6) {#each colTotals as total}
    function create_each_block(ctx) {
    	var current;

    	var block = new Block({
    		props: {
    		color: ctx.color,
    		state: 1,
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			block.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(block, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var block_changes = {};
    			if (changed.color) block_changes.color = ctx.color;
    			if (changed.$$scope || changed.colTotals) block_changes.$$scope = { changed, ctx };
    			block.$set(block_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(block.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(block.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(block, detaching);
    		}
    	};
    }

    function create_fragment$8(ctx) {
    	var div3, h1, t0, t1, t2, t3, t4, t5, div0, t6, div1, t7, t8, t9, t10, div2, t11_value = ctx.same.toString(), t11, current;

    	var if_block0 = (ctx.levels && !!ctx.levels.length) && create_if_block_6(ctx);

    	var if_block1 = (ctx.colors && !!ctx.colors.length) && create_if_block_5(ctx);

    	var if_block2 = (ctx.colTotals && !!ctx.colTotals.length) && create_if_block_4(ctx);

    	var if_block3 = (ctx.rowTotals && !!ctx.rowTotals.length) && create_if_block_3(ctx);

    	var if_block4 = (ctx.board) && create_if_block_2(ctx);

    	var if_block5 = (ctx.rowTotals && !!ctx.rowTotals.length) && create_if_block_1(ctx);

    	var if_block6 = (ctx.colTotals && !!ctx.colTotals.length) && create_if_block(ctx);

    	return {
    		c: function create() {
    			div3 = element("div");
    			h1 = element("h1");
    			t0 = text(ctx.levelIndex);
    			t1 = text(": ");
    			t2 = text(ctx.title);
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			div0 = element("div");
    			if (if_block2) if_block2.c();
    			t6 = space();
    			div1 = element("div");
    			if (if_block3) if_block3.c();
    			t7 = space();
    			if (if_block4) if_block4.c();
    			t8 = space();
    			if (if_block5) if_block5.c();
    			t9 = space();
    			if (if_block6) if_block6.c();
    			t10 = space();
    			div2 = element("div");
    			t11 = text(t11_value);
    			attr(h1, "class", "svelte-w9h21n");
    			add_location(h1, file$8, 115, 2, 2435);
    			attr(div0, "class", "flex-row justify-center svelte-w9h21n");
    			add_location(div0, file$8, 142, 2, 3251);
    			attr(div1, "class", "flex-row justify-center svelte-w9h21n");
    			add_location(div1, file$8, 164, 2, 3722);
    			attr(div2, "class", "flex-row justify-center svelte-w9h21n");
    			add_location(div2, file$8, 233, 2, 5403);
    			attr(div3, "class", "main svelte-w9h21n");
    			add_location(div3, file$8, 114, 0, 2414);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, h1);
    			append(h1, t0);
    			append(h1, t1);
    			append(h1, t2);
    			append(div3, t3);
    			if (if_block0) if_block0.m(div3, null);
    			append(div3, t4);
    			if (if_block1) if_block1.m(div3, null);
    			append(div3, t5);
    			append(div3, div0);
    			if (if_block2) if_block2.m(div0, null);
    			append(div3, t6);
    			append(div3, div1);
    			if (if_block3) if_block3.m(div1, null);
    			append(div1, t7);
    			if (if_block4) if_block4.m(div1, null);
    			append(div1, t8);
    			if (if_block5) if_block5.m(div1, null);
    			append(div3, t9);
    			if (if_block6) if_block6.m(div3, null);
    			append(div3, t10);
    			append(div3, div2);
    			append(div2, t11);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (!current || changed.levelIndex) {
    				set_data(t0, ctx.levelIndex);
    			}

    			if (!current || changed.title) {
    				set_data(t2, ctx.title);
    			}

    			if (ctx.levels && !!ctx.levels.length) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_6(ctx);
    					if_block0.c();
    					if_block0.m(div3, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.colors && !!ctx.colors.length) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t5);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}

    			if (ctx.colTotals && !!ctx.colTotals.length) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    					transition_in(if_block2, 1);
    				} else {
    					if_block2 = create_if_block_4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				group_outros();
    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});
    				check_outros();
    			}

    			if (ctx.rowTotals && !!ctx.rowTotals.length) {
    				if (if_block3) {
    					if_block3.p(changed, ctx);
    					transition_in(if_block3, 1);
    				} else {
    					if_block3 = create_if_block_3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div1, t7);
    				}
    			} else if (if_block3) {
    				group_outros();
    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});
    				check_outros();
    			}

    			if (ctx.board) {
    				if (if_block4) {
    					if_block4.p(changed, ctx);
    					transition_in(if_block4, 1);
    				} else {
    					if_block4 = create_if_block_2(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div1, t8);
    				}
    			} else if (if_block4) {
    				group_outros();
    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});
    				check_outros();
    			}

    			if (ctx.rowTotals && !!ctx.rowTotals.length) {
    				if (if_block5) {
    					if_block5.p(changed, ctx);
    					transition_in(if_block5, 1);
    				} else {
    					if_block5 = create_if_block_1(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div1, null);
    				}
    			} else if (if_block5) {
    				group_outros();
    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});
    				check_outros();
    			}

    			if (ctx.colTotals && !!ctx.colTotals.length) {
    				if (if_block6) {
    					if_block6.p(changed, ctx);
    					transition_in(if_block6, 1);
    				} else {
    					if_block6 = create_if_block(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div3, t10);
    				}
    			} else if (if_block6) {
    				group_outros();
    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});
    				check_outros();
    			}

    			if ((!current || changed.same) && t11_value !== (t11_value = ctx.same.toString())) {
    				set_data(t11, t11_value);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div3);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    		}
    	};
    }

    function instance$8($$self, $$props, $$invalidate) {
    	

      let { props = {} } = $$props;

      let levels;
      let boards;
      let level;

      let levelIndex = 0;
      let layerIndex = 0;
      let same = false;

      const setLevelIndex = index => {
        $$invalidate('levelIndex', levelIndex = index);
        $$invalidate('level', level = levels[levelIndex]);
      };
      const setLayerIndex = index => { $$invalidate('layerIndex', layerIndex = index); };

      const toggleDisabled = (row, col) => { const $$result = (
        board[row][col] = board[row][col] === -2
          ? -1
          : -2
      ); $$invalidate('board', board), $$invalidate('boards', boards), $$invalidate('levelIndex', levelIndex); return $$result; };

      const toggleEnabled = (row, col) => {
        board[row][col] = board[row][col] === -1
          ? layerIndex
          : -1; $$invalidate('board', board), $$invalidate('boards', boards), $$invalidate('levelIndex', levelIndex);
        $$invalidate('same', same = deepEqual(matrix(solution), matrix(board)));

        if (same && levelIndex < levels.length) {
          setLevelIndex(levelIndex + 1);
        }
      };

      onMount(async () => {
        const resp = await client.query({ query: Levels });
        $$invalidate('levels', levels = resp.data.levels);
        $$invalidate('boards', boards = levels.map(l => l.solution.map(r => r.map(c => -1))));
        $$invalidate('level', level = levels[levelIndex]);
      });

    	const writable_props = ['props'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Griddler> was created with unknown prop '${key}'`);
    	});

    	function click_handler({ index }) {
    		return setLevelIndex(index);
    	}

    	function func({ index }) { setLayerIndex(index); }

    	$$self.$set = $$props => {
    		if ('props' in $$props) $$invalidate('props', props = $$props.props);
    	};

    	let title, colors, solution, board, color, rowTotals, colTotals;

    	$$self.$$.update = ($$dirty = { level: 1, boards: 1, levelIndex: 1, colors: 1, layerIndex: 1, solution: 1 }) => {
    		if ($$dirty.level) { $$invalidate('title', title = level ? level.title : ''); }
    		if ($$dirty.level) { $$invalidate('colors', colors = level ? level.colors : ''); }
    		if ($$dirty.level) { $$invalidate('solution', solution = level ? level.solution : ''); }
    		if ($$dirty.boards || $$dirty.levelIndex) { $$invalidate('board', board = boards ? boards[levelIndex] : null); }
    		if ($$dirty.colors || $$dirty.layerIndex) { $$invalidate('color', color = colors ? colors[layerIndex] : null); }
    		if ($$dirty.colors || $$dirty.solution || $$dirty.layerIndex) { [rowTotals, colTotals] = (!!colors && !!solution)
            ? generateTotals(colors, solution)[layerIndex]
            : [[], []]
          ; $$invalidate('rowTotals', rowTotals), $$invalidate('colors', colors), $$invalidate('solution', solution), $$invalidate('layerIndex', layerIndex), $$invalidate('level', level); $$invalidate('colTotals', colTotals), $$invalidate('colors', colors), $$invalidate('solution', solution), $$invalidate('layerIndex', layerIndex), $$invalidate('level', level); }
    	};

    	return {
    		props,
    		levels,
    		levelIndex,
    		same,
    		setLevelIndex,
    		setLayerIndex,
    		toggleDisabled,
    		toggleEnabled,
    		title,
    		colors,
    		board,
    		color,
    		rowTotals,
    		colTotals,
    		click_handler,
    		func
    	};
    }

    class Griddler extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, ["props"]);
    	}

    	get props() {
    		throw new Error("<Griddler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set props(value) {
    		throw new Error("<Griddler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.6.7 */

    const file$9 = "src/App.svelte";

    function create_fragment$9(ctx) {
    	var t, section, current;

    	var switch_value = ctx.bgs[5];

    	function switch_props(ctx) {
    		return {
    			props: {
    			colors: ['#3ab', '#aa2', '#cf1', '#52a', '#3a1', '#52a', '#3a1', '#aa2', '#cf1'],
    			styles: "position: absolute; z-index: -1; top: 0; bottom: 0; left: 0; right: 0;"
    		},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props());
    	}

    	var griddler = new Griddler({ $$inline: true });

    	return {
    		c: function create() {
    			if (switch_instance) switch_instance.$$.fragment.c();
    			t = space();
    			section = element("section");
    			griddler.$$.fragment.c();
    			add_location(section, file$9, 23, 0, 803);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, t, anchor);
    			insert(target, section, anchor);
    			mount_component(griddler, section, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (switch_value !== (switch_value = ctx.bgs[5])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;
    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});
    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());

    					switch_instance.$$.fragment.c();
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, t.parentNode, t);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			transition_in(griddler.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(griddler.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (switch_instance) destroy_component(switch_instance, detaching);

    			if (detaching) {
    				detach(t);
    				detach(section);
    			}

    			destroy_component(griddler, );
    		}
    	};
    }

    function instance$9($$self) {
    	

      const bgs = [Aare, Clarence, Doubs, Hinterrhein, Inn, Kander, Linth];

    	return { bgs };
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, []);
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {
    		name: 'Griddler'
    	}
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
